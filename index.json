[{"categories":null,"contents":"基础类型内存宽度以及表示范围 bool\n1Byte true/false uint8\n1Byte 0-255 uint16\n2Byte 0-65535 uint32\n4Byte 0-4294967295 uint64\n8Byte 0-18446744073709551615 int8\n1Byte -128-127 int16\n2Byte -32768-32767 int32\n4Byte -2147483648-2147483647 int64\n6Byte -9223372036854775808-9223372036854775807 byte\n1Byte 类似 uint8 rune\n4Byte 类似 int32 uint\n4Byte / 8Byte 32 或 64 位 int\n4Byte / 8Byte 与 uint 一样大小 float32\n4Byte float64\n8Byte string\n1Byte （英文） / 2Byte-4Byte（中文，取决于字符编码类型）     切片拼接 slice1 := []int{0, 1, 2, 3} slice2 := []int{3, 4, 5} slice1 = append(slice1, slice2...) fmt.Println(slice1) //[0 1 2 3 3 4 5]     ","date":"January 1, 0001","hero":"/images/default-hero.jpg","permalink":"https://ormissia.github.io/notes/go/basic/basic/","summary":"基础类型内存宽度以及表示范围 bool\n1Byte true/false uint8\n1Byte 0-255 uint16\n2Byte 0-65535 uint32\n4Byte 0-4294967295 uint64\n8Byte 0-18446744073709551615 int8\n1Byte -128-127 int16\n2Byte -32768-32767 int32\n4Byte -2147483648-2147483647 int64\n6Byte -9223372036854775808-9223372036854775807 byte\n1Byte 类似 uint8 rune\n4Byte 类似 int32 uint\n4Byte / 8Byte 32 或 64 位 int\n4Byte / 8Byte 与 uint 一样大小 float32\n4Byte float64\n8Byte string\n1Byte （英文） / 2Byte-4Byte（中文，取决于字符编码类型）     切片拼接 slice1 := []int{0, 1, 2, 3} slice2 := []int{3, 4, 5} slice1 = append(slice1, slice2.","tags":null,"title":"Basic"},{"categories":null,"contents":"时间转换 字符串转时间\ntime.Parse() 时间转字符串\ntime.Format() 时间转时间戳\nTime.Unix() 时间戳转时间\ntime.Unix()     计时 朴素方法\nstartTime := time.Now() //do something \ttime.Sleep(time.Second) duration := time.Since(startTime) fmt.Printf(\u0026#34;经过时间：%v\\n\u0026#34;, duration) //经过时间：1.005046959s   简洁方法\n// TimeCost 耗时统计函数 func TimeCost(start time.Time) { duration := time.Since(start) fmt.Printf(\u0026#34;经过时间：%v\\n\u0026#34;, duration) } defer TimeCost(time.Now()) //do something \ttime.Sleep(time.Second) //经过时间：1.005054375s   优雅方法\n// TimeCost 耗时统计函数 func TimeCost() func() { start := time.Now() return func() { duration := time.Since(start) fmt.Printf(\u0026#34;经过时间：%v\\n\u0026#34;, duration) } } defer TimeCost()() //do something \ttime.Sleep(time.Second) //经过时间：1.005033916s     ","date":"January 1, 0001","hero":"/images/default-hero.jpg","permalink":"https://ormissia.github.io/notes/go/advance/time/","summary":"时间转换 字符串转时间\ntime.Parse() 时间转字符串\ntime.Format() 时间转时间戳\nTime.Unix() 时间戳转时间\ntime.Unix()     计时 朴素方法\nstartTime := time.Now() //do something \ttime.Sleep(time.Second) duration := time.Since(startTime) fmt.Printf(\u0026#34;经过时间：%v\\n\u0026#34;, duration) //经过时间：1.005046959s   简洁方法\n// TimeCost 耗时统计函数 func TimeCost(start time.Time) { duration := time.Since(start) fmt.Printf(\u0026#34;经过时间：%v\\n\u0026#34;, duration) } defer TimeCost(time.Now()) //do something \ttime.Sleep(time.Second) //经过时间：1.005054375s   优雅方法\n// TimeCost 耗时统计函数 func TimeCost() func() { start := time.Now() return func() { duration := time.Since(start) fmt.","tags":null,"title":"time"},{"categories":null,"contents":"go get 下载指定版本 go get github.com/ormissia/go-opv@v0.0.2     ","date":"January 1, 0001","hero":"/images/default-hero.jpg","permalink":"https://ormissia.github.io/notes/go/advance/gomod/","summary":"go get 下载指定版本 go get github.com/ormissia/go-opv@v0.0.2     ","tags":null,"title":"go mod"},{"categories":null,"contents":"异或  异或运算法则：无进位相加 异或运算性质：  0 ^ N = N N ^ N = 0 满足交换律和结合律    a := 0b1100 b := 0b1001 fmt.Printf(\u0026#34;%b\u0026#34;,a^b) //101 简单应用：不申请额外内存交换两个变量的值\na := 0b1100 b := 0b1001 a = a ^ b b = a ^ b //b = (a ^ b) ^ b = a a = a ^ b //a = (a ^ b) ^ a = b fmt.Printf(\u0026#34;a:%b,b:%b\u0026#34;, a, b) //a:1001,b:1100     ","date":"January 1, 0001","hero":"/images/default-hero.jpg","permalink":"https://ormissia.github.io/notes/go/algorithm/basic/","summary":"异或  异或运算法则：无进位相加 异或运算性质：  0 ^ N = N N ^ N = 0 满足交换律和结合律    a := 0b1100 b := 0b1001 fmt.Printf(\u0026#34;%b\u0026#34;,a^b) //101 简单应用：不申请额外内存交换两个变量的值\na := 0b1100 b := 0b1001 a = a ^ b b = a ^ b //b = (a ^ b) ^ b = a a = a ^ b //a = (a ^ b) ^ a = b fmt.Printf(\u0026#34;a:%b,b:%b\u0026#34;, a, b) //a:1001,b:1100     ","tags":null,"title":"Basic"},{"categories":null,"contents":"Strings test\nString str = \u0026#34;123\u0026#34;;     ","date":"January 1, 0001","hero":"/images/default-hero.jpg","permalink":"https://ormissia.github.io/notes/java/basic/basic_type/","summary":"Strings test\nString str = \u0026#34;123\u0026#34;;     ","tags":null,"title":"Basic Types"},{"categories":null,"contents":"函数 函数参数为val类型，且可以给出默认值\ndef test(a: Int, b: Int = 1, c: Int = 2): Unit = { println(s\u0026quot;$a $b $c\u0026quot;) } test(1, 2) //1 2 2 test(1, c = 4) //1 1 4     匿名函数 函数是带有参数的表达式。\n(x: Int) =\u0026gt; x + 1     方法 方法的表现和行为和函数非常类似，但是它们之间有一些关键的差别。\n方法由def关键字定义。def后面跟着一个名字、参数列表、返回类型和方法体。\ndef addThenMultiply(x: Int, y: Int)(multiplier: Int): Int = (x + y) * multiplier println(addThenMultiply(1, 2)(3)) // 9     字符串拼接 val a = 1 val b = 2 val c = s\u0026quot;$a+$b=${a + b}\u0026quot;     对象 约等于static单例对象\nobject TestObj { def main(args: Array[String]): Unit = { val a = 1 val b = 2 val c = s\u0026quot;$a+$b=${a + b}\u0026quot; println(c) } }     类 可以使用class关键字定义一个类，后面跟着它的名字和构造参数。\n 类里裸露的代码是默认构造中的 类名构造器中的参数就是类的成员属性，默认是val类型，且是private 只有在类名构造器中的参数可以设置成var，其他方法函数中的参数都是val类型的，且不允许设置成var类型  class Greeter(prefix: String, var suffix: String) { var name = \u0026quot;name\u0026quot; def greet(name: String): Unit = println(prefix + name + suffix) }     循环 scala中嵌套for循环可以写到一起，循环上可以加守卫（条件）。 循环结果可以通过yield收集到一个集合中\n// val value = for (i \u0026lt;- 1 to 9; j \u0026lt;- 1 to i) yield { val value = for (i \u0026lt;- 1 to 9; j \u0026lt;- 1 to 10 if (j \u0026lt;= i)) yield { i * j } for (i \u0026lt;- value) { println(i) }     偏应用函数 类似于重新封装一下函数\ndef log(date: Date, logType: String, msg: String): Unit = { println(s\u0026quot;$date\\t$logType\\t$msg\u0026quot;) } val info = log(_, \u0026quot;info\u0026quot;, _) info(new Date, \u0026quot;this is a info msg\u0026quot;) //Thu Jul 22 23:14:04 CST 2021\tinfo\tthis is a info msg     可变长度参数以及foreach def foreachTest(a: Int*): Unit = { //for (i \u0026lt;- a) { // print(i) //} //a.foreach((x: Int) =\u0026gt; { // print(x) //}) //a.foreach(print(_)) a.foreach(print) } foreachTest(1, 2, 3, 4, 5) //12345     高阶函数 函数作为参数\ndef computer(a: Int, b: Int, f: (Int, Int) =\u0026gt; Int): Unit = { val res = f(a, b) println(res) } computer(1, 2, (x: Int, y: Int) =\u0026gt; {x + y}) //3 computer(1, 2, _ + _) //3   函数作为返回值\ndef factory(i: String): (Int, Int) =\u0026gt; Int = { def plus(x: Int, y: Int): Int = { x + y } if (i.equals(\u0026quot;+\u0026quot;)) { plus } else { _ * _ } } val plus = factory(\u0026quot;+\u0026quot;) computer(1,2,plus) //3     柯里化 多个参数列表\ndef testFunc(a:Int*)(b:Int*)(c:String*): Unit ={ a.foreach(print) b.foreach(print) c.foreach(print) } testFunc(1,2,3)(2,3,4)(\u0026quot;3\u0026quot;,\u0026quot;4\u0026quot;,\u0026quot;5\u0026quot;) //123234345     数组 数组 scala中泛型是[]，数组用()\nval约等于final，不可变描述的是val指定的引用（字面值、地址）\nval arr1 = Array[Int](1, 2, 3) arr1(1) = 99 println(arr1(1)) //99   遍历\n for (elem \u0026lt;- arr1) {} //foreach需要函数接收元素 arr1.foreach(println)     链表 scala中collections中有两个包：immutable,mutable，默认是不可变的immutable\nval list1 = List(1, 2, 3, 4) //++ += ++: :++ val list2 = new ListBuffer[Int] list2.+=(1) list2.+=(2) list2.+=(3)   val list1 = List(1, 2, 3, 4) val list2 = list1.map(_ * 2) list2.foreach(print) //2468     Set Set\n不可变的\nval set1 = Set(1, 2, 3, 4, 1, 2) //1 2 3 4   可变的\nval set2 = mutable.Set(1, 2, 3, 4, 1, 2) set2.add(1) set2.add(5) //1 2 3 4 5     Map Map\nval map1 = Map((\u0026quot;a\u0026quot;, 1), \u0026quot;b\u0026quot; -\u0026gt; 2, (\u0026quot;c\u0026quot;, 3), (\u0026quot;a\u0026quot;, 4)) map1.foreach(print) //(a,4)(b,2)(c,3) println(map1.get(\u0026quot;a\u0026quot;)) //Some(4) println(map1.get(\u0026quot;d\u0026quot;)) //None println(map1.getOrElse(\u0026quot;a\u0026quot;, \u0026quot;test\u0026quot;)) //4 println(map1.getOrElse(\u0026quot;d\u0026quot;, \u0026quot;test\u0026quot;)) //test val keys = map1.keys keys.foreach(println)   遍历\nfor (m \u0026lt;- map1) { print(s\u0026quot;$m\u0026quot;) } for (k \u0026lt;- keys) { print(s\u0026quot;($k,${map1(k)})\u0026quot;) }   可变的\nval map2 = mutable.Map((\u0026quot;a\u0026quot;, 1), \u0026quot;b\u0026quot; -\u0026gt; 2, (\u0026quot;c\u0026quot;, 3), (\u0026quot;a\u0026quot;, 4)) map2.put(\u0026quot;a\u0026quot;, 5)     案例类     模式匹配     特质     偏函数     隐式转换     ","date":"January 1, 0001","hero":"/images/default-hero.jpg","permalink":"https://ormissia.github.io/notes/scala/basic/basic_type/","summary":"函数 函数参数为val类型，且可以给出默认值\ndef test(a: Int, b: Int = 1, c: Int = 2): Unit = { println(s\u0026quot;$a $b $c\u0026quot;) } test(1, 2) //1 2 2 test(1, c = 4) //1 1 4     匿名函数 函数是带有参数的表达式。\n(x: Int) =\u0026gt; x + 1     方法 方法的表现和行为和函数非常类似，但是它们之间有一些关键的差别。\n方法由def关键字定义。def后面跟着一个名字、参数列表、返回类型和方法体。\ndef addThenMultiply(x: Int, y: Int)(multiplier: Int): Int = (x + y) * multiplier println(addThenMultiply(1, 2)(3)) // 9     字符串拼接 val a = 1 val b = 2 val c = s\u0026quot;$a+$b=${a + b}\u0026quot;     对象 约等于static单例对象","tags":null,"title":"Basic Types"},{"categories":null,"contents":"函数     ","date":"January 1, 0001","hero":"/images/default-hero.jpg","permalink":"https://ormissia.github.io/notes/python/basic/basic/","summary":"函数     ","tags":null,"title":"Basic"},{"categories":null,"contents":"函数     ","date":"January 1, 0001","hero":"/images/default-hero.jpg","permalink":"https://ormissia.github.io/notes/js/basic/basic/","summary":"函数     ","tags":null,"title":"Basic"},{"categories":null,"contents":"按年月日分组聚合 group by date_format(field_name, format); 根据format字符串格式化date值。下列修饰符可以被用在format字符串中：\n%M 月名字(January……December) %W 星期名字(Sunday……Saturday) %D 有英语前缀的月份的日期(1st, 2nd, 3rd, 等等。） %Y 年, 数字, 4 位 %y 年, 数字, 2 位 %a 缩写的星期名字(Sun……Sat) %d 月份中的天数, 数字(00……31) %e 月份中的天数, 数字(0……31) %m 月, 数字(01……12) %c 月, 数字(1……12) %b 缩写的月份名字(Jan……Dec) %j 一年中的天数(001……366) %H 小时(00……23) %k 小时(0……23) %h 小时(01……12) %I 小时(01……12) %l 小时(1……12) %i 分钟, 数字(00……59) %r 时间,12 小时(hh:mm:ss [AP]M) %T 时间,24 小时(hh:mm:ss) %S 秒(00……59) %s 秒(00……59) %p AM或PM %w 一个星期中的天数(0=Sunday ……6=Saturday ） %U 星期(0……52), 这里星期天是星期的第一天 %u 星期(0……52), 这里星期一是星期的第一天 %% 一个文字“%”     count统计不重复个数 select count(distinct (field_name)) from table_name     ","date":"January 1, 0001","hero":"/images/default-hero.jpg","permalink":"https://ormissia.github.io/notes/sql/dml/dml/","summary":"按年月日分组聚合 group by date_format(field_name, format); 根据format字符串格式化date值。下列修饰符可以被用在format字符串中：\n%M 月名字(January……December) %W 星期名字(Sunday……Saturday) %D 有英语前缀的月份的日期(1st, 2nd, 3rd, 等等。） %Y 年, 数字, 4 位 %y 年, 数字, 2 位 %a 缩写的星期名字(Sun……Sat) %d 月份中的天数, 数字(00……31) %e 月份中的天数, 数字(0……31) %m 月, 数字(01……12) %c 月, 数字(1……12) %b 缩写的月份名字(Jan……Dec) %j 一年中的天数(001……366) %H 小时(00……23) %k 小时(0……23) %h 小时(01……12) %I 小时(01……12) %l 小时(1……12) %i 分钟, 数字(00……59) %r 时间,12 小时(hh:mm:ss [AP]M) %T 时间,24 小时(hh:mm:ss) %S 秒(00……59) %s 秒(00……59) %p AM或PM %w 一个星期中的天数(0=Sunday ……6=Saturday ） %U 星期(0……52), 这里星期天是星期的第一天 %u 星期(0……52), 这里星期一是星期的第一天 %% 一个文字“%”     count统计不重复个数 select count(distinct (field_name)) from table_name     ","tags":null,"title":"SQL DML"},{"categories":null,"contents":"快捷键 回到命令行开头\u0026ndash;Home\nCtrl+a 回到命令行的尾部\u0026ndash;End\nCtrl+e   删除光标前边的所有字符\nCtrl+u 删除光标后边的所有字符\nCtrl+k 删除光标前的一个单词\nCtrl+w   输入曾经的命令下的某个单词或字母，按照单词的匹配history\nCtrl+r     cat 在cat输出时候显示行数\ncat -n maim.go     wc 统计文件行、单词、字符数量 格式：\nusage: wc [-clmw] [file ...] 统计main.go的行、单词、字符数量\nwc main.go 选项：\n-l 统计行数 -c 统计字符数 -w 统计单词数 -L 统计最长的行的字符数     nc 简单的文件传输工具\n接收方\nnc -l [port] \u0026gt; filename 发送方\nnc [ip] [port] \u0026lt; filename     gzip 解压*.gz的压缩文件\n与*.tar.gz文件不同，*.gz文件需要用gzip来解压\ngzip -d filename     ","date":"January 1, 0001","hero":"/images/default-hero.jpg","permalink":"https://ormissia.github.io/notes/linux/shell/basic/","summary":"快捷键 回到命令行开头\u0026ndash;Home\nCtrl+a 回到命令行的尾部\u0026ndash;End\nCtrl+e   删除光标前边的所有字符\nCtrl+u 删除光标后边的所有字符\nCtrl+k 删除光标前的一个单词\nCtrl+w   输入曾经的命令下的某个单词或字母，按照单词的匹配history\nCtrl+r     cat 在cat输出时候显示行数\ncat -n maim.go     wc 统计文件行、单词、字符数量 格式：\nusage: wc [-clmw] [file ...] 统计main.go的行、单词、字符数量\nwc main.go 选项：\n-l 统计行数 -c 统计字符数 -w 统计单词数 -L 统计最长的行的字符数     nc 简单的文件传输工具\n接收方\nnc -l [port] \u0026gt; filename 发送方\nnc [ip] [port] \u0026lt; filename     gzip 解压*.","tags":null,"title":"Basic"},{"categories":null,"contents":"xargs xargs是给命令传递参数的一个过滤器，可以将管道或标准输入（stdin）数据转换成命令行参数，也能够从文件的输出中读取数据，一般是和管道一起使用。 格式:\nsomecommand | xargs [-item] [command] 选项：\n-a file 从文件中读入作为 stdin -e flag ，注意有的时候可能会是-E，flag必须是一个以空格分隔的标志，当xargs分析到含有flag这个标志的时候就停止。 -p 当每次执行一个argument的时候询问一次用户。 -n num 后面加次数，表示命令在执行的时候一次用的argument的个数，默认是用所有的。 -t 表示先打印命令，然后再执行。 -i 或者是-I，这得看linux支持了，将xargs的每项名称，一般是一行一行赋值给 {}，可以用 {} 代替。 -r no-run-if-empty 当xargs的输入为空的时候则停止xargs，不用再去执行了。 -s num 命令行的最大字符数，指的是 xargs 后面那个命令的最大命令行字符数。 -L num 从标准输入一次读取 num 行送给 command 命令。 -l 同 -L。 -d delim 分隔符，默认的xargs分隔符是回车，argument的分隔符是空格，这里修改的是xargs的分隔符。 -x exit的意思，主要是配合-s使用。。     ","date":"January 1, 0001","hero":"/images/default-hero.jpg","permalink":"https://ormissia.github.io/notes/linux/shell/advance/","summary":"xargs xargs是给命令传递参数的一个过滤器，可以将管道或标准输入（stdin）数据转换成命令行参数，也能够从文件的输出中读取数据，一般是和管道一起使用。 格式:\nsomecommand | xargs [-item] [command] 选项：\n-a file 从文件中读入作为 stdin -e flag ，注意有的时候可能会是-E，flag必须是一个以空格分隔的标志，当xargs分析到含有flag这个标志的时候就停止。 -p 当每次执行一个argument的时候询问一次用户。 -n num 后面加次数，表示命令在执行的时候一次用的argument的个数，默认是用所有的。 -t 表示先打印命令，然后再执行。 -i 或者是-I，这得看linux支持了，将xargs的每项名称，一般是一行一行赋值给 {}，可以用 {} 代替。 -r no-run-if-empty 当xargs的输入为空的时候则停止xargs，不用再去执行了。 -s num 命令行的最大字符数，指的是 xargs 后面那个命令的最大命令行字符数。 -L num 从标准输入一次读取 num 行送给 command 命令。 -l 同 -L。 -d delim 分隔符，默认的xargs分隔符是回车，argument的分隔符是空格，这里修改的是xargs的分隔符。 -x exit的意思，主要是配合-s使用。。     ","tags":null,"title":"Advance"},{"categories":null,"contents":"快捷键     命令 显示行号\n:set number   在vi中执行shell命令\n:!ls-l   将shell命令的结果插入到当前行的下一行\n:r !date //读取系统时间并插入到当前行的下一行   将起始行号和结束行号指定的范围中的内容输入到shell命令command处理，并将处理结果替换起始行号和结束行号指定的范围中的内容\n:62,72 !sort //将62行到72行的内容进行排序 当前光标所在行，除可以指定行号外，也可以用.表示\n:. !tr [a-z] [A-Z] //将当前行的小写转为大写   将起始行号和结束行号所指定的范围的内容作为命令command的输入，不会改变当前编辑的文件的内容\n:62,72 w !sort //将62行到72行的内容进行排序，但排序的结果并不会直接输出到当前编辑的文件中，而是显示在vim敲命令的区域   将某一行作为shell命令执行\n:62 w !bash //将会把第62行的内容作为bash命令来执行并显示结果，而且不会改变当前编辑的文件的内容     ","date":"January 1, 0001","hero":"/images/default-hero.jpg","permalink":"https://ormissia.github.io/notes/linux/tool/vi/","summary":"快捷键     命令 显示行号\n:set number   在vi中执行shell命令\n:!ls-l   将shell命令的结果插入到当前行的下一行\n:r !date //读取系统时间并插入到当前行的下一行   将起始行号和结束行号指定的范围中的内容输入到shell命令command处理，并将处理结果替换起始行号和结束行号指定的范围中的内容\n:62,72 !sort //将62行到72行的内容进行排序 当前光标所在行，除可以指定行号外，也可以用.表示\n:. !tr [a-z] [A-Z] //将当前行的小写转为大写   将起始行号和结束行号所指定的范围的内容作为命令command的输入，不会改变当前编辑的文件的内容\n:62,72 w !sort //将62行到72行的内容进行排序，但排序的结果并不会直接输出到当前编辑的文件中，而是显示在vim敲命令的区域   将某一行作为shell命令执行\n:62 w !bash //将会把第62行的内容作为bash命令来执行并显示结果，而且不会改变当前编辑的文件的内容     ","tags":null,"title":"vi"},{"categories":null,"contents":"Este archivo existe únicamente para responder a la URL /search con la plantilla de diseño search relacionada.\nNo se muestra ningún contenido aquí, todo el contenido se basa en la plantilla layouts/page/search.html\nEstablecer una prioridad muy baja en el mapa del sitio le dirá a los motores de búsqueda que éste no es un contenido importante.\nEsta implementación utiliza Fusejs, jquery y mark.js\nConfiguración inicial La búsqueda depende del tipo de contenido de salida adicional de JSON en config.toml\n``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nBúsqueda de archivos adicionales Para buscar campos adicionales definidos en el front matter, debes añadirlo en 2 lugares.\nEditar layouts/_default/index.JSON Esto expone los valores en /index.json: por ejemplo, para agregar categories ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEditar las opciones de fuse.js para buscar static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://ormissia.github.io/search/","summary":"Este archivo existe únicamente para responder a la URL /search con la plantilla de diseño search relacionada.\nNo se muestra ningún contenido aquí, todo el contenido se basa en la plantilla layouts/page/search.html\nEstablecer una prioridad muy baja en el mapa del sitio le dirá a los motores de búsqueda que éste no es un contenido importante.\nEsta implementación utiliza Fusejs, jquery y mark.js\nConfiguración inicial La búsqueda depende del tipo de contenido de salida adicional de JSON en config.","tags":null,"title":"Resultados de Búsqueda"},{"categories":null,"contents":"Este archivo existe únicamente para responder a la URL /search con la plantilla de diseño search relacionada.\nNo se muestra ningún contenido aquí, todo el contenido se basa en la plantilla layouts/page/search.html\nEstablecer una prioridad muy baja en el mapa del sitio le dirá a los motores de búsqueda que éste no es un contenido importante.\nEsta implementación utiliza Fusejs, jquery y mark.js\nConfiguración inicial La búsqueda depende del tipo de contenido de salida adicional de JSON en config.toml\n``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nBúsqueda de archivos adicionales Para buscar campos adicionales definidos en el front matter, debes añadirlo en 2 lugares.\nEditar layouts/_default/index.JSON Esto expone los valores en /index.json: por ejemplo, para agregar categories ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEditar las opciones de fuse.js para buscar static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://ormissia.github.io/search/","summary":"Este archivo existe únicamente para responder a la URL /search con la plantilla de diseño search relacionada.\nNo se muestra ningún contenido aquí, todo el contenido se basa en la plantilla layouts/page/search.html\nEstablecer una prioridad muy baja en el mapa del sitio le dirá a los motores de búsqueda que éste no es un contenido importante.\nEsta implementación utiliza Fusejs, jquery y mark.js\nConfiguración inicial La búsqueda depende del tipo de contenido de salida adicional de JSON en config.","tags":null,"title":"Resultados de Búsqueda"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://ormissia.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://ormissia.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://ormissia.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://ormissia.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://ormissia.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://ormissia.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://ormissia.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://ormissia.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://ormissia.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://ormissia.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://ormissia.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://ormissia.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://ormissia.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://ormissia.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://ormissia.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://ormissia.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://ormissia.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://ormissia.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://ormissia.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://ormissia.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://ormissia.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://ormissia.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"অনুসন্ধানের ফলাফল"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://ormissia.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"অনুসন্ধানের ফলাফল"},{"categories":null,"contents":"归并排序  思想：整体是递归（当然可以用非递归实现），使左边有序，使右边有序，合并左边右边使整体有序\n 核心代码：\nfunc merge(arr []interface{}, l, mid, r int, compare Compare) { help := make([]interface{}, r-l+1) i := 0 p1 := l p2 := mid + 1 for p1 \u0026lt;= mid \u0026amp;\u0026amp; p2 \u0026lt;= r { if compare(arr[p1], arr[p2]) { help[i] = arr[p1] p1++ } else { help[i] = arr[p2] p2++ } i++ } //要么p1越界了，要么p2越界了 \tfor p1 \u0026lt;= mid { help[i] = arr[p1] i++ p1++ } for p2 \u0026lt;= r { help[i] = arr[p2] i++ p2++ } for j, _ := range help { arr[l+j] = help[j] } } 递归 核心代码\nfunc mergeProcess(arr []interface{}, l, r int, compare Compare) { if l == r { return } mid := l + ((r - l) \u0026gt;\u0026gt; 1) mergeProcess(arr, l, mid, compare) mergeProcess(arr, mid+1, r, compare) merge(arr, l, mid, r, compare) } 非递归 核心代码：\nn := len(arr) mergeSize := 1 //当前有序的左组长度 \tfor mergeSize \u0026lt; n { l := 0 for l \u0026lt; n { m := l + mergeSize - 1 if m \u0026gt;= n { break } r := m + mergeSize if m+mergeSize \u0026gt; n-1 { r = n - 1 } merge(arr, l, m, r, s.Compare) l = r + 1 } //防止溢出 \tif mergeSize \u0026gt; n/2 { break } mergeSize \u0026lt;\u0026lt;= 1 } 快速排序  思想：给定一个数组arr和一个整数num，把小于等于num的数放在数组左边，大于num的数放在数组的右边。\n  额外空间复杂度是O(1)，时间复杂度O(N)\n 核心代码：\nfunc netherlandsFlag(arr []interface{}, l, r int, isEqual, isSmall Compare) (i, j int) { if l \u0026gt; r { return -1, -1 } if l == r { return l, r } less := l - 1 //小于arr[R]区\t右边界 \tmore := r //大于arr[R]区\t左边界 \tindex := l for index \u0026lt; more { if isEqual(arr[index], arr[r]) { index++ } else if isSmall(arr[index], arr[r]) { less++ arr[index], arr[less] = arr[less], arr[index] index++ } else { more-- arr[index], arr[more] = arr[more], arr[index] } } arr[more], arr[r] = arr[r], arr[more] return less + 1, more } 递归 核心代码：\nfunc quickProcess(arr []interface{}, l, r int, isEqual, isSmall Compare) { if l \u0026gt;= r { return } n := rand.Intn(r-l+1) + l arr[n], arr[r] = arr[r], arr[n] i, j := netherlandsFlag(arr, l, r, isEqual, isSmall) quickProcess(arr, l, i-1, isEqual, isSmall) quickProcess(arr, j+1, r, isEqual, isSmall) } ","date":"August 7, 2021","hero":"/posts/algorithm/4001-algorithm-sort/head.svg","permalink":"https://ormissia.github.io/posts/algorithm/4001-algorithm-sort/","summary":"归并排序  思想：整体是递归（当然可以用非递归实现），使左边有序，使右边有序，合并左边右边使整体有序\n 核心代码：\nfunc merge(arr []interface{}, l, mid, r int, compare Compare) { help := make([]interface{}, r-l+1) i := 0 p1 := l p2 := mid + 1 for p1 \u0026lt;= mid \u0026amp;\u0026amp; p2 \u0026lt;= r { if compare(arr[p1], arr[p2]) { help[i] = arr[p1] p1++ } else { help[i] = arr[p2] p2++ } i++ } //要么p1越界了，要么p2越界了 \tfor p1 \u0026lt;= mid { help[i] = arr[p1] i++ p1++ } for p2 \u0026lt;= r { help[i] = arr[p2] i++ p2++ } for j, _ := range help { arr[l+j] = help[j] } } 递归 核心代码","tags":null,"title":"排序算法"},{"categories":null,"contents":" pprof is a tool for visualization and analysis of profiling data.\n  pprof reads a collection of profiling samples in profile.proto format and generates reports to visualize and help analyze the data. It can generate both text and graphical reports (through the use of the dot visualization package).\n  PProf是用于可视化和分析性能分析数据的工具，PProf以profile.proto读取分析样本的集合，并生成报告以可视化并帮助分析数据（支持文本和图形报告）。\n 简介 采集方式  runtime/pprof：采集程序（非Server）的指定区块的运行数据进行分析。 net/http/pprof：基于HTTPServer运行，并且可以采集运行时数据进行分析。 gotest：通过运行测试用例，并指定所需标识来进行采集。  功能  CPUProfiling：CPU分析，按照一定的频率采集所监听的应用程序CPU（含寄存器）的使用情况，可确定应用程序在主动消耗CPU周期时花费时间的位置。 MemoryProfiling：内存分析，在应用程序进行堆分配时记录堆栈跟踪，用于监视当前和历史内存使用情况，以及检查内存泄漏。 BlockProfiling：阻塞分析，记录Goroutine阻塞等待同步（包括定时器通道）的位置，默认不开启，需要调用runtime.SetBlockProfileRate进行设置。 MutexProfiling：互斥锁分析，报告互斥锁的竞争情况，默认不开启，需要调用runtime.SetMutexProfileFraction进行设置。 GoroutineProfiling：Goroutine分析，可以对当前应用程序正在运行的Goroutine进行堆栈跟踪和分析。这项功能在实际排查中会经常用到， 因为很多问题出现时的表象就是Goroutine暴增，而这时候我们要做的事情之一就是查看应用程序中的Goroutine正在做什么事情，因为什么阻塞了， 然后再进行下一步。  简单的例子 注意要在import中引入 _ \u0026quot;net/http/pprof\u0026quot;\npackage main import ( \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; _ \u0026#34;net/http/pprof\u0026#34; \u0026#34;time\u0026#34; ) func main() { go func() { for { log.Println(\u0026#34;pprof\u0026#34;) time.Sleep(time.Second) } }() if err := http.ListenAndServe(\u0026#34;0.0.0.0:6060\u0026#34;, nil); err != nil { log.Println(err) return } } 通过web页面访问 运行之后打开页面http://127.0.0.1:6060/debug/pprof/\n/debug/pprof/ Types of profiles available: Count\tProfile 0\tallocs 0\tblock 0\tcmdline 5\tgoroutine 0\theap 0\tmutex 0\tprofile 7\tthreadcreate 0\ttrace full goroutine stack dump Profile Descriptions: allocs: A sampling of all past memory allocations block: Stack traces that led to blocking on synchronization primitives cmdline: The command line invocation of the current program goroutine: Stack traces of all current goroutines heap: A sampling of memory allocations of live objects. You can specify the gc GET parameter to run GC before taking the heap sample. mutex: Stack traces of holders of contended mutexes profile: CPU profile. You can specify the duration in the seconds GET parameter. After you get the profile file, use the go tool pprof command to investigate the profile. threadcreate: Stack traces that led to the creation of new OS threads trace: A trace of execution of the current program. You can specify the duration in the seconds GET parameter. After you get the trace file, use the go tool trace command to investigate the trace. 通过终端访问 go tool pprof http://localhost:6060/debug/pprof/profile\\?seconds\\=60 执行该命令后，需等待60秒（可调整seconds的值），pprof会进行CPU Profiling。结束后将默认进入pprof的交互式命令模式， 可以对分析的结果进行查看或导出。\nFetching profile over HTTP from http://localhost:6060/debug/pprof/profile?seconds=60 Saved profile in /Users/orimissia/pprof/pprof.samples.cpu.003.pb.gz Type: cpu Time: Aug 6, 2021 at 2:41pm (CST) Duration: 1mins, Total samples = 10ms (0.017%) Entering interactive mode (type \u0026#34;help\u0026#34; for commands, \u0026#34;o\u0026#34; for options) (pprof) 具体可执行pprof help查看命令说明\n(pprof) top10 Showing nodes accounting for 10ms, 100% of 10ms total flat flat% sum% cum cum% 10ms 100% 100% 10ms 100% runtime.kevent 0 0% 100% 10ms 100% runtime.findrunnable 0 0% 100% 10ms 100% runtime.mcall 0 0% 100% 10ms 100% runtime.netpoll 0 0% 100% 10ms 100% runtime.park_m 0 0% 100% 10ms 100% runtime.schedule  flat：给定函数上运行耗时 flat%：同上的CPU运行耗时总比例 sum%：给定函数累积使用CPU总比例 cum：当前函数加上它之上的调用运行总耗时 cum%：同上的CPU运行耗时总比例   最后一列为函数名称，在大多数的情况下，我们可以通过这五列得出一个应用程序的运行情况，加以优化。\n go tool pprof http://localhost:6060/debug/pprof/heap Saved profile in /Users/orimissia/pprof/pprof.alloc_objects.alloc_space.inuse_objects.inuse_space.001.pb.gz Type: inuse_space Time: Aug 6, 2021 at 2:46pm (CST) No samples were found with the default sample value type. Try \u0026#34;sample_index\u0026#34; command to analyze different sample values. Entering interactive mode (type \u0026#34;help\u0026#34; for commands, \u0026#34;o\u0026#34; for options)  -inuse_space：分析应用程序的常驻内存占用情况 -alloc_objects：分析应用程序的内存临时分配情况  可视化界面 新建测试用例：\npackage main import \u0026#34;testing\u0026#34; const str = \u0026#34;ormissia\u0026#34; func TestAdd(t *testing.T) { s := Con(str) if s == \u0026#34;\u0026#34; { t.Errorf(\u0026#34;Test.Add error!\u0026#34;) } } func BenchmarkAdd(b *testing.B) { for i := 0; i \u0026lt; b.N; i++ { Con(str) } } func Con(str string) string { data := []byte(str) sData := string(data) return sData } 执行测试用例\n% go test -bench=. -cpuprofile=cpu.prof goos: darwin goarch: arm64 pkg: awesomeProject/pprof BenchmarkAdd-8 182690547 6.330 ns/op PASS ok awesomeProject/pprof 2.366s 启动pprof可视化界面\n方法一\ngo tool pprof -http=:8080 cpu.prof 方法二\ngo tool pprof cpu.prof (pprof) web 可视化界面\n参考  https://github.com/google/pprof https://golang2.eddycjy.com/posts/ch6/01-pprof-1  ","date":"August 5, 2021","hero":"/posts/knowledge/2004-go-pprof/head.svg","permalink":"https://ormissia.github.io/posts/knowledge/2004-go-pprof/","summary":"pprof is a tool for visualization and analysis of profiling data.\n  pprof reads a collection of profiling samples in profile.proto format and generates reports to visualize and help analyze the data. It can generate both text and graphical reports (through the use of the dot visualization package).\n  PProf是用于可视化和分析性能分析数据的工具，PProf以profile.proto读取分析样本的集合，并生成报告以可视化并帮助分析数据（支持文本和图形报告）。\n 简介 采集方式  runtime/pprof：采集程序（非Server）的指定区块的运行数据进行分析。 net/http/pprof：基于HTTPServer运行，并且可以采集运行时数据进行分析。 gotest：通过运行测试用例，并指定所需标识来进行采集。  功能  CPUProfiling：CPU分析，按照一定的频率采集所监听的应用程序CPU（含寄存器）的使用情况，可确定应用程序在主动消耗CPU周期时花费时间的位置。 MemoryProfiling：内存分析，在应用程序进行堆分配时记录堆栈跟踪，用于监视当前和历史内存使用情况，以及检查内存泄漏。 BlockProfiling：阻塞分析，记录Goroutine阻塞等待同步（包括定时器通道）的位置，默认不开启，需要调用runtime.SetBlockProfileRate进行设置。 MutexProfiling：互斥锁分析，报告互斥锁的竞争情况，默认不开启，需要调用runtime.SetMutexProfileFraction进行设置。 GoroutineProfiling：Goroutine分析，可以对当前应用程序正在运行的Goroutine进行堆栈跟踪和分析。这项功能在实际排查中会经常用到， 因为很多问题出现时的表象就是Goroutine暴增，而这时候我们要做的事情之一就是查看应用程序中的Goroutine正在做什么事情，因为什么阻塞了， 然后再进行下一步。  简单的例子 注意要在import中引入 _ \u0026quot;net/http/pprof\u0026quot;","tags":null,"title":"Golang性能分析工具-pprof"},{"categories":null,"contents":"反射简介  Golang提供了一种机制，在编译时不知道类型的情况下，可更新变量、运行时查看值、调用方法以及直接对他们的布局进行操作的机制，称为反射。\n  reflect 包中的官方注释：Package reflect implements run-time reflection, allowing a program to manipulate objects with arbitrary types. \n reflect 实现了运行时的反射能力，能够让程序操作不同类型的对象。反射包中有两对非常重要的函数和类型， 两个函数分别是：\n reflect.TypeOf 能获取类型信息 reflect.ValueOf 能获取数据的运行时表示  三大法则 运行时反射是程序在运行期间检查其自身结构的一种方式。反射带来的灵活性是一把双刃剑，反射作为一种元编程方式可以减少重复代码， 但是过量的使用反射会使我们的程序逻辑变得难以理解并且运行缓慢。我们在这一节中会介绍Go语言反射的三大法则，其中包括：\n 从interface{}变量可以反射出反射对象； 从反射对象可以获取interface{}变量； 要修改反射对象，其值必须可设置；  第一法则 反射的第一法则是我们能将Go语言的interface{}变量转换成反射对象。很多读者可能会对这以法则产生困惑—为什么是从interface{}变量到反射对象？ 当我们执行reflect.ValueOf(1)时，虽然看起来是获取了基本类型int对应的反射类型，但是由于 reflect.TypeOf 、 reflect.ValueOf 两个方法的入参都是interface{}类型，所以在方法执行的过程中发生了类型转换。\n因为Go语言的函数调用都是值传递的，所以变量会在函数调用时进行类型转换。基本类型int会转换成interface{}类型， 这也就是为什么第一条法则是从接口到反射对象。\n上面提到的reflect.TypeOf 和reflect.ValueOf 函数就能完成这里的转换，如果我们认为Go语言的类型和反射类型处于两个不同的世界，那么这两个函数就是连接这两个世界的桥梁。\n我们可以通过以下例子简单介绍它们的作用， reflect.TypeOf 获取了变量author的类型， reflect.ValueOf 获取了变量的值ormissia。如果我们知道了一个变量的类型和值，那么就意味着我们知道了这个变量的全部信息。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { author := \u0026#34;ormissia\u0026#34; fmt.Println(\u0026#34;TypeOf author:\u0026#34;, reflect.TypeOf(author)) fmt.Println(\u0026#34;ValueOf author:\u0026#34;, reflect.ValueOf(author)) } $ go run main.go TypeOf author: string ValueOf author: ormissia 有了变量的类型之后，我们可以通过Method方法获得类型实现的方法，通过Field获取类型包含的全部字段。对于不同的类型， 我们也可以调用不同的方法获取相关信息：\n 结构体：获取字段的数量并通过下标和字段名获取字段StructField； 哈希表：获取哈希表的Key类型； 函数或方法：获取入参和返回值的类型； …  总而言之，使用reflect.TypeOf 和reflect.ValueOf 能够获取Go语言中的变量对应的反射对象。一旦获取了反射对象，我们就能得到跟当前类型相关数据和操作，并可以使用这些运行时获取的结构执行方法。\n第二法则 反射的第二法则是我们可以从反射对象可以获取interface{}变量。既然能够将接口类型的变量转换成反射对象， 那么一定需要其他方法将反射对象还原成接口类型的变量，reflect 中的 reflect.Value.Interface 就能完成这项工作\n不过调用reflect.Value.Interface 方法只能获得interface{}类型的变量，如果想要将其还原成最原始的状态还需要经过如下所示的显式类型转换：\nv := reflect.ValueOf(1) v.Interface().(int) 从反射对象到接口值的过程是从接口值到反射对象的镜面过程，两个过程都需要经历两次转换：\n 从接口值到反射对象：  从基本类型到接口类型的类型转换； 从接口类型到反射对象的转换；   从反射对象到接口值：  反射对象转换成接口类型； 通过显式类型转换变成原始类型；    当然不是所有的变量都需要类型转换这一过程。如果变量本身就是interface{}类型的，那么它不需要类型转换，因为类型转换这一过程一般都是隐式的， 所以我不太需要关心它，只有在我们需要将反射对象转换回基本类型时才需要显式的转换操作。\n第三法则 Go语言反射的最后一条法则是与值是否可以被更改有关，如果我们想要更新一个 reflect.Value ， 那么它持有的值一定是可以被更新的，假设我们有以下代码：\nfunc main() { i := 1 v := reflect.ValueOf(i) v.SetInt(10) fmt.Println(i) } $ go run reflect.go panic: reflect: reflect.Value.SetInt using unaddressable value goroutine 1 [running]: reflect.flag.mustBeAssignableSlow(0x82) /usr/local/go/src/reflect/value.go:260 +0x118 reflect.flag.mustBeAssignable(...) /usr/local/go/src/reflect/value.go:247 reflect.Value.SetInt(0x100196bc0, 0x10021f8e8, 0x82, 0xa) /usr/local/go/src/reflect/value.go:1637 +0x30 main.main() /Users/orimissia/workspace/awesomeProject/goroutine/main.go:13 +0xb8 运行上述代码会导致程序崩溃并报出“reflect:reflect.flag.mustBeAssignableusingunaddressablevalue”错误， 仔细思考一下就能够发现出错的原因：由于Go语言的函数调用都是传值的，所以我们得到的反射对象跟最开始的变量没有任何关系， 那么直接修改反射对象无法改变原始变量，程序为了防止错误就会崩溃。\n想要修改原变量只能使用如下的方法：\nfunc main() { i := 1 v := reflect.ValueOf(\u0026amp;i) v.Elem().SetInt(10) fmt.Println(i) } $ go run reflect.go 10  调用reflect.ValueOf 获取变量指针； 调用reflect.Value.Elem 获取指针指向的变量； 调用reflect.Value.SetInt 更新变量的值：  由于Go语言的函数调用都是值传递的，所以我们只能只能用迂回的方式改变原变量：先获取指针对应的 reflect.Value ， 再通过reflect.Value.Elem 方法得到可以被设置的变量，我们可以通过下面的代码理解这个过程：\nfunc main() { i := 1 v := \u0026amp;i *v = 10 } 如果不能直接操作i变量修改其持有的值，我们就只能获取i变量所在地址并使用*v修改所在地址中存储的整数。\n类型和值 Go语言的interface{}类型在语言内部是通过reflect.emptyInterface 结体表示的，其中的rtype字段用于表示变量的类型，另一个word字段指向内部封装的数据：\ntype emptyInterface struct { typ *rtype word unsafe.Pointer } 用于获取变量类型的reflect.TypeOf函数将传入的变量隐式转换成 reflect.emptyInterface 类型并获取其中存储的类型信息reflect.rtype：\nfunc TypeOf(i interface{}) Type { eface := *(*emptyInterface)(unsafe.Pointer(\u0026amp;i)) return toType(eface.typ) } func toType(t *rtype) Type { if t == nil { return nil } return t } reflect.rtype是一个实现了reflect.Type接口的结构体，该结构体实现的 reflect.rtype.String 方法可以帮助我们获取当前类型的名称：\nfunc (t *rtype) String() string { s := t.nameOff(t.str).name() if t.tflag\u0026amp;tflagExtraStar != 0 { return s[1:] } return s } reflect.TypeOf 的实现原理其实并不复杂，它只是将一个interface{}变量转换成了内部的 reflect.emptyInterface 表示，然后从中获取相应的类型信息。\n用于获取接口值reflect.Value 的函数reflect.ValueOf 实现也非常简单，在该函数中我们先调用了 reflect.escapes 保证当前值逃逸到堆上，然后通过 reflect.unpackEface 从接口中获取reflect.Value 结构体：\nfunc ValueOf(i interface{}) Value { if i == nil { return Value{} } escapes(i) return unpackEface(i) } func unpackEface(i interface{}) Value { e := (*emptyInterface)(unsafe.Pointer(\u0026amp;i)) t := e.typ if t == nil { return Value{} } f := flag(t.Kind()) if ifaceIndir(t) { f |= flagIndir } return Value{t, e.word, f} } reflect.unpackEface 会将传入的接口转换成 reflect.emptyInterface， 然后将具体类型和指针包装成 reflect.Value 结构体后返回。\nreflect.TypeOf 和reflect.ValueOf 的实现都很简单。我们已经分析了这两个函数的实现，现在需要了解编译器在调用函数之前做了哪些工作：\npackage main import ( \u0026#34;reflect\u0026#34; ) func main() { i := 20 _ = reflect.TypeOf(i) } $ go build -gcflags=\u0026#34;-S -N\u0026#34; main.go ... MOVQ\t$20, \u0026#34;\u0026#34;..autotmp_20+56(SP) // autotmp = 20 LEAQ\ttype.int(SB), AX // AX = type.int(SB) MOVQ\tAX, \u0026#34;\u0026#34;..autotmp_19+280(SP) // autotmp_19+280(SP) = type.int(SB) LEAQ\t\u0026#34;\u0026#34;..autotmp_20+56(SP), CX // CX = 20 MOVQ\tCX, \u0026#34;\u0026#34;..autotmp_19+288(SP) // autotmp_19+288(SP) = 20 ... 从上面这段截取的汇编语言，我们可以发现在函数调用之前已经发生了类型转换，上述指令将int类型的变量转换成了占用16字节 autotmp_19+280(SP) ~ autotmp_19+288(SP)的接口，两个LEAQ指令分别获取了类型的指针type.int(SB)以及变量i所在的地址。\n当我们想要将一个变量转换成反射对象时，Go语言会在编译期间完成类型转换，将变量的类型和值转换成了interface{}并等待运行期间使用 reflect 包获取接口中存储的信息。\n更新变量 当我们想要更新reflect.Value 时，就需要调用 reflect.Value.Set 更新反射对象，该方法会调用 reflect.flag.mustBeAssignable 和reflect.flag.mustBeExported 分别检查当前反射对象是否是可以被设置的以及字段是否是对外公开的：\nfunc (v Value) Set(x Value) { v.mustBeAssignable() x.mustBeExported() var target unsafe.Pointer if v.kind() == Interface { target = v.ptr } x = x.assignTo(\u0026#34;reflect.Set\u0026#34;, v.typ, target) typedmemmove(v.typ, v.ptr, x.ptr) } reflect.Value.Set 会调用reflect.Value.assignTo 并返回一个新的反射对象，这个返回的反射对象指针会直接覆盖原反射变量。\nfunc (v Value) assignTo(context string, dst *rtype, target unsafe.Pointer) Value { ... switch { case directlyAssignable(dst, v.typ): ... return Value{dst, v.ptr, fl} case implements(dst, v.typ): if v.Kind() == Interface \u0026amp;\u0026amp; v.IsNil() { return Value{dst, nil, flag(Interface)} } x := valueInterface(v, false) if dst.NumMethod() == 0 { *(*interface{})(target) = x } else { ifaceE2I(dst, x, target) } return Value{dst, target, flagIndir | flag(Interface)} } panic(context + \u0026#34;: value of type \u0026#34; + v.typ.String() + \u0026#34; is not assignable to type \u0026#34; + dst.String()) } reflect.Value.assignTo 会根据当前和被设置的反射对象类型创建一个新的 reflect.Value 结构体：\n 如果两个反射对象的类型是可以被直接替换，就会直接返回目标反射对象； 如果当前反射对象是接口并且目标对象实现了接口，就会把目标对象简单包装成接口值  在变量更新的过程中， reflect.Value.assignTo 返回的reflect.Value 中的指针会覆盖当前反射对象中的指针实现变量的更新。\n实现协议 reflect 包还为我们提供了 reflect.rtype.Implements 方法可以用于判断某些类型是否遵循特定的接口。在Go语言中获取结构体的反射类型 reflect.Type 还是比较容易的，但是想要获得接口类型需要通过以下方式：\nreflect.TypeOf((*\u0026lt;interface\u0026gt;)(nil)).Elem() 我们通过一个例子在介绍如何判断一个类型是否实现了某个接口。假设我们需要判断如下代码中的CustomError是否实现了Go语言标准库中的error接口：\ntype CustomError struct{} func (*CustomError) Error() string { return \u0026#34;\u0026#34; } func main() { typeOfError := reflect.TypeOf((*error)(nil)).Elem() customErrorPtr := reflect.TypeOf(\u0026amp;CustomError{}) customError := reflect.TypeOf(CustomError{}) fmt.Println(customErrorPtr.Implements(typeOfError)) // #=\u0026gt; true \tfmt.Println(customError.Implements(typeOfError)) // #=\u0026gt; false } 上述代码的运行结果正如我们在接口一节中介绍的：\n CustomError类型并没有实现error接口 *CustomError指针类型实现了error接口  抛开上述的执行结果不谈，我们来分析一下 reflect.rtype.Implements 方法的工作原理：\nfunc (t *rtype) Implements(u Type) bool { if u == nil { panic(\u0026#34;reflect: nil type passed to Type.Implements\u0026#34;) } if u.Kind() != Interface { panic(\u0026#34;reflect: non-interface type passed to Type.Implements\u0026#34;) } return implements(u.(*rtype), t) } reflect.rtype.Implements 会检查传入的类型是不是接口，如果不是接口或者是空值就会直接崩溃并中止当前程序。在参数没有问题的情况下，上述方法会调用私有函数 reflect.implements 判断类型之间是否有实现关系：\nfunc implements(T, V *rtype) bool { t := (*interfaceType)(unsafe.Pointer(T)) if len(t.methods) == 0 { return true } ... v := V.uncommon() i := 0 vmethods := v.methods() for j := 0; j \u0026lt; int(v.mcount); j++ { tm := \u0026amp;t.methods[i] tmName := t.nameOff(tm.name) vm := vmethods[j] vmName := V.nameOff(vm.name) if vmName.name() == tmName.name() \u0026amp;\u0026amp; V.typeOff(vm.mtyp) == t.typeOff(tm.typ) { if i++; i \u0026gt;= len(t.methods) { return true } } } return false } 如果接口中不包含任何方法，就意味着这是一个空的接口，任意类型都自动实现该接口，这时会直接返回true。\n在其他情况下，由于方法都是按照字母序存储的， reflect.implements 会维护两个用于遍历接口和类型方法的索引i和j判断类型是否实现了接口，因为最多只会进行n次比较（类型的方法数量），所以整个过程的时间复杂度是𝑂(𝑛)。\n方法调用 作为一门静态语言，如果我们想要通过reflect 包利用反射在运行期间执行方法不是一件容易的事情，下面的十几行代码就使用反射来执行Add(0,1)函数：\nfunc Add(a, b int) int { return a + b } func main() { v := reflect.ValueOf(Add) if v.Kind() != reflect.Func { return } t := v.Type() argv := make([]reflect.Value, t.NumIn()) for i := range argv { if t.In(i).Kind() != reflect.Int { return } argv[i] = reflect.ValueOf(i) } result := v.Call(argv) if len(result) != 1 || result[0].Kind() != reflect.Int { return } fmt.Println(result[0].Int()) // #=\u0026gt; 1 }  通过reflect.ValueOf 获取函数Add对应的反射对象； 调用reflect.rtype.NumIn 获取函数的入参个数； 多次调用reflect.ValueOf 函数逐一设置argv数组中的各个参数； 调用反射对象Add的reflect.Value.Call 方法并传入参数列表； 获取返回值数组、验证数组的长度以及类型并打印其中的数据；  使用反射来调用方法非常复杂，原本只需要一行代码就能完成的工作，现在需要十几行代码才能完成，但这也是在静态语言中使用动态特性需要付出的成本。\nfunc (v Value) Call(in []Value) []Value { v.mustBe(Func) v.mustBeExported() return v.call(\u0026#34;Call\u0026#34;, in) } reflect.Value.Call 是运行时调用方法的入口，它通过两个MustBe开头的方法确定了当前反射对象的类型是函数以及可见性，随后调用 reflect.Value.call 完成方法调用，这个私有方法的执行过程会分成以下的几个部分：\n 检查输入参数以及类型的合法性； 将传入的reflect.Value 参数数组设置到栈上； 通过函数指针和输入参数调用函数； 从栈上获取函数的返回值；  我们将按照上面的顺序分析使用reflect 进行函数调用的几个过程。\n参数检查 参数检查是通过反射调用方法的第一步，在参数检查期间我们会从反射对象中取出当前的函数指针unsafe.Pointer，如果该函数指针是方法， 那么我们会通过reflect.methodReceiver 获取方法的接收者和函数指针。\nfunc (v Value) call(op string, in []Value) []Value { t := (*funcType)(unsafe.Pointer(v.typ)) ... if v.flag\u0026amp;flagMethod != 0 { rcvr = v rcvrtype, t, fn = methodReceiver(op, v, int(v.flag)\u0026gt;\u0026gt;flagMethodShift) } else { ... } n := t.NumIn() if len(in) \u0026lt; n { panic(\u0026#34;reflect: Call with too few input arguments\u0026#34;) } if len(in) \u0026gt; n { panic(\u0026#34;reflect: Call with too many input arguments\u0026#34;) } for i := 0; i \u0026lt; n; i++ { if xt, targ := in[i].Type(), t.In(i); !xt.AssignableTo(targ) { panic(\u0026#34;reflect: \u0026#34; + op + \u0026#34; using \u0026#34; + xt.String() + \u0026#34; as type \u0026#34; + targ.String()) } } 上述方法还会检查传入参数的个数以及参数的类型与函数签名中的类型是否可以匹配，任何参数的不匹配都会导致整个程序的崩溃中止。\n准备参数 当我们已经对当前方法的参数完成验证后，就会进入函数调用的下一个阶段，为函数调用准备参数，在前面函数调用一节中，我们已经介绍过Go语言的函数调用惯例， 函数或者方法在调用时，所有的参数都会被依次放到栈上。\nnout := t.NumOut() frametype, _, retOffset, _, framePool := funcLayout(t, rcvrtype) var args unsafe.Pointer if nout == 0 { args = framePool.Get().(unsafe.Pointer) } else { args = unsafe_New(frametype) } off := uintptr(0) if rcvrtype != nil { storeRcvr(rcvr, args) off = ptrSize } for i, v := range in { targ := t.In(i).(*rtype) a := uintptr(targ.align) off = (off + a - 1) \u0026amp;^ (a - 1) n := targ.size ... addr := add(args, off, \u0026#34;n \u0026gt; 0\u0026#34;) v = v.assignTo(\u0026#34;reflect.Value.Call\u0026#34;, targ, addr) *(*unsafe.Pointer)(addr) = v.ptr off += n }  通过reflect.funcLayout 计算当前函数需要的参数和返回值的栈布局，也就是每一个参数和返回值所占的空间大小； 如果当前函数有返回值，需要为当前函数的参数和返回值分配一片内存空间args； 如果当前函数是方法，需要向将方法的接收接收者者拷贝到args内存中； 将所有函数的参数按照顺序依次拷贝到对应args内存中  使用reflect.funcLayout 返回的参数计算参数在内存中的位置； 将参数拷贝到内存空间中；    准备参数是计算各个参数和返回值占用的内存空间并将所有的参数都拷贝内存空间对应位置的过程，该过程会考虑函数和方法、返回值数量以及参数类型带来的差异。\n调用函数 准备好调用函数需要的全部参数后，就会通过下面的代码执行函数指针了。我们会向该函数传入栈类型、函数指针、参数和返回值的内存空间、 栈的大小以及返回值的偏移量：\ncall(frametype, fn, args, uint32(frametype.size), uint32(retOffset)) 上述函数实际上并不存在，它会在编译期间链接到 reflect.reflectcall 这个用汇编实现的函数上，我们在这里不会分析该函数的具体实现，感兴趣的读者可以自行了解其实现原理。\n处理返回值 当函数调用结束之后，就会开始处理函数的返回值：\n 如果函数没有任何返回值，会直接清空args中的全部内容来释放内存空间； 如果当前函数有返回值；  将args中与输入参数有关的内存空间清空； 创建一个nout长度的切片用于保存由反射对象构成的返回值数组； 从函数对象中获取返回值的类型和内存大小，将args内存中的数据转换成 reflect.Value 类型并存储到切片中；    var ret []Value if nout == 0 { typedmemclr(frametype, args) framePool.Put(args) } else { typedmemclrpartial(frametype, args, 0, retOffset) ret = make([]Value, nout) off = retOffset for i := 0; i \u0026lt; nout; i++ { tv := t.Out(i) a := uintptr(tv.Align()) off = (off + a - 1) \u0026amp;^ (a - 1) if tv.Size() != 0 { fl := flagIndir | flag(tv.Kind()) ret[i] = Value{tv.common(), add(args, off, \u0026#34;tv.Size() != 0\u0026#34;), fl} } else { ret[i] = Zero(tv) } off += tv.Size() } } return ret } 由reflect.Value 构成的ret数组会被返回到调用方，到这里为止使用反射实现函数调用的过程就结束了。\n小结 Go语言的reflect 包为我们提供了多种能力，包括如何使用反射来动态修改变量、 判断类型是否实现了某些接口以及动态调用方法等功能，通过分析反射包中方法的原理能帮助我们理解之前看起来比较怪异、令人困惑的现象。\n参考  转载自Draveness Go语言设计与实现 4.3反射  ","date":"August 3, 2021","hero":"/posts/knowledge/2003-go-reflect/head.svg","permalink":"https://ormissia.github.io/posts/knowledge/2003-go-reflect/","summary":"反射简介  Golang提供了一种机制，在编译时不知道类型的情况下，可更新变量、运行时查看值、调用方法以及直接对他们的布局进行操作的机制，称为反射。\n  reflect 包中的官方注释：Package reflect implements run-time reflection, allowing a program to manipulate objects with arbitrary types. \n reflect 实现了运行时的反射能力，能够让程序操作不同类型的对象。反射包中有两对非常重要的函数和类型， 两个函数分别是：\n reflect.TypeOf 能获取类型信息 reflect.ValueOf 能获取数据的运行时表示  三大法则 运行时反射是程序在运行期间检查其自身结构的一种方式。反射带来的灵活性是一把双刃剑，反射作为一种元编程方式可以减少重复代码， 但是过量的使用反射会使我们的程序逻辑变得难以理解并且运行缓慢。我们在这一节中会介绍Go语言反射的三大法则，其中包括：\n 从interface{}变量可以反射出反射对象； 从反射对象可以获取interface{}变量； 要修改反射对象，其值必须可设置；  第一法则 反射的第一法则是我们能将Go语言的interface{}变量转换成反射对象。很多读者可能会对这以法则产生困惑—为什么是从interface{}变量到反射对象？ 当我们执行reflect.ValueOf(1)时，虽然看起来是获取了基本类型int对应的反射类型，但是由于 reflect.TypeOf 、 reflect.ValueOf 两个方法的入参都是interface{}类型，所以在方法执行的过程中发生了类型转换。\n因为Go语言的函数调用都是值传递的，所以变量会在函数调用时进行类型转换。基本类型int会转换成interface{}类型， 这也就是为什么第一条法则是从接口到反射对象。\n上面提到的reflect.TypeOf 和reflect.ValueOf 函数就能完成这里的转换，如果我们认为Go语言的类型和反射类型处于两个不同的世界，那么这两个函数就是连接这两个世界的桥梁。\n我们可以通过以下例子简单介绍它们的作用， reflect.TypeOf 获取了变量author的类型， reflect.ValueOf 获取了变量的值ormissia。如果我们知道了一个变量的类型和值，那么就意味着我们知道了这个变量的全部信息。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { author := \u0026#34;ormissia\u0026#34; fmt.Println(\u0026#34;TypeOf author:\u0026#34;, reflect.","tags":null,"title":"Golang反射"},{"categories":null,"contents":" A：\u0026ldquo;请用一句话让别人知道你写过Golang。\u0026rdquo;\nB：\u0026ldquo;if err!= nil \u0026hellip;\u0026rdquo;\n 起因 只要是接触过Golang的人，无不为其if err != nil的语法感到惊奇，或是大加赞赏，或是狠狠痛批。作为使用者，不管喜欢也好，反对也罢， 目前还是要接受这种错误处理模式。\n而最令人头痛的就是请求参数中各种值的校验。比如Get请求中接收分页参数时，需要将string格式的参数转换成int类型，再如时间类型的参数 转换， 诸如此类，等等等等。好家伙，一个接口写完if err != nil的判断占了一多半的行数，看着实在不爽。\n下面就是一个典型的例子，而且这个接口参数还不是特别多\nfunc Export(c *gin.Context) { //删除开头  //... \tvar param map[string]string err := c.ShouldBindJSON(\u0026amp;param) if err != nil { ErrRsponse(c,errCode) return } var vId, userId, userName, format string if v, ok := param[\u0026#34;vId\u0026#34;]; ok { vId = v } else { ErrRsponse(c,errCode) return } if len(vId) == 0 { ErrRsponse(c,errCode) return } if v, ok := param[\u0026#34;userId\u0026#34;]; ok { userId = v } else { ErrRsponse(c,errCode) return } if v, ok := param[\u0026#34;userName\u0026#34;]; ok { userName = v } else { ErrRsponse(c,errCode) return } if v, ok := param[\u0026#34;format\u0026#34;]; ok { format = v } else { ErrRsponse(c,errCode) return } if !file.IsOk(format) { ErrRsponse(c,errCode) return } //... \t//删除结尾 } 机遇 前几天在看GIN-VUE-ADMIN代码的时候，偶然看到一个通过反射去做参数校验的方式。 嘿，学到了！\n改变 定义规则 校验规则使用一个map存储，key为字段名，value为规则列表，并使用一个string类型的切片来存储。\n 后续计划加入tag标签定义规则的功能以及增加通过函数参数的方式，实现自定义规则校验\n type Rules map[string][]string 支持的规则有：\n 不为空 等于、不等于 大于、小于 大于等于、小于等于   对于数值类型为比较值大小，对于字符串或者切片等类型为比较长度大小\n 比如调用生成小于规则的方法，则会返回一个小于指定值规则的字符串，用于后面校验器使用\n// Lt \u0026lt; func (verifier verifier) Lt(limit string) string { return fmt.Sprintf(\u0026#34;%s%s%s\u0026#34;, lt, verifier.separator, limit) } 规则定义示例：\nUserRequestRules = go_opv.Rules{ \u0026#34;Name\u0026#34;: {myVerifier.NotEmpty(), myVerifier.Lt(\u0026#34;10\u0026#34;)}, \u0026#34;Age\u0026#34;: {myVerifier.Lt(\u0026#34;100\u0026#34;)}, } //map[Age:[lt#100] Name:[notEmpty lt#10]] 规则含义为Age字段长度或值小于100，Name字段不为空且长度或值小于10。\n验证器 先通过反射获取待检验参数的值和类型，判断是否为struct（目前只实现了对struct校验的功能，计划后续加入对map的校验功能）， 获取struct属性数量并遍历所有属性，并遍历每个字段下所有规则，对定义的每一个规则进行校验是否合格。\nfunc (verifier verifier) Verify(st interface{}, rules Rules) (err error) { typ := reflect.TypeOf(st) val := reflect.ValueOf(st) if val.Kind() != reflect.Struct { return errors.New(\u0026#34;expect struct\u0026#34;) } num := val.NumField() //遍历需要验证对象的所有字段 \tfor i := 0; i \u0026lt; num; i++ { tagVal := typ.Field(i) val := val.Field(i) if len(rules[tagVal.Name]) \u0026gt; 0 { for _, v := range rules[tagVal.Name] { switch { case v == \u0026#34;notEmpty\u0026#34;: if isEmpty(val) { return errors.New(tagVal.Name + \u0026#34; value can not be nil\u0026#34;) } case verifier.conditions[strings.Split(v, verifier.separator)[0]]: if !compareVerify(val, v, verifier.separator) { return errors.New(tagVal.Name + \u0026#34; length or value is illegal,\u0026#34; + v) } } } } } return nil } 规则校验有两种，分别是判空 和条件校验。\n判空是通过反射reflect.Value获得字段值，并通过反射value.Kind()获得字段类型。 最终使用switch分别对不同类型 字段进行判断。\nfunc isEmpty(value reflect.Value) bool { switch value.Kind() { case reflect.String: return value.Len() == 0 case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64: return value.Int() == 0 //此处省略其他类型判断 \t//... \t} return reflect.DeepEqual(value.Interface(), reflect.Zero(value.Type()).Interface()) } 条件校验则是通过开始时定义的范围条件进行校验，传入反射reflect.Value获得字段值，定义的规则，以及规则中的分隔符。先通过switch判断其类型， 再通过switch判断条件是大于小于或是其他条件，然后进行相应判断。\nfunc compareVerify(value reflect.Value, verifyStr, separator string) bool { switch value.Kind() { case reflect.String, reflect.Slice, reflect.Array: return compare(value.Len(), verifyStr, separator) //此处省略其他类型判断 \t//... \tdefault: return false } } 封装 为了调用方便，做了一层封装，使用函数选项模式对校验器进行封装，使调用更为方便。\nvar defaultVerifierOptions = verifierOptions{ separator: \u0026#34;:\u0026#34;, conditions: map[string]bool{ eq: true, ne: true, gt: true, lt: true, ge: true, le: true, }, } type VerifierOption func(o *verifierOptions) type verifierOptions struct { conditions map[string]bool separator string } // SetSeparator Default separator is \u0026#34;:\u0026#34;. func SetSeparator(seq string) VerifierOption { return func(o *verifierOptions) { o.separator = seq } } func SwitchEq(sw bool) VerifierOption { return func(o *verifierOptions) { o.conditions[eq] = sw } } //... //此处省略其他参数的设置  type Verifier interface { Verify(obj interface{}, rules Rules) (err error) NotEmpty() string Ne(limit string) string Gt(limit string) string Lt(limit string) string Ge(limit string) string Le(limit string) string } type verifier struct { separator string conditions map[string]bool } func NewVerifier(opts ...VerifierOption) Verifier { options := defaultVerifierOptions for _, opt := range opts { opt(\u0026amp;options) } return verifier{ separator: options.separator, conditions: options.conditions, } } //... //此处省略接口的实现 发布  好了，基本功能完成了，如果仅仅是放在每个项目的utils拷来拷去，显然十分的不优雅。\n那么这就需要发布到pkg.go.dev才能通过go get命令正常被其他项目所引用。\n  首先是git commit、git push一把梭将项目整到GitHub上。 由于pkg.go.dev的版本管理机制需要给项目打上tag，git tag v0.0.1基础版本，😋先定个0.0.1吧， 然后git push再走一遍。 当然这时候还没完，需要自己go get一下，加上GitHub仓库名执行一下go get github.com/ormissia/go-opv 这样仓库就可以正常被引用了。而且用不了多久，就可以从pkg.go.dev上搜到相应的项目了。 最后贴一下次项目的连接：go-opv   当然，这个过程中也遇到过小坑。项目中go.mod中的模块名需要写GitHub的仓库地址，对应此项目即为module github.com/ormissia/go-opv。 如果项目版本有更新，打了新的tag之后。可以通过go get github.com/ormissia/go-opv@v0.0.3拉取指定版本，目前尚不清楚 pkg.go.dev是否会自动同步GitHub上最新的tag。\n 检验 测试用例？\n好吧，// TODO\n 老铁看到底了，来个star吧😁\n↓↓↓↓↓↓↓↓↓\nGitHub仓库\n ","date":"July 27, 2021","hero":"/posts/knowledge/2002-go-param-verify/head.svg","permalink":"https://ormissia.github.io/posts/knowledge/2002-go-param-verify/","summary":"A：\u0026ldquo;请用一句话让别人知道你写过Golang。\u0026rdquo;\nB：\u0026ldquo;if err!= nil \u0026hellip;\u0026rdquo;\n 起因 只要是接触过Golang的人，无不为其if err != nil的语法感到惊奇，或是大加赞赏，或是狠狠痛批。作为使用者，不管喜欢也好，反对也罢， 目前还是要接受这种错误处理模式。\n而最令人头痛的就是请求参数中各种值的校验。比如Get请求中接收分页参数时，需要将string格式的参数转换成int类型，再如时间类型的参数 转换， 诸如此类，等等等等。好家伙，一个接口写完if err != nil的判断占了一多半的行数，看着实在不爽。\n下面就是一个典型的例子，而且这个接口参数还不是特别多\nfunc Export(c *gin.Context) { //删除开头  //... \tvar param map[string]string err := c.ShouldBindJSON(\u0026amp;param) if err != nil { ErrRsponse(c,errCode) return } var vId, userId, userName, format string if v, ok := param[\u0026#34;vId\u0026#34;]; ok { vId = v } else { ErrRsponse(c,errCode) return } if len(vId) == 0 { ErrRsponse(c,errCode) return } if v, ok := param[\u0026#34;userId\u0026#34;]; ok { userId = v } else { ErrRsponse(c,errCode) return } if v, ok := param[\u0026#34;userName\u0026#34;]; ok { userName = v } else { ErrRsponse(c,errCode) return } if v, ok := param[\u0026#34;format\u0026#34;]; ok { format = v } else { ErrRsponse(c,errCode) return } if !","tags":null,"title":"Golang 实体参数校验"},{"categories":null,"contents":" 作为 Golang 开发者，遇到的许多问题之一就是尝试将函数的参数设置成可选项。这是一个十分常见的场景，您可以使用一些已经设置默认配置和开箱即用的对象，同时您也可以使用一些更为详细的配置。\n 问题出发点 对于许多编程语言来说，这很容易。在 C 语言家族中，您可以提供具有同一个函数但是不同参数的多个版本；在 PHP 之类的语言中，您可以为参数提供默认值，并在调用该方法时将其忽略。但是在 Golang 中，上述的做法都不可以使用。那么您如何创建具有一些其他配置的函数，用户可以根据他的需求（但是仅在需要时）指定一些额外的配置。\n有很多的方法可以做到这一点，但是大多数方法都不是尽如人意，要么需要在服务端的代码中进行大量额外的检查和验证，要么通过传入他们不关心的其他参数来为客户端进行额外的工作。\n下面我将会介绍一些不同的选项，然后为其说明为什么每个选项都不理想，接着我们会逐步构建自己的方式来作为最终的干净解决方案：函数选项模式。\n让我们来看一个例子。比方说，这里有一个叫做StuffClient的服务，它能够胜任一些工作，同时还具有两个配置选项（超时和重试）。\ntype StuffClient interface { DoStuff() error } type stuffClient struct { conn Connection timeout int retries int } 这是个私有的结构体，因此我们应该为它提供某种构造函数：\nfunc NewStuffClient(conn Connection, timeout, retries int) StuffClient { return \u0026amp;stuffClient{ conn: conn, timeout: timeout, retries: retries, } } 嗯，但是现在我们每次调用NewStuffClient函数时都要提供timeout和retries。因为在大多数情况下，我们只想使用默认值，我们无法使用不同参数数量带定义多个版本的NewStuffClient，否则我们会得到一个类似NewStuffClient redeclared in this block编译错误。\n一个可选方案是创建另一个具有不同名称的构造函数，例如：\nfunc NewStuffClient(conn Connection) StuffClient { return \u0026amp;stuffClient{ conn: conn, timeout: DEFAULT_TIMEOUT, retries: DEFAULT_RETRIES, } } func NewStuffClientWithOptions(conn Connection, timeout, retries int) StuffClient { return \u0026amp;stuffClient{ conn: conn, timeout: timeout, retries: retries, } } 但是这么做的话有点蹩脚。我们可以做得更好，如果我们传入了一个配置对象呢:\ntype StuffClientOptions struct { Retries int //number of times to retry the request before giving up  Timeout int //connection timeout in seconds } func NewStuffClient(conn Connection, options StuffClientOptions) StuffClient { return \u0026amp;stuffClient{ conn: conn, timeout: options.Timeout, retries: options.Retries, } } 但是，这也不是很好的做法。现在，我们总是需要创建StuffClientOption这个结构体，即使不想在指定任何选项时还要传递它。另外我们也没有自动填充默认值，除非我们在代码中的某处添加了一堆检查，或者也可以传入一个DefaultStuffClientOptions变量（不过这么做也不好，因为在修改某一处地方后可能会导致其他的问题。）\n所以，更好的解决方法是什么呢？解决这个难题最好的解决方法是使用函数选项模式，它利用了Go对闭包更加方便的支持。让我们保留上述定义的StuffClientOptions，不过我们仍需要为其添加一些内容。\ntype StuffClientOption func(*StuffClientOptions) type StuffClientOptions struct { Retries int //number of times to retry the request before giving up \tTimeout int //connection timeout in seconds } func WithRetries(r int) StuffClientOption { return func(o *StuffClientOptions) { o.Retries = r } } func WithTimeout(t int) StuffClientOption { return func(o *StuffClientOptions) { o.Timeout = t } } 泥土般芬芳, 不是吗？这到底是怎么回事？基本上，我们有一个结构来定义StuffClient的可用选项。另外，现状我们还定义了一个叫做StuffClientOption的东西（次数是单数），它只是接受我们选项的结构体作为参数的函数。我们还定义了另外两个函数 WithRetries 和WithTimeout，它们返回一个闭包，现在就是见证奇迹的时刻了！\nvar defaultStuffClientOptions = StuffClientOptions{ Retries: 3, Timeout: 2, } func NewStuffClient(conn Connection, opts ...StuffClientOption) StuffClient { options := defaultStuffClientOptions for _, o := range opts { o(\u0026amp;options) } return \u0026amp;stuffClient{ conn: conn, timeout: options.Timeout, retries: options.Retries, } } 现在，我们定义了一个额外和包含默认选项的没有导出的变量，同时我们已经调整了构造函数，用来接收可变参数。然后, 我们遍历StuffClientOption列表(单数)，针对每一个列表，将列表中返回的闭包使用在我们的options变量（需要记住，这些闭包接收一个StuffClientOptions变量，仅需要在选项的值上做出少许修改）。\n现在我们要做的事情就是使用它！\nx := NewStuffClient(Connection{}) fmt.Println(x) // prints \u0026amp;{{} 2 3} x = NewStuffClient( Connection{}, WithRetries(1), ) fmt.Println(x) // prints \u0026amp;{{} 2 1} x = NewStuffClient( Connection{}, WithRetries(1), WithTimeout(1), ) fmt.Println(x) // prints \u0026amp;{{} 1 1} 函数选项模式 这看起来相当不错，已经可以使用了！而且，它的好处是，我们只需要对代码进行很少的修改，就可以随时随地添加新的选项。\n把这些修改放在一起，就是这样：\nvar defaultStuffClientOptions = StuffClientOptions{ Retries: 3, Timeout: 2, } type StuffClientOption func(*StuffClientOptions) type StuffClientOptions struct { Retries int //number of times to retry the request before giving up \tTimeout int //connection timeout in seconds } func WithRetries(r int) StuffClientOption { return func(o *StuffClientOptions) { o.Retries = r } } func WithTimeout(t int) StuffClientOption { return func(o *StuffClientOptions) { o.Timeout = t } } type StuffClient interface { DoStuff() error } type stuffClient struct { conn Connection timeout int retries int } type Connection struct{} func NewStuffClient(conn Connection, opts ...StuffClientOption) StuffClient { options := defaultStuffClientOptions for _, o := range opts { o(\u0026amp;options) } return \u0026amp;stuffClient{ conn: conn, timeout: options.Timeout, retries: options.Retries, } } func (c stuffClient) DoStuff() error { return nil } 但这也可以通过删除StuffClientOptions结构体进一步简化，并将选项直接应用在我们的StuffClient上。\nvar defaultStuffClient = stuffClient{ retries: 3, timeout: 2, } type StuffClientOption func(*stuffClient) func WithRetries(r int) StuffClientOption { return func(o *stuffClient) { o.retries = r } } func WithTimeout(t int) StuffClientOption { return func(o *stuffClient) { o.timeout = t } } type StuffClient interface { DoStuff() error } type stuffClient struct { conn Connection timeout int retries int } type Connection struct{} func NewStuffClient(conn Connection, opts ...StuffClientOption) StuffClient { client := defaultStuffClient for _, o := range opts { o(\u0026amp;client) } client.conn = conn return client } func (c stuffClient) DoStuff() error { return nil } 在我们的示例中，我们只是将配置直接应用于结构体中，如果中间有一个额外的结构体是没有意义的。但是，请注意，在许多情况下，您可能仍然想使用上一个示例中的config结构。例如，如果您的构造函数正在使用config选项执行某些操作时，但是并没有将它们存储到结构体中，或者被传递到其他地方，配置结构的变体是更通用的实现。\n转载自此处\n","date":"July 22, 2021","hero":"/posts/knowledge/2001-go-partten-1/head.svg","permalink":"https://ormissia.github.io/posts/knowledge/2001-go-partten-1/","summary":"作为 Golang 开发者，遇到的许多问题之一就是尝试将函数的参数设置成可选项。这是一个十分常见的场景，您可以使用一些已经设置默认配置和开箱即用的对象，同时您也可以使用一些更为详细的配置。\n 问题出发点 对于许多编程语言来说，这很容易。在 C 语言家族中，您可以提供具有同一个函数但是不同参数的多个版本；在 PHP 之类的语言中，您可以为参数提供默认值，并在调用该方法时将其忽略。但是在 Golang 中，上述的做法都不可以使用。那么您如何创建具有一些其他配置的函数，用户可以根据他的需求（但是仅在需要时）指定一些额外的配置。\n有很多的方法可以做到这一点，但是大多数方法都不是尽如人意，要么需要在服务端的代码中进行大量额外的检查和验证，要么通过传入他们不关心的其他参数来为客户端进行额外的工作。\n下面我将会介绍一些不同的选项，然后为其说明为什么每个选项都不理想，接着我们会逐步构建自己的方式来作为最终的干净解决方案：函数选项模式。\n让我们来看一个例子。比方说，这里有一个叫做StuffClient的服务，它能够胜任一些工作，同时还具有两个配置选项（超时和重试）。\ntype StuffClient interface { DoStuff() error } type stuffClient struct { conn Connection timeout int retries int } 这是个私有的结构体，因此我们应该为它提供某种构造函数：\nfunc NewStuffClient(conn Connection, timeout, retries int) StuffClient { return \u0026amp;stuffClient{ conn: conn, timeout: timeout, retries: retries, } } 嗯，但是现在我们每次调用NewStuffClient函数时都要提供timeout和retries。因为在大多数情况下，我们只想使用默认值，我们无法使用不同参数数量带定义多个版本的NewStuffClient，否则我们会得到一个类似NewStuffClient redeclared in this block编译错误。\n一个可选方案是创建另一个具有不同名称的构造函数，例如：\nfunc NewStuffClient(conn Connection) StuffClient { return \u0026amp;stuffClient{ conn: conn, timeout: DEFAULT_TIMEOUT, retries: DEFAULT_RETRIES, } } func NewStuffClientWithOptions(conn Connection, timeout, retries int) StuffClient { return \u0026amp;stuffClient{ conn: conn, timeout: timeout, retries: retries, } } 但是这么做的话有点蹩脚。我们可以做得更好，如果我们传入了一个配置对象呢:","tags":null,"title":"Go 惯用模式：函数选项模式"},{"categories":null,"contents":" 博客后端使用Golang重构之后使用GitHub-DockerHub-Jenkins自动打包部署流程\n  虽然说Golang打包生成的是二进制可执行文件，不需要像JAVA一样部署环境变量，但依然也是需要打包的流程。由于考虑到在不(hen)久(yuan)的将来可能做成简单的微服务程序，又要使用Docker部署，所以在这就直接使用Docker镜像的方式来部署运行。\n 本地代码→GitHub 这一步是通过git commit-git push或是直接使用IDE将代码托管到GitHub上。 在这一步的同时需要编写Dockerfile文件，用来指定Docker镜像打包时的各种参数\n# Go程序编译之后会得到一个可执行的二进制文件，其实在最终的镜像中是不需要go编译器的，也就是说我们只需要一个运行最终二进制文件的容器即可。# 作为别名为\u0026#34;builder\u0026#34;的编译镜像，下面会用到FROMgolang AS builder# 为镜像设置必要的环境变量ENV GO111MODULE=on \\  CGO_ENABLED=0 \\  GOOS=linux \\  GOARCH=amd64 \\  GOPROXY=https://goproxy.cn# 设置工作目录：/buildWORKDIR/build# 复制项目中的 go.mod 和 go.sum文件并下载依赖信息COPY go.mod .COPY go.sum .RUN go mod download# 将代码复制到容器中COPY 2021-03-04T18:02:29 .# 将代码编译成二进制可执行文件appRUN go build -o go-blog-app .#################### 接下来创建一个小镜像###################FROMscratch# 设置程序运行时必要的环境变量，包括监听端口、数据库配置等等ENV SERVER_PORT=8085 \\  DATASOURCE_DRIVERNAME=mysql \\  DATASOURCE_HOST=192.168.13.110 \\  DATASOURCE_PORT=3306 \\  DATASOURCE_DATABASE=blog \\  DATASOURCE_USERNAME=root \\  DATASOURCE_PASSWORD=5KvA82*Ziq \\  DATASOURCE_CHARSET=utf8mb4# 从builder镜像中把/dist/app 拷贝到当前目录COPY --from=builder /build/go-blog-app /# 声明服务端口EXPOSE8085# 启动容器时运行的命令ENTRYPOINT [\u0026#34;/go-blog-app\u0026#34;]GitHub→Docker Hub 这一步是将GitHub上的代码打包成Docker镜像并将镜像托管到Docker Hub上，我在这里使用的是使用Docker Hub来自动打包Docker镜像。也有另一种方式是GitHub通过设置好的Webhooks来通知Jenkins等CI/CD工具来拉取代码在自己的服务器上打包Docker镜像再上传到Docker Hub或是其他Docker镜像管理工具上，由于自己的这个项目代码更新比较慢，可以容忍提交代码之后有较长的时间来更新到线上环境中，所以就采用了Docker官方的打包功能。\n 首先要有一个Docker Hub的账号  将GitHub账号关联到Docker Hub账号上  创建Docker仓库并且与GitHub仓库绑定  打开Docker Hub的仓库创建页面 添加仓库名称 选择GitHub作为代码仓库 选择要打包Docker镜像的GitHub仓库 添加Docker镜像打包规则  可以选择按git push到指定分支或者是git push一个git tag来触发build动作 可以指定Docker镜像的Tag 可以指定用于打包Docker镜像的Dockerfile文件 可以开关Docker镜像打包的缓存      创建好Docker仓库之后再去GitHub仓库的setting页面中就会发现多了一个Webhook的设置  每当GitHub仓库里触发了指定条件之后就会通过这个Webhook通知到Docker Hub触发对应的镜像打包动作，当然打包动作也可以手动触发   Docker Hub→服务器生产环境 这一步是将Docker Hub上已经打包好的Docker镜像部署到生产服务器上。\n 在Docker Hub仓库中添加Webhook，首先需要有自己的CI/CD服务，我这里用的时搭在自己服务器上的Jenkins(搭建流程)。当然理论上应该也可以使用GitHub上一些CI/CD应用，我没有深入了解就不赘述了。   未完待续。。。 由于时间比较紧，Docker Hub→服务器生产环境这一步还没有实际操作，目前还是docker pull→docker run 不过基于已经线上运行很久的前端VUE项目的自动部署流程，理论上这一步应该是可行的 ","date":"March 3, 2021","hero":"/posts/deployment/3001-blog-cicd/head.svg","permalink":"https://ormissia.github.io/posts/deployment/3001-blog-cicd/","summary":"博客后端使用Golang重构之后使用GitHub-DockerHub-Jenkins自动打包部署流程\n  虽然说Golang打包生成的是二进制可执行文件，不需要像JAVA一样部署环境变量，但依然也是需要打包的流程。由于考虑到在不(hen)久(yuan)的将来可能做成简单的微服务程序，又要使用Docker部署，所以在这就直接使用Docker镜像的方式来部署运行。\n 本地代码→GitHub 这一步是通过git commit-git push或是直接使用IDE将代码托管到GitHub上。 在这一步的同时需要编写Dockerfile文件，用来指定Docker镜像打包时的各种参数\n# Go程序编译之后会得到一个可执行的二进制文件，其实在最终的镜像中是不需要go编译器的，也就是说我们只需要一个运行最终二进制文件的容器即可。# 作为别名为\u0026#34;builder\u0026#34;的编译镜像，下面会用到FROMgolang AS builder# 为镜像设置必要的环境变量ENV GO111MODULE=on \\  CGO_ENABLED=0 \\  GOOS=linux \\  GOARCH=amd64 \\  GOPROXY=https://goproxy.cn# 设置工作目录：/buildWORKDIR/build# 复制项目中的 go.mod 和 go.sum文件并下载依赖信息COPY go.mod .COPY go.sum .RUN go mod download# 将代码复制到容器中COPY 2021-03-04T18:02:29 .# 将代码编译成二进制可执行文件appRUN go build -o go-blog-app .#################### 接下来创建一个小镜像###################FROMscratch# 设置程序运行时必要的环境变量，包括监听端口、数据库配置等等ENV SERVER_PORT=8085 \\  DATASOURCE_DRIVERNAME=mysql \\  DATASOURCE_HOST=192.168.13.110 \\  DATASOURCE_PORT=3306 \\  DATASOURCE_DATABASE=blog \\  DATASOURCE_USERNAME=root \\  DATASOURCE_PASSWORD=5KvA82*Ziq \\  DATASOURCE_CHARSET=utf8mb4# 从builder镜像中把/dist/app 拷贝到当前目录COPY --from=builder /build/go-blog-app /# 声明服务端口EXPOSE8085# 启动容器时运行的命令ENTRYPOINT [\u0026#34;/go-blog-app\u0026#34;]GitHub→Docker Hub 这一步是将GitHub上的代码打包成Docker镜像并将镜像托管到Docker Hub上，我在这里使用的是使用Docker Hub来自动打包Docker镜像。也有另一种方式是GitHub通过设置好的Webhooks来通知Jenkins等CI/CD工具来拉取代码在自己的服务器上打包Docker镜像再上传到Docker Hub或是其他Docker镜像管理工具上，由于自己的这个项目代码更新比较慢，可以容忍提交代码之后有较长的时间来更新到线上环境中，所以就采用了Docker官方的打包功能。","tags":null,"title":"我的博客后端Docker镜像打包自动部署流程"},{"categories":null,"contents":"This is a sample post intended to test the followings:\n A different post author. Table of contents. Markdown content rendering. Math rendering. Emoji rendering.   Markdown Syntax Rendering Headings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution  Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\n Blockquote with attribution  Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.— Rob Pike1 Tables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\n   Name Age     Bob 27   Alice 23    Inline Markdown within tables    Inline  Markdown  In  Table     italics bold strikethrough  code    Code Blocks Code block with backticks html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  Code block with Hugo\u0026rsquo;s internal highlight shortcode \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; List Types Ordered List  First item Second item Third item  Unordered List  List item Another item And another item  Nested list  Fruit  Apple Orange Banana   Dairy  Milk Cheese    Other Elements — abbr, sub, sup, kbd, mark GIFis a bitmap image format.\nH2O\nXn+ Yn= ZnPress CTRL+ALT+Deleteto end the session.\nMost salamandersare nocturnal, and hunt for insects, worms, and other small creatures.\n Math Rendering Block math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n Emoji Rendering   The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"June 8, 2020","hero":"/posts/unclassified/6001-markdown/head.svg","permalink":"https://ormissia.github.io/posts/unclassified/6001-markdown/","summary":"This is a sample post intended to test the followings:\n A different post author. Table of contents. Markdown content rendering. Math rendering. Emoji rendering.   Markdown Syntax Rendering Headings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur?","tags":null,"title":"Markdown Samples"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"January 1, 0001","hero":"/images/default-hero.jpg","permalink":"https://ormissia.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"}]