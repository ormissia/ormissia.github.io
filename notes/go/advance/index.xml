<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Advance on Ormissia's Blog</title><link>https://ormissia.github.io/notes/go/advance/</link><description>Recent content in Advance on Ormissia's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://ormissia.github.io/notes/go/advance/index.xml" rel="self" type="application/rss+xml"/><item><title>time</title><link>https://ormissia.github.io/notes/go/advance/time/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/go/advance/time/</guid><description>时间转换 字符串转时间
time.Parse() 时间转字符串
time.Format() 时间转时间戳
Time.Unix() 时间戳转时间
time.Unix() 计时 朴素方法
startTime := time.Now() //do something time.Sleep(time.Second) duration := time.Since(startTime) fmt.Printf(&amp;#34;经过时间：%v\n&amp;#34;, duration) //经过时间：1.005046959s 简洁方法
// TimeCost 耗时统计函数 func TimeCost(start time.Time) { duration := time.Since(start) fmt.Printf(&amp;#34;经过时间：%v\n&amp;#34;, duration) } defer TimeCost(time.Now()) //do something time.Sleep(time.Second) //经过时间：1.005054375s 优雅方法
// TimeCost 耗时统计函数 func TimeCost() func() { start := time.Now() return func() { duration := time.Since(start) fmt.Printf(&amp;#34;经过时间：%v\n&amp;#34;, duration) } } defer TimeCost()() //do something time.Sleep(time.Second) //经过时间：1.</description></item><item><title>go mod</title><link>https://ormissia.github.io/notes/go/advance/gomod/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/go/advance/gomod/</guid><description> go get 下载指定版本 go get github.com/ormissia/go-opv@v0.0.2</description></item><item><title>go chan</title><link>https://ormissia.github.io/notes/go/advance/chan/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/go/advance/chan/</guid><description> go chan close 在go的chan中，chan被关闭后，消费者会继续读取channel中的消息。直到消息被全部读取之后使用i, ok := &amp;lt;-ch得到的ok才会变为false
下面是测试代码以及运行时控制台打印结果：
func main() { ch := make(chan int, 3) go producer(ch) for { i, ok := &amp;lt;-ch fmt.Printf(&amp;#34;consume msg: %d\tok: %v\n&amp;#34;, i, ok) time.Sleep(time.Second * 3) } } func producer(ch chan int) { for i := 0; i &amp;lt; 10; i++ { ch &amp;lt;- i fmt.Printf(&amp;#34;produce msg: %d\n&amp;#34;, i) time.Sleep(time.Second) } close(ch) fmt.Println(&amp;#34;chan closed&amp;#34;) } 输出结果
produce msg: 0 consume msg: 0 ok: true produce msg: 1 produce msg: 2 consume msg: 1 ok: true produce msg: 3 produce msg: 4 consume msg: 2 ok: true produce msg: 5 consume msg: 3 ok: true produce msg: 6 consume msg: 4 ok: true produce msg: 7 consume msg: 5 ok: true produce msg: 8 consume msg: 6 ok: true produce msg: 9 chan closed consume msg: 7 ok: true consume msg: 8 ok: true consume msg: 9 ok: true consume msg: 0 ok: false consume msg: 0 ok: false</description></item></channel></rss>