<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Linux Notes on Ormissia's Blog</title><link>https://ormissia.github.io/notes/linux/</link><description>Recent content in Linux Notes on Ormissia's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://ormissia.github.io/notes/linux/index.xml" rel="self" type="application/rss+xml"/><item><title>Basic</title><link>https://ormissia.github.io/notes/linux/shell/basic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/linux/shell/basic/</guid><description>快捷键 回到命令行开头&amp;ndash;Home
Ctrl+a 回到命令行的尾部&amp;ndash;End
Ctrl+e 删除光标前边的所有字符
Ctrl+u 删除光标后边的所有字符
Ctrl+k 删除光标前的一个单词
Ctrl+w 输入曾经的命令下的某个单词或字母，按照单词的匹配history
Ctrl+r cat 在cat输出时候显示行数
cat -n maim.go wc 统计文件行、单词、字符数量 格式：
usage: wc [-clmw] [file ...] 统计main.go的行、单词、字符数量
wc main.go 选项：
-l 统计行数 -c 统计字符数 -w 统计单词数 -L 统计最长的行的字符数 nc 简单的文件传输工具
接收方
nc -l [port] &amp;gt; filename 发送方
nc [ip] [port] &amp;lt; filename gzip 解压*.gz的压缩文件
与*.tar.gz文件不同，*.gz文件需要用gzip来解压
gzip -d filename hostnamectl 修改hostname，重启也生效
hostnamectl set-hostname CentOS 查看hostname
hostname echo -n：不换行 -e：支持扩展属性
# 红色显示OK echo -e &amp;#34;\033[31mOK\033[0m&amp;#34; # 绿色显示OK echo -e &amp;#34;\033[32mOK\033[0m&amp;#34; tr 删除多余重复字符串</description></item><item><title>Advance</title><link>https://ormissia.github.io/notes/linux/shell/advance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/linux/shell/advance/</guid><description>xargs xargs是给命令传递参数的一个过滤器，可以将管道或标准输入（stdin）数据转换成命令行参数，也能够从文件的输出中读取数据，一般是和管道一起使用。 格式:
somecommand | xargs [-item] [command] 选项：
-a file 从文件中读入作为 stdin -e flag ，注意有的时候可能会是-E，flag必须是一个以空格分隔的标志，当xargs分析到含有flag这个标志的时候就停止。 -p 当每次执行一个argument的时候询问一次用户。 -n num 后面加次数，表示命令在执行的时候一次用的argument的个数，默认是用所有的。 -t 表示先打印命令，然后再执行。 -i 或者是-I，这得看linux支持了，将xargs的每项名称，一般是一行一行赋值给 {}，可以用 {} 代替。 -r no-run-if-empty 当xargs的输入为空的时候则停止xargs，不用再去执行了。 -s num 命令行的最大字符数，指的是 xargs 后面那个命令的最大命令行字符数。 -L num 从标准输入一次读取 num 行送给 command 命令。 -l 同 -L。 -d delim 分隔符，默认的xargs分隔符是回车，argument的分隔符是空格，这里修改的是xargs的分隔符。 -x exit的意思，主要是配合-s使用。。 top Linux top命令VIRT,RES,SHR,DATA的含义:
VIRT:virtual memory usage虚拟内存 进程“需要的”虚拟内存大小，包括进程使用的库、代码、数据等 假如进程申请100m的内存，但实际只使用了10m，那么它会增长100m，而不是实际的使用量 RES:resident memory usage常驻内存 进程当前使用的内存大小，但不包括swap out 包含其他进程的共享 如果申请100m的内存，实际使用10m，它只增长10m，与VIRT相反 关于库占用内存的情况，它只统计加载的库文件所占内存大小 SHR:shared memory共享内存 除了自身进程的共享内存，也包括其他进程的共享内存 虽然进程只使用了几个共享库的函数，但它包含了整个共享库的大小 计算某个进程所占的物理内存大小公式：RES – SHR swap out后，它将会降下来 top运行中可以通过top的内部命令对进程的显示方式进行控制。内部命令如下：</description></item><item><title>vi</title><link>https://ormissia.github.io/notes/linux/shell/vi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/linux/shell/vi/</guid><description> 命令 显示行号
:set number 在vi中执行shell命令
:!ls-l 将shell命令的结果插入到当前行的下一行
:r !date //读取系统时间并插入到当前行的下一行 将起始行号和结束行号指定的范围中的内容输入到shell命令command处理，并将处理结果替换起始行号和结束行号指定的范围中的内容
:62,72 !sort //将62行到72行的内容进行排序 当前光标所在行，除可以指定行号外，也可以用.表示
:. !tr [a-z] [A-Z] //将当前行的小写转为大写 将起始行号和结束行号所指定的范围的内容作为命令command的输入，不会改变当前编辑的文件的内容
:62,72 w !sort //将62行到72行的内容进行排序，但排序的结果并不会直接输出到当前编辑的文件中，而是显示在vim敲命令的区域 将某一行作为shell命令执行
:62 w !shell //将会把第62行的内容作为shell命令来执行并显示结果，而且不会改变当前编辑的文件的内容</description></item><item><title>Script</title><link>https://ormissia.github.io/notes/linux/shell/script/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/linux/shell/script/</guid><description>脚本执行方式 需要可执行权限 相对路径执行 绝对路径执行 不需要可执行权限 sh 脚本文件名 source 脚本文件名 // 不会启动子进程，通过pstree查看进程树 定义变量 定义变量：变量名=变量值 取消变量：unset 变量名 注意事项： =两边不能有空格 不能使用关键字做变量名，如：ls、cd等 如果变量名已存在，则会覆盖之前的变量值 变量名称由字母、数字、下划线组成，不能以数字开头 变量类型 环境变量：变量名通常大写，由操作系统维护 位置变量：shell内置变量，存储脚本执行时的参数 使用$n表示，n为数字序列号：$1、$2、&amp;hellip;、${10}、${11}、&amp;hellip; 预定义变量：shell内置变量，可以直接调用但是不能赋值或修改' $0：存储所在的进程或脚本名 $$：当前进程的PID号 $?：命令执行后的返回状态，0-正常，其他-异常 $#：已加载的位置变量的个数 $*：所有位置变量的值 自定义变量：用户自主设置 多种引号的区别 双引号：允许扩展，以$引用其他变量 单引号：禁用扩展，将$视为普通字符 反引号：将命令执行的输出作为变量值，$()与反引号等效 变量的作用范围 局部变量：新定义的变量默认只在当前Shell中有效，无法在子Shell环境中使用 全局变量：在当前Shell以及子Shell中均有效（export a=1：定义全局变量a） read标准输入取值 read从键盘读入变量值完成赋值
格式：read [参数] [变量名] 参数： -p：提示信息 -t：指定超时秒数 -s：设置是否在终端显示输入的内容 变量作用范围 局部变量 新定义的变量默认只在当前Shell环境中有效，无法在子Shell环境中使用 全局变量 全局变量在当前Shell及子Shell中均有效，定义格式：export a=1 数学运算 整数运算
使用$[]或$(())表达式
格式：$[整数1 运算符 整数2]
小数运算
Bash内建机制仅支持整数运算，不支持小数运算 可以通过计算器软件bc实现小数计算
如果没有该软件需要使用yum安装 bc支持交互式和非交互式两种方式计算，scale=n可以约束小数位
bc也支持比较操作： &amp;gt;,&amp;gt;=,&amp;lt;,&amp;lt;=,==,!= 表达式成立返回1，否则返回0
字符串 字符串比较</description></item><item><title>Memory</title><link>https://ormissia.github.io/notes/linux/system/system/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/linux/system/system/</guid><description>内存 一般来说内存占用大小有如下规律：VSS &amp;gt;= RSS &amp;gt;= PSS &amp;gt;= USS
VSS - Virtual Set Size 虚拟耗用内存（包含共享库占用的内存） RSS - Resident Set Size 实际使用物理内存（包含共享库占用的内存） PSS - Proportional Set Size 实际使用的物理内存（比例分配共享库占用的内存） USS - Unique Set Size 进程独自占用的物理内存（不包含共享库占用的内存） RSS / VSZ
RSS是Resident Set Size（常驻内存大小）的缩写，用于表示进程使用了多少内存（RAM中的物理内存）， RSS不包含已经被换出的内存。RSS包含了它所链接的动态库并且被加载到物理内存中的内存。RSS还包含栈内存和堆内存。 VSZ是Virtual Memory Size（虚拟内存大小）的缩写。它包含了进程所能访问的所有内存，包含了被换出的内存， 被分配但是还没有被使用的内存，以及动态库中的内存。 假设进程A的二进制文件是500K，并且链接了一个2500K的动态库，堆和栈共使用了200K，其中100K在内存中（剩下的被换出或者不再被使用）， 一共加载了动态库中的1000K内容以及二进制文件中的400K内容至内存中，那么：
RSS: 400K + 1000K + 100K = 1500K VSZ: 500K + 2500K + 200K = 3200K 由于部分内存是共享的，被多个进程使用，所以如果将所有进程的RSS值加起来可能会大于系统的内存总量。
申请过的内存如果程序没有实际使用，则可能不显示在RSS里。比如说一个程序，预先申请了一大批内存， 过了一段时间才使用，你会发现RSS会增长而VSZ保持不变。
还有一个概念是PSS，它是proportional set size（proportional是成比例的意思）的缩写。 这是一种新的度量方式。它将动态库所使用的内存按比例划分。比如我们前面例子中的动态库如果是被两个进程使用，那么：
PSS: 400K + (1000K/2) + 100K = 400K + 500K + 100K = 1000K 一个进程中的多个线程共享同样的地址空间。所以一个进程中的多个线程的RSS，VSZ，PSS是完全相同的。linux下可以使用ps或者top命令查看这些信息。</description></item></channel></rss>