<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Notes on Ormissia's Blog</title><link>https://ormissia.github.io/notes/</link><description>Recent content in Notes on Ormissia's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 08 Jun 2010 08:06:25 +0600</lastBuildDate><atom:link href="https://ormissia.github.io/notes/index.xml" rel="self" type="application/rss+xml"/><item><title>Basic</title><link>https://ormissia.github.io/notes/go/basic/basic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/go/basic/basic/</guid><description>基础类型内存宽度以及表示范围 bool
1Byte true/false uint8
1Byte 0-255 uint16
2Byte 0-65535 uint32
4Byte 0-4294967295 uint64
8Byte 0-18446744073709551615 int8
1Byte -128-127 int16
2Byte -32768-32767 int32
4Byte -2147483648-2147483647 int64
6Byte -9223372036854775808-9223372036854775807 byte
1Byte 类似 uint8 rune
4Byte 类似 int32 uint
4Byte / 8Byte 32 或 64 位 int
4Byte / 8Byte 与 uint 一样大小 float32
4Byte float64
8Byte string
1Byte （英文） / 2Byte-4Byte（中文，取决于字符编码类型） 切片拼接 slice1 := []int{0, 1, 2, 3} slice2 := []int{3, 4, 5} slice1 = append(slice1, slice2.</description></item><item><title>time</title><link>https://ormissia.github.io/notes/go/advance/time/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/go/advance/time/</guid><description>时间转换 字符串转时间
time.Parse() 时间转字符串
time.Format() 时间转时间戳
Time.Unix() 时间戳转时间
time.Unix() 计时 朴素方法
startTime := time.Now() //do something time.Sleep(time.Second) duration := time.Since(startTime) fmt.Printf(&amp;#34;经过时间：%v\n&amp;#34;, duration) //经过时间：1.005046959s 简洁方法
// TimeCost 耗时统计函数 func TimeCost(start time.Time) { duration := time.Since(start) fmt.Printf(&amp;#34;经过时间：%v\n&amp;#34;, duration) } defer TimeCost(time.Now()) //do something time.Sleep(time.Second) //经过时间：1.005054375s 优雅方法
// TimeCost 耗时统计函数 func TimeCost() func() { start := time.Now() return func() { duration := time.Since(start) fmt.Printf(&amp;#34;经过时间：%v\n&amp;#34;, duration) } } defer TimeCost()() //do something time.Sleep(time.Second) //经过时间：1.</description></item><item><title>go mod</title><link>https://ormissia.github.io/notes/go/advance/gomod/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/go/advance/gomod/</guid><description> go get 下载指定版本 go get github.com/ormissia/go-opv@v0.0.2</description></item><item><title>go chan</title><link>https://ormissia.github.io/notes/go/advance/chan/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/go/advance/chan/</guid><description> go chan close 在go的chan中，chan被关闭后，消费者会继续读取channel中的消息。直到消息被全部读取之后使用i, ok := &amp;lt;-ch得到的ok才会变为false
下面是测试代码以及运行时控制台打印结果：
func main() { ch := make(chan int, 3) go producer(ch) for { i, ok := &amp;lt;-ch fmt.Printf(&amp;#34;consume msg: %d\tok: %v\n&amp;#34;, i, ok) time.Sleep(time.Second * 3) } } func producer(ch chan int) { for i := 0; i &amp;lt; 10; i++ { ch &amp;lt;- i fmt.Printf(&amp;#34;produce msg: %d\n&amp;#34;, i) time.Sleep(time.Second) } close(ch) fmt.Println(&amp;#34;chan closed&amp;#34;) } 输出结果
produce msg: 0 consume msg: 0 ok: true produce msg: 1 produce msg: 2 consume msg: 1 ok: true produce msg: 3 produce msg: 4 consume msg: 2 ok: true produce msg: 5 consume msg: 3 ok: true produce msg: 6 consume msg: 4 ok: true produce msg: 7 consume msg: 5 ok: true produce msg: 8 consume msg: 6 ok: true produce msg: 9 chan closed consume msg: 7 ok: true consume msg: 8 ok: true consume msg: 9 ok: true consume msg: 0 ok: false consume msg: 0 ok: false</description></item><item><title>Basic</title><link>https://ormissia.github.io/notes/go/algorithm/basic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/go/algorithm/basic/</guid><description>异或 异或运算法则：无进位相加 异或运算性质： 0 ^ N = N N ^ N = 0 满足交换律和结合律 a := 0b1100 b := 0b1001 fmt.Printf(&amp;#34;%b&amp;#34;,a^b) //101 简单应用：不申请额外内存交换两个变量的值
a := 0b1100 b := 0b1001 a = a ^ b b = a ^ b //b = (a ^ b) ^ b = a a = a ^ b //a = (a ^ b) ^ a = b fmt.Printf(&amp;#34;a:%b,b:%b&amp;#34;, a, b) //a:1001,b:1100 堆 堆的实质是一棵完全二叉树
堆可分为两种类型：</description></item><item><title>Basic Types</title><link>https://ormissia.github.io/notes/java/basic/basic_type/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/java/basic/basic_type/</guid><description> Strings test
String str = &amp;#34;123&amp;#34;;</description></item><item><title>Basic Types</title><link>https://ormissia.github.io/notes/scala/basic/basic_type/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/scala/basic/basic_type/</guid><description>函数 函数参数为val类型，且可以给出默认值
def test(a: Int, b: Int = 1, c: Int = 2): Unit = { println(s&amp;#34;$a $b $c&amp;#34;) } test(1, 2) //1 2 2 test(1, c = 4) //1 1 4 匿名函数 函数是带有参数的表达式。
(x: Int) =&amp;gt; x + 1 方法 方法的表现和行为和函数非常类似，但是它们之间有一些关键的差别。
方法由def关键字定义。def后面跟着一个名字、参数列表、返回类型和方法体。
def addThenMultiply(x: Int, y: Int)(multiplier: Int): Int = (x + y) * multiplier println(addThenMultiply(1, 2)(3)) // 9 字符串拼接 val a = 1 val b = 2 val c = s&amp;#34;$a+$b=${a + b}&amp;#34; 对象 约等于static单例对象</description></item><item><title>Basic</title><link>https://ormissia.github.io/notes/python/basic/basic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/python/basic/basic/</guid><description>函数 在 python 中，类型属于对象，变量是没有类型的：
a=[1,2,3] a=&amp;#34;ormissia&amp;#34; 以上代码中，[1,2,3]是List类型，&amp;quot;ormissia&amp;quot;是String类型，而变量a是没有类型，他仅仅是一个对象的引用（一个指针），可以是指向List类型对象，也可以是指向String类型对象。
可更改(mutable)与不可更改(immutable)对象 在python中，strings，tuples和numbers是不可更改的对象，而list，dict等则是可以修改的对象。
不可变类型：变量赋值a=5后再赋值a=10，这里实际是新生成一个int值对象10，再让a指向它，而5被丢弃，不是改变a的值，相当于新生成了a。
可变类型：变量赋值la = [1,2,3,4]后再赋值la[2] = 5则是将list la的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。
python函数的参数传递： 不可变类型：类似C++的值传递，如整数、字符串、元组。如fun(a)，传递的只是a的值，没有影响a对象本身。如果在fun(a)内部修改a的值，则是新生成一个a的对象。
可变类型：类似C++的引用传递，如列表，字典。如fun(la)，则是将la真正的传过去，修改后fun外部的la也会受影响
python中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。</description></item><item><title>Basic</title><link>https://ormissia.github.io/notes/js/basic/basic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/js/basic/basic/</guid><description> 函数</description></item><item><title>SQL DML</title><link>https://ormissia.github.io/notes/sql/dml/dml/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/sql/dml/dml/</guid><description>按年月日分组聚合 group by date_format(field_name, format); 根据format字符串格式化date值。下列修饰符可以被用在format字符串中：
%M 月名字(January……December) %W 星期名字(Sunday……Saturday) %D 有英语前缀的月份的日期(1st, 2nd, 3rd, 等等。） %Y 年, 数字, 4 位 %y 年, 数字, 2 位 %a 缩写的星期名字(Sun……Sat) %d 月份中的天数, 数字(00……31) %e 月份中的天数, 数字(0……31) %m 月, 数字(01……12) %c 月, 数字(1……12) %b 缩写的月份名字(Jan……Dec) %j 一年中的天数(001……366) %H 小时(00……23) %k 小时(0……23) %h 小时(01……12) %I 小时(01……12) %l 小时(1……12) %i 分钟, 数字(00……59) %r 时间,12 小时(hh:mm:ss [AP]M) %T 时间,24 小时(hh:mm:ss) %S 秒(00……59) %s 秒(00……59) %p AM或PM %w 一个星期中的天数(0=Sunday ……6=Saturday ） %U 星期(0……52), 这里星期天是星期的第一天 %u 星期(0……52), 这里星期一是星期的第一天 %% 一个文字“%” count统计不重复个数 select count(distinct (field_name)) from table_name sum结果为null时置为0 SQL中使用sum统计总数时:sum(col_name)，如果某列不符合sum的条件（比如某列中含有NULL元素，或者不是数值类型，或者没有符合where条件的行），那么会返回NULL 有的时候不希望sum的结果为NULL，可以做如下的处理：</description></item><item><title>Basic</title><link>https://ormissia.github.io/notes/linux/shell/basic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/linux/shell/basic/</guid><description>快捷键 回到命令行开头&amp;ndash;Home
Ctrl+a 回到命令行的尾部&amp;ndash;End
Ctrl+e 删除光标前边的所有字符
Ctrl+u 删除光标后边的所有字符
Ctrl+k 删除光标前的一个单词
Ctrl+w 输入曾经的命令下的某个单词或字母，按照单词的匹配history
Ctrl+r cat 在cat输出时候显示行数
cat -n maim.go wc 统计文件行、单词、字符数量 格式：
usage: wc [-clmw] [file ...] 统计main.go的行、单词、字符数量
wc main.go 选项：
-l 统计行数 -c 统计字符数 -w 统计单词数 -L 统计最长的行的字符数 nc 简单的文件传输工具
接收方
nc -l [port] &amp;gt; filename 发送方
nc [ip] [port] &amp;lt; filename gzip 解压*.gz的压缩文件
与*.tar.gz文件不同，*.gz文件需要用gzip来解压
gzip -d filename hostnamectl 修改hostname，重启也生效
hostnamectl set-hostname CentOS 查看hostname
hostname echo -n：不换行 -e：支持扩展属性
# 红色显示OK echo -e &amp;#34;\033[31mOK\033[0m&amp;#34; # 绿色显示OK echo -e &amp;#34;\033[32mOK\033[0m&amp;#34; tr 删除多余重复字符串</description></item><item><title>Advance</title><link>https://ormissia.github.io/notes/linux/shell/advance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/linux/shell/advance/</guid><description>xargs xargs是给命令传递参数的一个过滤器，可以将管道或标准输入（stdin）数据转换成命令行参数，也能够从文件的输出中读取数据，一般是和管道一起使用。 格式:
somecommand | xargs [-item] [command] 选项：
-a file 从文件中读入作为 stdin -e flag ，注意有的时候可能会是-E，flag必须是一个以空格分隔的标志，当xargs分析到含有flag这个标志的时候就停止。 -p 当每次执行一个argument的时候询问一次用户。 -n num 后面加次数，表示命令在执行的时候一次用的argument的个数，默认是用所有的。 -t 表示先打印命令，然后再执行。 -i 或者是-I，这得看linux支持了，将xargs的每项名称，一般是一行一行赋值给 {}，可以用 {} 代替。 -r no-run-if-empty 当xargs的输入为空的时候则停止xargs，不用再去执行了。 -s num 命令行的最大字符数，指的是 xargs 后面那个命令的最大命令行字符数。 -L num 从标准输入一次读取 num 行送给 command 命令。 -l 同 -L。 -d delim 分隔符，默认的xargs分隔符是回车，argument的分隔符是空格，这里修改的是xargs的分隔符。 -x exit的意思，主要是配合-s使用。。 top Linux top命令VIRT,RES,SHR,DATA的含义:
VIRT:virtual memory usage虚拟内存 进程“需要的”虚拟内存大小，包括进程使用的库、代码、数据等 假如进程申请100m的内存，但实际只使用了10m，那么它会增长100m，而不是实际的使用量 RES:resident memory usage常驻内存 进程当前使用的内存大小，但不包括swap out 包含其他进程的共享 如果申请100m的内存，实际使用10m，它只增长10m，与VIRT相反 关于库占用内存的情况，它只统计加载的库文件所占内存大小 SHR:shared memory共享内存 除了自身进程的共享内存，也包括其他进程的共享内存 虽然进程只使用了几个共享库的函数，但它包含了整个共享库的大小 计算某个进程所占的物理内存大小公式：RES – SHR swap out后，它将会降下来 top运行中可以通过top的内部命令对进程的显示方式进行控制。内部命令如下：</description></item><item><title>vi</title><link>https://ormissia.github.io/notes/linux/shell/vi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/linux/shell/vi/</guid><description> 命令 显示行号
:set number 在vi中执行shell命令
:!ls-l 将shell命令的结果插入到当前行的下一行
:r !date //读取系统时间并插入到当前行的下一行 将起始行号和结束行号指定的范围中的内容输入到shell命令command处理，并将处理结果替换起始行号和结束行号指定的范围中的内容
:62,72 !sort //将62行到72行的内容进行排序 当前光标所在行，除可以指定行号外，也可以用.表示
:. !tr [a-z] [A-Z] //将当前行的小写转为大写 将起始行号和结束行号所指定的范围的内容作为命令command的输入，不会改变当前编辑的文件的内容
:62,72 w !sort //将62行到72行的内容进行排序，但排序的结果并不会直接输出到当前编辑的文件中，而是显示在vim敲命令的区域 将某一行作为shell命令执行
:62 w !shell //将会把第62行的内容作为shell命令来执行并显示结果，而且不会改变当前编辑的文件的内容</description></item><item><title>Script</title><link>https://ormissia.github.io/notes/linux/shell/script/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/linux/shell/script/</guid><description>脚本执行方式 需要可执行权限 相对路径执行 绝对路径执行 不需要可执行权限 sh 脚本文件名 source 脚本文件名 // 不会启动子进程，通过pstree查看进程树 定义变量 定义变量：变量名=变量值 取消变量：unset 变量名 注意事项： =两边不能有空格 不能使用关键字做变量名，如：ls、cd等 如果变量名已存在，则会覆盖之前的变量值 变量名称由字母、数字、下划线组成，不能以数字开头 变量类型 环境变量：变量名通常大写，由操作系统维护 位置变量：shell内置变量，存储脚本执行时的参数 使用$n表示，n为数字序列号：$1、$2、&amp;hellip;、${10}、${11}、&amp;hellip; 预定义变量：shell内置变量，可以直接调用但是不能赋值或修改' $0：存储所在的进程或脚本名 $$：当前进程的PID号 $?：命令执行后的返回状态，0-正常，其他-异常 $#：已加载的位置变量的个数 $*：所有位置变量的值 自定义变量：用户自主设置 多种引号的区别 双引号：允许扩展，以$引用其他变量 单引号：禁用扩展，将$视为普通字符 反引号：将命令执行的输出作为变量值，$()与反引号等效 变量的作用范围 局部变量：新定义的变量默认只在当前Shell中有效，无法在子Shell环境中使用 全局变量：在当前Shell以及子Shell中均有效（export a=1：定义全局变量a） read标准输入取值 read从键盘读入变量值完成赋值
格式：read [参数] [变量名] 参数： -p：提示信息 -t：指定超时秒数 -s：设置是否在终端显示输入的内容 变量作用范围 局部变量 新定义的变量默认只在当前Shell环境中有效，无法在子Shell环境中使用 全局变量 全局变量在当前Shell及子Shell中均有效，定义格式：export a=1 数学运算 整数运算
使用$[]或$(())表达式
格式：$[整数1 运算符 整数2]
小数运算
Bash内建机制仅支持整数运算，不支持小数运算 可以通过计算器软件bc实现小数计算
如果没有该软件需要使用yum安装 bc支持交互式和非交互式两种方式计算，scale=n可以约束小数位
bc也支持比较操作： &amp;gt;,&amp;gt;=,&amp;lt;,&amp;lt;=,==,!= 表达式成立返回1，否则返回0
字符串 字符串比较</description></item><item><title>Memory</title><link>https://ormissia.github.io/notes/linux/system/system/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/linux/system/system/</guid><description>内存 一般来说内存占用大小有如下规律：VSS &amp;gt;= RSS &amp;gt;= PSS &amp;gt;= USS
VSS - Virtual Set Size 虚拟耗用内存（包含共享库占用的内存） RSS - Resident Set Size 实际使用物理内存（包含共享库占用的内存） PSS - Proportional Set Size 实际使用的物理内存（比例分配共享库占用的内存） USS - Unique Set Size 进程独自占用的物理内存（不包含共享库占用的内存） RSS / VSZ
RSS是Resident Set Size（常驻内存大小）的缩写，用于表示进程使用了多少内存（RAM中的物理内存）， RSS不包含已经被换出的内存。RSS包含了它所链接的动态库并且被加载到物理内存中的内存。RSS还包含栈内存和堆内存。 VSZ是Virtual Memory Size（虚拟内存大小）的缩写。它包含了进程所能访问的所有内存，包含了被换出的内存， 被分配但是还没有被使用的内存，以及动态库中的内存。 假设进程A的二进制文件是500K，并且链接了一个2500K的动态库，堆和栈共使用了200K，其中100K在内存中（剩下的被换出或者不再被使用）， 一共加载了动态库中的1000K内容以及二进制文件中的400K内容至内存中，那么：
RSS: 400K + 1000K + 100K = 1500K VSZ: 500K + 2500K + 200K = 3200K 由于部分内存是共享的，被多个进程使用，所以如果将所有进程的RSS值加起来可能会大于系统的内存总量。
申请过的内存如果程序没有实际使用，则可能不显示在RSS里。比如说一个程序，预先申请了一大批内存， 过了一段时间才使用，你会发现RSS会增长而VSZ保持不变。
还有一个概念是PSS，它是proportional set size（proportional是成比例的意思）的缩写。 这是一种新的度量方式。它将动态库所使用的内存按比例划分。比如我们前面例子中的动态库如果是被两个进程使用，那么：
PSS: 400K + (1000K/2) + 100K = 400K + 500K + 100K = 1000K 一个进程中的多个线程共享同样的地址空间。所以一个进程中的多个线程的RSS，VSZ，PSS是完全相同的。linux下可以使用ps或者top命令查看这些信息。</description></item><item><title>Basic</title><link>https://ormissia.github.io/notes/hbase/shell/basic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/hbase/shell/basic/</guid><description>shell 在hbase的shell中scan时指定列
scan &amp;#39;table_name&amp;#39;,{STARTROW=&amp;gt;&amp;#39;start_row&amp;#39;,ENDROW=&amp;gt;&amp;#39;end_row&amp;#39;,LIMIT=&amp;gt;100,COLUMNS=&amp;gt;[&amp;#39;info:type&amp;#39;]} COLUMNS=&amp;gt;['info:type']中参数为数组，可以指定列簇名和列名</description></item><item><title>Basic</title><link>https://ormissia.github.io/notes/kafka/shell/basic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/kafka/shell/basic/</guid><description> shell 查询消费者组
kafka-consumer-groups.sh --bootstrap-server bigdata7:9092 --list kafka-consumer-groups.sh --bootstrap-server bigdata7:9092 --describe --group group_name 删除消费者组
kafka-consumer-groups.sh --bootstrap-server bigdata7:9092 --delete --group group_name 查看topic消息数量
kafka-run-class.sh kafka.tools.GetOffsetShell --bootstrap-server bigdata7:9092 --topic topic_name --time -1</description></item><item><title/><link>https://ormissia.github.io/notes/my_notes/notes/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/my_notes/notes/readme/</guid><description>notes 我的笔记本</description></item><item><title/><link>https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E4%B8%AD%E9%97%B4%E4%BB%B6/kubernetes/client-go/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E4%B8%AD%E9%97%B4%E4%BB%B6/kubernetes/client-go/</guid><description>client-go #k8s #kubernetes #clientgo #apiserver #go #golang
基础使用 源码仓库 依赖引入 go get k8s.io/client-go@latest go get k8s.io/client-go@v0.20.4 client-go 客户端 架构 图片来源
客户端组件 Reflector：反射器，定义在 type Reflector inside package cache 中，监视 Kubernetes API 的指定资源类型（种类）。完成此操作的函数是 ListAndWatch。监视可以用于内置资源，也可以用于自定义资源。当 Reflector 通过 watch API 接收到关于新资源实例存在的通知时，它使用相应的 listing API 获取新创建的对象并将其放入 watchHandler 函数内的 Delta Fifo 队列中。 Informer：在 base controller inside package cache 中定义的 Informer 从 Delta Fifo 队列中弹出对象。完成此操作的函数是 processLoop。这个基本控制器的工作是保存对象供以后检索，并调用我们的控制器将对象传递给它。 Indexer：索引器提供对象的索引功能。在 type Indexer inside package cache 中定义。一个典型的索引用例是基于对象标签创建索引。Indexer 可以维护基于多个索引函数的索引。索引器使用线程安全的数据存储来存储对象及其键。type Store inside package cache 中定义了一个名为 MetaNamespaceKeyFunc 的默认函数，它生成 &amp;lt;namespace&amp;gt;/&amp;lt;name&amp;gt; 的键作为该对象的组合。 自定义控制器组件 Informer reference：这是对知道如何使用自定义资源对象的 Informer 实例的引用。自定义控制器代码需要创建适当的 Informer。 Indexer reference：这是对知道如何使用自定义资源对象的 Indexer 实例的引用。自定义控制器代码需要创建它。将使用此引用来检索对象以供以后处理。 client-go 中的 base controller 提供了 NewIndexerInformer 函数来创建 Informer 和 Indexer。在代码中，可以直接调用此函数或使用工厂方法来创建Informer。</description></item><item><title/><link>https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E4%B8%AD%E9%97%B4%E4%BB%B6/kubernetes/kubernetes-%E7%BB%84%E4%BB%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E4%B8%AD%E9%97%B4%E4%BB%B6/kubernetes/kubernetes-%E7%BB%84%E4%BB%B6/</guid><description>Kubernetes 组件 #k8s #kubernetes #容器 #云 #go #golang
控制平面组件（Control Plane Components） 控制平面组件会为集群做出全局决策，比如资源的调度。 以及检测和响应集群事件，例如当不满足部署的 replicas 字段时， 要启动新的 pod）。
控制平面组件可以在集群中的任何节点上运行。 然而，为了简单起见，设置脚本通常会在同一个计算机上启动所有控制平面组件， 并且不会在此计算机上运行用户容器。 请参阅使用 kubeadm 构建高可用性集群 中关于跨多机器控制平面设置的示例。
kube-apiserver API 服务器是 Kubernetes 控制平面的组件， 该组件负责公开了 Kubernetes API，负责处理接受请求的工作。 API 服务器是 Kubernetes 控制平面的前端。
Kubernetes API 服务器的主要实现是 kube-apiserver。 kube-apiserver 设计上考虑了水平扩缩，也就是说，它可通过部署多个实例来进行扩缩。 你可以运行 kube-apiserver 的多个实例，并在这些实例之间平衡流量。
etcd 一致且高可用的键值存储，用作 Kubernetes 所有集群数据的后台数据库。
如果你的 Kubernetes 集群使用 etcd 作为其后台数据库， 请确保你针对这些数据有一份 备份计划。
你可以在官方文档中找到有关 etcd 的深入知识。
kube-scheduler kube-scheduler 是控制平面的组件， 负责监视新创建的、未指定运行节点（node）的 Pods， 并选择节点来让 Pod 在上面运行。
调度决策考虑的因素包括单个 Pod 及 Pods 集合的资源需求、软硬件及策略约束、 亲和性及反亲和性规范、数据位置、工作负载间的干扰及最后时限。</description></item><item><title/><link>https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E4%B8%AD%E9%97%B4%E4%BB%B6/mysql/mysql/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E4%B8%AD%E9%97%B4%E4%BB%B6/mysql/mysql/</guid><description>MySQL #mysql #数据库 #db #b加树
基础 #事务 只有 InnoDB 引擎才支持事务
MySQL 默认的事务隔离级别是可重复读（REPEATABLE READ）
#ACID 特性 原子性 (Atomicity)： 一致性 (Consistency)： 隔离性 (Isolation)： 持久性 (Durability)： 并发问题 脏读：当一个事务读取到另外一个事务修改但未提交的数据时，就可能发生脏读 不可重复读：“不可重复读”现象发生在当执行 SELECT 操作时没有获得读锁或者 SELECT 操作执行完后马上释放了读锁；另外一个事务对数据进行了更新， 读到了不同的结果 幻读：是&amp;rsquo;&amp;lsquo;不可重复读&amp;rsquo;&amp;lsquo;的一种特殊场景：当事务1两次执行&amp;rsquo;&amp;lsquo;SELECT &amp;hellip; WHERE&amp;rsquo;&amp;lsquo;检索一定范围内数据的操作中间，事务2在这个表中创建了 (如 INSERT 或 DELETE)了一行新数据，这条新数据正好满足事务1的“WHERE”子句。事务1执行了两遍同样的查询语句，第二遍比第一遍多出了一条数据，就是幻读 三者区别： 脏读：指读到了其他事务未提交的数据 不可重复读：读到了其他事务已提交的数据 (update)
不可重复读与幻读都是读到其他事务已提交的数据, 但是它们针对点不同 不可重复读：update 幻读：delete, insert
乐观锁与悲观锁 #悲观锁 ：在整个数据处理过程中，将数据处于锁定状态。读取数据时给加锁，其它事务无法修改这些数据。修改删除数据时也要加锁，其它事务无法读取这些数据 #乐观锁 ：相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。乐观锁，大多是基于数据版本（ Version ）记录机制实现。在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据 #隔离级别 事务隔离级别 脏读 不可重复读 幻读 读未提交 ✅ ✅ ✅ 读已提交 ❎ ✅ ✅ 可重复读 ❎ ❎ ✅ 串行化 ❎ ❎ ❎ 读未提交：该隔离级别因为可以读取到其他事务中未提交的数据，而未提交的数据可能会发生回滚，因此我们把该级别读取到的数据称之为脏数据，把这个问题称之为脏读。 读已提交：该隔离级别的事务能读取到已经提交事务的数据，因此它不会有脏读问题。但由于在事务的执行中可以读取到其他事务提交的结果，所以在不同时间的相同 SQL 查询中，可能会得到不同的结果，这种现象叫做不可重复读。 可重复读：可重复读，是 MySQL 的默认事务隔离级别，它能确保同一事务多次查询的结果一致。但也会有新的问题，比如此级别的事务正在执行时，另一个事务成功的插入了某条数据，但因为它每次查询的结果都是一样的，所以会导致查询不到这条数据，自己重复插入时又失败（因为唯一约束的原因）。明明在事务中查询不到这条信息，但自己就是插入不进去，这就叫幻读 （Phantom Read）。 序列化：序列化，事务最高隔离级别，它会强制事务排序，使之不会发生冲突，从而解决了脏读、不可重复读和幻读问题，但执行效率低。 #MVCC (多版本并发控制) 在 MySQL 中可重复读隔离级别就是通过 MVCC 来实现的乐观锁解决不可重复读问题。</description></item><item><title/><link>https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/redis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/redis/</guid><description>Redis #redis #中间件 #缓存 #db #内存缓存
基础数据类型 string list hash set zset bitmap 高级特性 #慢查询 #pipeline 多个命令一次请求减少网络开销
#事务 #Lua 原子操作
#Stream 底层原理 持久化 RDB save: 阻塞主线程 bgsave: 不阻塞主线程 AOF 分布式锁 setnx set lock_name 1 ex 10 nx 普通流程 加锁：set lock_name uuid ex 10 nx 业务操作 释放锁：lua 脚本，先 get 判断是否属于自己，再 del 释放锁 红锁流程 客户端获取当前时间戳T1 客户端依次向这 5 台 redis 实例（非集群）发起加锁请求 如果&amp;gt;=3个（大多数）成功，当前时间戳T2 - T1 &amp;lt; 锁的过期时间则加锁成功 加锁成功，操作业务 加锁失败/释放锁，向5台redis发起释放锁请求 集群 一主多从 主从 哨兵 多主多从 虚拟一致性哈希 -&amp;gt; 虚拟槽分区</description></item><item><title/><link>https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/freertos/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/freertos/</guid><description>FreeRTOS #操作系统 #freertos #嵌入式</description></item><item><title/><link>https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/</guid><description>Linux #操作系统 #linux
进程管理 查看进程 ps 查看某个时间点的进程信息。
示例：查看自己的进程
ps -l 示例：查看系统所有进程
ps aux 示例：查看特定的进程
ps aux | grep threadx pstree 查看进程树。
示例：查看所有进程树
pstree -A top 实时显示进程信息。
示例：两秒钟刷新一次
top -d 2 netstat 查看占用端口的进程
示例：查看特定端口的进程
netstat -anp | grep port 进程状态 状态 说明 R running or runnable (on run queue)正在执行或者可执行，此时进程位于执行队列中。 D uninterruptible sleep (usually I/O)不可中断阻塞，通常为 IO 阻塞。 S interruptible sleep (waiting for an event to complete) 可中断阻塞，此时进程正在等待某个事件完成。 Z zombie (terminated but not reaped by its parent)僵死，进程已经终止但是尚未被其父进程获取信息。 T stopped (either by a job control signal or because it is being traced) 结束，进程既可以被作业控制信号结束，也可能是正在被追踪。 #孤儿进程 一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。</description></item><item><title/><link>https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ubuntu/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ubuntu/</guid><description>Ubuntu #linux #ubuntu #ssh
开启 SSH 服务 检查是否有 ssh
ps -e | grep ssh 更新软件列表和软件
sudo apt-get update sudo apt-get upgrade 安装 ssh
sudo apt-get install ssh 启动 ssh
sudo /etc/int.d/ssh start 再次检查是否有 ssh，当结果里看到 sshd 即为 ssh 服务端已启动</description></item><item><title/><link>https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/</guid><description>操作系统零碎知识点 #操作系统
#进程 、 #线程 、 #协程 的区别 进程：操作系统分配资源的单位，进程包含了一组资源，其中有进程的唯一 ID、虚拟地址空间、打开文件描述符（或句柄表）等，还有至少一个线程，也就是主线程 线程：CPU 调度的基本单位，在多线程模式下，进程打算开的文件描述符表、文件系统信息、虚拟地址空间、和命名空间是被进程内所有线程共享的，但是每个线程拥有自己的内核数据结构、内核栈和用户栈、以及信号处理器 协程： 异同：
进程拥有自己独立的堆栈，堆栈均不共享 线程拥有独立的栈，共享堆 协程同线程一样共享堆但不共享栈 #CPU密集型 / #IO密集型 CPU 密集型任务一般更看重吞吐量，所以要尽量减少上下文切换，每次直接用完时间片就行了，所以对这种场景协程是非必要的。 IO 密集型任务可能更看重相应延迟，例如常见的 web 服务器 #乐观锁 / #悲观锁 悲观锁：访问资源的时候对资源加锁，未解锁之前，不允许其他访问者访问该资源 乐观锁：认为不会与其他访问冲突，因此默认不加锁，通常是通过对访问资源添加版本或是时间戳来控制数据的正确性 #零拷贝</description></item><item><title/><link>https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</guid><description>动态规划 #算法 #动态规划
基础思想：使用自然智慧写出递归代码，然后使用递归的依赖关系以及边界条件该出动态规划算法
模型 自左向右的尝试模型 范围上的尝试模型 多样本位置全对应的尝试模型 寻找业务限制的尝试模型</description></item><item><title/><link>https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E6%A0%88%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E6%A0%88%E7%BB%93%E6%9E%84/</guid><description>单调栈结构 #算法 #栈 #单调栈</description></item><item><title/><link>https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/</guid><description>基础算法 #算法
#排序 #选择排序 #冒泡排序 #插入排序 #归并排序 #快速排序 #堆排序 [[计算机/算法/数据结构#堆]]
#桶排序 查找 #二分查找</description></item><item><title/><link>https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid><description>数据结构 #算法
#位运算 #位图 #异或 #同或 题目 #链表 #单链表 逆序 实现 #队列 实现栈 #双链表 逆序 实现 #双端队列 题目 多个 #有序链表 合并 先把所有头结点放入小根堆
#树 #二叉树 遍历 先序遍历 中序遍历 后序遍历 Morris 序遍历 #堆 #大根堆 #小根堆 #最小四叉堆 #搜索二叉树 每一棵子树，左树的值比我小，右树的值比我大（中序遍历升序）
#平衡二叉树 左树和右树高度相差不超过1
SB 树 #平衡搜索二叉树 #红黑树 题目 #b加树 [[计算机/中间件/MySQL]]
图</description></item><item><title/><link>https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%AE%97%E6%B3%95/%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6%E6%8A%80%E5%B7%A7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%AE%97%E6%B3%95/%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6%E6%8A%80%E5%B7%A7/</guid><description>资源限制技巧 #算法
布隆过滤器用于集合的建立与查询，可以节省大量空间 一致性哈希解决数据服务器的负载管理问题 利用并查集结构做岛问题的并行计算 哈希函数可以把数据按照种类均匀分流 位图解决某一范围上数字的出现情况，并可以节省大量空间 利用分段统计思想，进一步节省大量空间 利用堆、外排序来做多个处理单元的结果合并</description></item><item><title/><link>https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/http/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/http/</guid><description>HTTP #网络 #http
基础概念 请求和响应报文 客户端发送一个请求报文给服务器，服务器根据请求报文中的信息进行处理，并将处理结果放入响应报文中返回给客户端。
请求报文结构：
第一行是包含了请求方法、URL、协议版本； 接下来的多行都是请求首部 Header，每个首部都有一个首部名称，以及对应的值。 一个空行用来分隔首部和内容主体 Body 最后是请求的内容主体 GET http://www.example.com/ HTTP/1.1 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en;q=0.8 Cache-Control: max-age=0 Host: www.example.com If-Modified-Since: Thu, 17 Oct 2019 07:18:26 GMT If-None-Match: &amp;#34;3147526947+gzip&amp;#34; Proxy-Connection: keep-alive Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 xxx param1=1&amp;amp;param2=2 响应报文结构：
第一行包含协议版本、状态码以及描述，最常见的是 200 OK 表示请求成功了 接下来多行也是首部内容 一个空行分隔首部和内容主体 最后是响应的内容主体 HTTP/1.1 200 OK Age: 529651 Cache-Control: max-age=604800 Connection: keep-alive Content-Encoding: gzip Content-Length: 648 Content-Type: text/html; charset=UTF-8 Date: Mon, 02 Nov 2020 17:53:39 GMT Etag: &amp;#34;3147526947+ident+gzip&amp;#34; Expires: Mon, 09 Nov 2020 17:53:39 GMT Keep-Alive: timeout=4 Last-Modified: Thu, 17 Oct 2019 07:18:26 GMT Proxy-Connection: keep-alive Server: ECS (sjc/16DF) Vary: Accept-Encoding X-Cache: HIT &amp;lt;!</description></item><item><title/><link>https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/tcp%E4%B8%8Eudp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/tcp%E4%B8%8Eudp/</guid><description>TCP/UDP #网络 #tcp #udp
TCP</description></item><item><title/><link>https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9Cio%E6%BC%94%E8%BF%9B%E5%8E%86%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9Cio%E6%BC%94%E8%BF%9B%E5%8E%86%E7%A8%8B/</guid><description>网络IO演进历程 #epoll #linux #网络 #网络模型
网络 IO 模型演进 阻塞 IO #BIO (Blocking IO) 非阻塞 IO #NIO (Nonblocking IO) IO 多路复用第一版 #select / #poll / #epoll 异步 IO #AIO (Async IO) BIO 阻塞 IO，顾名思义当用户发生了系统调用后，如果数据未从网卡到达内核态，内核态数据未准备好，此时会一直阻塞。直到数据就绪，然后从内核态拷贝到用户态再返回。
BIO 缺点，能支持的并发连接数比较少： 一台服务器能分配的线程数是有限的 大量线程频繁切换上下文会影响性能 核心矛盾：一个 client 分配一个线程是因为处理客户端读写是阻塞式的，为避免该阻塞影响接受后续新的 client 的连接，所以将阻塞逻辑交由单独的线程处理。
NIO 非阻塞 IO：见名知意，就是在第一阶段 (网卡-内核态) 数据未到达时不等待，然后直接返回。因此非阻塞 IO 需要不断的用户发起请求，轮询内核。
优点：将 socket 设为非阻塞后，在读取时如果数据未就绪就直接返回。可以通过一个线程管理多个 client 连接。 缺点：需要不断轮询内核，数据是否已经就绪，会造成很多无效的，太频繁的系统调用 (system call) 而造成资源浪费。 select/poll/epoll select 和 poll 的区别 select 能处理的最大连接，默认是 1024 个，可以通过修改配置来改变，但终究是有限个；而 poll 理论上可以支持无限个 select 和 poll 在管理海量的连接时，会频繁的从用户态拷贝到内核态，比较消耗资源 epoll 对文件描述符的操作有两种模式： LT（level trigger）和 ET（edge trigger）。</description></item><item><title/><link>https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AF%AD%E8%A8%80/c++/c++-%E8%AF%AD%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AF%AD%E8%A8%80/c++/c++-%E8%AF%AD%E6%B3%95/</guid><description>C++ #CPP #编程语言</description></item><item><title/><link>https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AF%AD%E8%A8%80/go/go-gmp-%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AF%AD%E8%A8%80/go/go-gmp-%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B/</guid><description>Go GMP 调度模型 #go #golang #gmp #scheduler #抢占式调度 #goroutine #协程 #gmp
所谓 GMP，其中 G 是指 goroutine；M 是 Machine 的缩写，指的是工作线程；P 则是指处理器 Processor，代表了一组资源，M 要想执行 G 的代码，必须持有一个 P 才行。
简单来说，GMP 就是 Task、Worker、Resource 的关系，G 和 P 都是 Go 语言实现的抽象程度更高的组件，对于工作线程而言，Machine 一词表明了它与具体的操作系统和平台密切相关，对具体平台的适配和特殊处理等大多在这一层实现。
从 GM 到 GMP GM 模型调度的几个明显问题 用一个全局的 mutex 保护一个全局的 runq（就绪队列），造成对锁的竞争异常严重 G 每次执行都会被分发到随机的 M 上，造成在不同 M 之间频繁切换，破坏了程序的局部性 每个 M 都会关联一个内存分配缓存 mcache，造成大量内存开销，进一步使数据的局部性变差。实际上只有执行 Go 代码的 M 才真正需要 mcache，那些阻塞在系统调用中的 M 根本不需要，而实际执行 Go 代码的 M 可能仅占总数的 1% 在存在系统调用的情况下，工作线程经常被阻塞和解除阻塞，从而增加了很多开销 通过 runtime.</description></item><item><title/><link>https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AF%AD%E8%A8%80/go/go-netpoll-%E5%8E%9F%E7%94%9F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AF%AD%E8%A8%80/go/go-netpoll-%E5%8E%9F%E7%94%9F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</guid><description>Go netpoll 原生网络模型 #go #golang #tcp #网络 #网络模型 #netpoll #epoll
一个简单的 TCP 服务器 func main() { l, err := net.Listen(&amp;#34;tcp4&amp;#34;, &amp;#34;:8000&amp;#34;) if err != nil { log.Fatal(err) } defer func() { _ = l.Close() }() log.Println(&amp;#34;server listen port: 8000&amp;#34;) var id int for { conn, err := l.Accept() if err != nil { log.Fatal(err) } id++ go func(id int, conn net.Conn) { defer func() { _ = conn.Close() }() var packet [0xFFF]byte for { n, err := conn.</description></item><item><title/><link>https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AF%AD%E8%A8%80/go/go-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AF%AD%E8%A8%80/go/go-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/</guid><description>Go 原子操作 #go #golang #atomic #原子操作
互斥锁跟原子操作的区别 在并发编程里，Go 语言 sync 包里的同步原语 Mutex 是我们经常用来保证并发安全的，但是他跟 atomic 包在使用目的和底层实现上都不一样：
&amp;mdash;&amp;ndash; 互斥锁 原子操作 使用目的 保护一段逻辑 保护一个变量 底层实现 由操作系统的调度器实现 由底层硬件指令直接提供支持 相对性能 低 高 Mutex 由操作系统的调度器实现，而 atomic 包中的原子操作则由底层硬件指令直接提供支持，这些指令在执行的过程中是不允许中断的，因此原子操作可以在 lock-free 的情况下保证并发安全，并且它的性能也能做到随 CPU 个数的增多而线性扩展。
对于一个变量更新的保护，原子操作通常会更有效率，并且更能利用计算机多核的优势。
性能对比测试 互斥锁性能测试 使用 sync 包下面互斥锁的多线程加法操作
func syncAdd(param int64) int64 { var wg sync.WaitGroup lock := sync.Mutex{} for i := 0; i &amp;lt; 10; i++ { wg.Add(1) go func() { for i := 0; i &amp;lt; 1000000; i++ { lock.</description></item><item><title/><link>https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AF%AD%E8%A8%80/go/go-%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD%E4%B8%8E%E9%94%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AF%AD%E8%A8%80/go/go-%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD%E4%B8%8E%E9%94%81/</guid><description>Go 同步原语与锁 #go #golang #锁 #互斥锁 #读写锁
基本原语 #Mutex #RWMutex 扩展原语</description></item><item><title/><link>https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AF%AD%E8%A8%80/go/go-%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AF%AD%E8%A8%80/go/go-%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/</guid><description>Go 开源项目 #go #golang #开源
Go Kubernetes Gin Gorm gnet ants</description></item><item><title/><link>https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AF%AD%E8%A8%80/go/go-%E6%B1%87%E7%BC%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AF%AD%E8%A8%80/go/go-%E6%B1%87%E7%BC%96/</guid><description>Go 汇编 #go #golang #汇编
官方文档 链接</description></item><item><title/><link>https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AF%AD%E8%A8%80/go/go-%E8%AF%AD%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AF%AD%E8%A8%80/go/go-%E8%AF%AD%E6%B3%95/</guid><description>Go 语法 #go #golang #语法 #编程语言
设置代理 go env -w GOPROXY=https://goproxy.cn,direct init () 函数 init() 函数的执行顺序：
对同一个 go 文件的 init() 调用顺序是从上到下的。 对同一个 package 中不同文件是按文件名字符串比较&amp;quot;从小到大&amp;quot;顺序调用各文件中的 init() 函数。 对于不同的 package，如果不相互依赖的话，按照 main 包中”先 import 的后调用”的顺序调用其包中的 init()，如果 package 存在依赖，则先调用最早被依赖的 package 中的 init()，最后调用 main 函数。 如果 init 函数中使用了 println() 或者 print() 你会发现在执行过程中这两个不会按照你想象中的顺序执行。这两个函数官方只推荐在测试环境中使用，对于正式环境不要使用。 基本类型 类型 长度 默认值 说明 bool 1 false byte 1 0 uint8 rune 4 0 Unicode Code Point, int32 int/uint 4/8 0 32 或 64 位 int8/uint8 1 0 -128 ~ 127, 0 ~ 255，byte是uint8 的别名 int16/uint16 2 0 -32768 ~ 32767, 0 ~ 65535 int32/uint32 4 0 -21亿~ 21亿, 0 ~ 42亿，rune是int32 的别名 int64/uint64 8 0 float32 4 0.</description></item><item><title/><link>https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AF%AD%E8%A8%80/lua/lua-%E8%AF%AD%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AF%AD%E8%A8%80/lua/lua-%E8%AF%AD%E6%B3%95/</guid><description>Lua 语法 #lua #编程语言
注释 单行注释 -- 单行注释 多行注释 --[[ 多行注释 多行注释 ]] 数据类型 Lua 是动态类型语言，变量不要类型定义，只需要为变量赋值
Lua 中有 8 个基本类型分别为：nil、boolean、number、string、userdata、function、thread 和 table。
数据类型 描述 nil 值nil属于该类，表示一个无效值（在条件表达式中相当于false） boolean 包含两个值：false 和 true number 表示双精度类型的实浮点数 string 字符串由一对双引号或单引号来表示 function 由 C 或 Lua 编写的函数 userdata 表示任意存储在变量中的C数据结构 thread 表示执行的独立线路，用于执行协同程序 table Lua 中的表（table）其实是一个&amp;quot;关联数组&amp;quot;（associative arrays），数组的索引可以是数字、字符串或表类型。在 Lua 里，table 的创建是通过&amp;quot;构造表达式&amp;quot;来完成，最简单构造表达式是{}，用来创建一个空表。 可以使用 type 函数测试给定变量或者值的类型：
print(type(&amp;#34;Hello world&amp;#34;)) print(type(10.4 * 3)) print(type(print)) print(type(type)) print(type(true)) print(type(nil)) print(type(type(X))) --[[ 输出 string number function function boolean nil string ]] 变量 在默认情况下，变量总是认为是全局的，哪怕是语句块或是函数里，除非用 local 显式声明为局部变量</description></item><item><title/><link>https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AF%AD%E8%A8%80/rust/rust-%E8%AF%AD%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AF%AD%E8%A8%80/rust/rust-%E8%AF%AD%E6%B3%95/</guid><description>RUST #rust #编程语言</description></item><item><title/><link>https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E9%A1%B9%E7%9B%AE/go%E7%BC%93%E5%AD%98%E5%9E%AB%E7%89%87/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E9%A1%B9%E7%9B%AE/go%E7%BC%93%E5%AD%98%E5%9E%AB%E7%89%87/</guid><description>Go 缓存垫片 #go #缓存 #框架 #延时双删
一个数据库与内存之间的缓存适配器，运用了控制反转的思想。引入之后无需重复为每种实体实现相同的缓存策略
项目背景 大多数情况下我们在代码中添加 #Redis 作为缓存中间件之后都会多出很多代码来。每给一个实体添加缓存，都需要加一大堆代码。久而久之，代码库变得非常冗杂而且难看。
举个栗子，一个带缓存的实体的查询逻辑的伪代码：
func (e *TestS) Select() { e, ok := SelectFromRedis() if !ok { et, ok := SelectFromDB() if !ok { return } e = et go func() { SaveToCache(e) }() return } return } 假如一个服务中有多个需要维护到缓存中的实体，再加上删除，修改等其他逻辑，就会出现非常多的相似代码，导致维护十分麻烦，而且复用性极低。即使写成工具类，当有新服务加入时，也需要将代码拷来拷去，显得十分不专业。
因此，写了这个缓存适配器框架，使用 #控制反转 的思想，代码中的实体只需实现指定接口，删除、修改、查询时只需要调用该库的对应方法即可，无需关心具体实现，框架会自动完成缓存相关逻辑。
使用示例 缓存客户端实现CacheClintImpl接口 type CacheClintImpl interface { Del(key string) (int64, error) SetString(key, value string) error GetString(k string) (string, error) } 实现参考redis_storage.go
初始化缓存客户端并将缓存客户端示例初始化到框架中 redis_ex.</description></item><item><title/><link>https://ormissia.github.io/notes/my_notes/notes/%E8%AE%BE%E8%AE%A1/%E8%89%B2%E5%BD%A9%E6%90%AD%E9%85%8D/%E8%89%B2%E5%BD%A9%E6%90%AD%E9%85%8D%E6%A0%B7%E4%BE%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/my_notes/notes/%E8%AE%BE%E8%AE%A1/%E8%89%B2%E5%BD%A9%E6%90%AD%E9%85%8D/%E8%89%B2%E5%BD%A9%E6%90%AD%E9%85%8D%E6%A0%B7%E4%BE%8B/</guid><description>色彩搭配样例 #设计 #色彩搭配 #高级感
高级感撞色样例 使用时颜色代码前加 #
BE98AA 珊瑚粉红 3E3F4C 蓝莓 E1DAD9 灰白 4D3A59 烈淡紫</description></item><item><title/><link>https://ormissia.github.io/notes/my_notes/notes/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/ddia/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/my_notes/notes/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/ddia/</guid><description>DDIA #系统设计</description></item><item><title/><link>https://ormissia.github.io/notes/my_notes/notes/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E4%B8%80%E6%BB%B4%E6%B0%B4%E5%88%B0%E6%B5%B7%E6%B4%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/my_notes/notes/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E4%B8%80%E6%BB%B4%E6%B0%B4%E5%88%B0%E6%B5%B7%E6%B4%8B/</guid><description>一滴水到海洋 #读书笔记 #散文
这个世界上所有的事情似乎都可以有很多完全不同的观点，然而，实践了什么才重要，观点反而是次要的 （P 4） 生命力任何事都没有特别的意义，在平凡中找到真实的人，就会发现每一段每一刻都有尊贵的意义。（P 30） 亦不观恶而生嫌，亦不观善而勤措，亦不舍智而近愚，亦不抛迷而求悟（P 43） 一个人如果心中有明月，就知道月亮虽有阴晴圆缺，其实月的本身是没有变化的（P 46） 我们今天在忧心台湾社会的时候，很少思考到社会是一个整体，许多事情不会单独或偶然发生，就像一个番薯的腐败，是整个番薯的事情（P 166）</description></item><item><title/><link>https://ormissia.github.io/notes/my_notes/notes/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%85%AB%E6%AC%A1%E5%8D%B1%E6%9C%BA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/my_notes/notes/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%85%AB%E6%AC%A1%E5%8D%B1%E6%9C%BA/</guid><description>八次危机 #读书笔记 #经济</description></item><item><title/><link>https://ormissia.github.io/notes/my_notes/notes/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A6%82%E4%BD%95%E5%B1%A0%E9%BE%99/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/my_notes/notes/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A6%82%E4%BD%95%E5%B1%A0%E9%BE%99/</guid><description>如何屠龙 #读书笔记
&amp;ldquo;嘿，宝贝儿，想来我的城堡探索高塔吗？&amp;quot;（P 49） 在 12 世纪的热那亚，城中的大户人家都会在家宅旁边修建高耸而优雅的塔楼。&amp;hellip;&amp;hellip; 然后，这些家族在高塔顶端修建了投石机，这样他们就可以向其他高塔投掷大石块，把它们砸倒。（P 55） 也就是说，你和人打架在法律上有什么样的后果取决于双方谁的名声更好。（P 56） 理论上，有关犯罪和罪犯的消息传播的快慢取决于马的速度。（P 57）</description></item><item><title/><link>https://ormissia.github.io/notes/my_notes/notes/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6/tcp-ip%E5%8D%8F%E8%AE%AE%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/my_notes/notes/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6/tcp-ip%E5%8D%8F%E8%AE%AE%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/</guid><description>TCP-IP协议及其应用 #读书笔记 #计算机 #计算机综合
元数据 [!abstract] TCP-IP协议及其应用
书名： TCP-IP协议及其应用 作者： 林成浴 简介： 本书基于网络工程和应用需求，按照从低层到高层的逻辑顺序，有针对性地讲解TCP-IP的层次结构、工作原理和协议数据单元。全书共13章，内容包括TCP-IP基础、网络接口层、IP寻址与地址解析、IP协议、ICMP协议、IP路由、TCP与UDP协议、DNS与DHCP协议、应用层协议、SNMP协议、网络安全协议，以及IPv6协议。本书内容丰富，注重系统性和实践性，对于重点协议提供协议分析操作示范，引导读者直观地探索TCP-IP。编写过程中参考了最新的RFC文档，反映TCP-IP最新的一些发展动态。本书可作为计算机网络相关专业的教材，也可作为网络管理和维护人员的参考书以及各种培训班的教材。 出版时间 2013-07-01 00:00:00 ISBN： 9787115325228 分类： 计算机-计算机综合 出版社： 人民邮电出版社 PC地址：https://weread.qq.com/web/reader/c8a324507159a3c4c8a8016 高亮划线 1.3 TCP/IP协议簇 📌 TCP/IP协议一个个堆叠起来，就像一个栈，有时又称其为协议栈。
⏱ 2024-01-04 11:30:24 ^22651844-8-1442-1474
📌 ARP用于根据IP地址获取物理地址。RARP用于根据物理地址查找其IP地址
⏱ 2024-01-04 11:33:09 ^22651844-8-2361-2398
📌 TCP为主机提供可靠的面向连接的传输服务；UDP为应用层提供简单高效的无连接传输服务。
⏱ 2024-01-04 11:34:08 ^22651844-8-2871-2914
📌 TCP、UDP、ICMP、IGMP都要向IP传送数据，为区分要传送的数据来源于哪一种协议，在生成的IP首部中加入一个称为协议号的标识，其中协议号1标识为ICMP协议，6标识为TCP协议，17标识为UDP协议。
⏱ 2024-01-04 11:36:05 ^22651844-8-4556-4660
📌 一般TCP/IP网络给临时端口分配1024～5000之间的端口号，大于5000的端口号是为其他服务器预留的。
⏱ 2024-01-04 11:47:00 ^22651844-8-7213-7267
📌 将一个IP地址和一个端口号码合并起来，就成为插座（Socket）
⏱ 2024-01-04 11:48:02 ^22651844-8-7641-7673
1.4 协议分析 📌 在网络中，数据的收发是由网卡来完成的，网卡有以下4种接收模式。 · 广播：能够接收发送给自己的数据帧和网络中的广播信息。 · 多播：只能够接收多播数据。 · 直接：只能够接收发送给自己的数据帧。 · 混杂（Promiscuous Mode）：能够接收一切通过它的数据帧，而不管该数据是否是传给它的。 默认情况下，网卡处于广播模式</description></item><item><title/><link>https://ormissia.github.io/notes/my_notes/notes/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6/%E5%95%86%E4%B8%9A%E5%8C%96%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8%E5%AE%9E%E6%88%98%E6%9C%BA%E6%A2%B0%E5%B7%A5%E4%B8%9A%E5%87%BA%E7%89%88%E7%A4%BE%E5%8D%81%E5%9B%9B%E4%BA%94%E7%A1%AC%E6%A0%B8%E4%BA%A7%E5%93%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/my_notes/notes/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6/%E5%95%86%E4%B8%9A%E5%8C%96%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8%E5%AE%9E%E6%88%98%E6%9C%BA%E6%A2%B0%E5%B7%A5%E4%B8%9A%E5%87%BA%E7%89%88%E7%A4%BE%E5%8D%81%E5%9B%9B%E4%BA%94%E7%A1%AC%E6%A0%B8%E4%BA%A7%E5%93%81/</guid><description>商业化推荐系统服务应用实战（机械工业出版社“十四五”硬核产品） #读书笔记 #计算机 #计算机综合
元数据 [!abstract] 商业化推荐系统服务应用实战（机械工业出版社“十四五”硬核产品）
书名： 商业化推荐系统服务应用实战（机械工业出版社“十四五”硬核产品） 作者： 张乐 简介： 1. 内容经典：涵盖从推荐服务的商业创新模式到需求与解决方案管理、商业化版本发布、工作流支持以及绩效KPI体系设计和跨职能团队的沟通技术等内容 2. 实用性强：知识经验与实例相结合，从不同角度详细阐述说明了商业化推荐服务领域各部分的内容 出版时间 2022-04-01 00:00:00 ISBN： 9787111704201 分类： 计算机-计算机综合 出版社： 机械工业出版社 PC地址：https://weread.qq.com/web/reader/d5f32350813ab7519g0136fb 高亮划线 1.1 从推荐开始的商业创新 📌 商业化推荐服务本身就是“在合适的时间，合适的位置，为合适的客户提供合适的商品和服务”，因此商业模式的研究和商业化推荐服务在内部模式和结构上，就构成了一种天然的商业联系。
⏱ 2024-01-10 18:56:06 ^3300037373-6-1153-1237
📌 在没有分析清楚自有平台和业务的商业模式特点之前，简单模仿不同商业模式下的推荐服务，不仅不会带来预期的商业效果，可能还会适得其反。
⏱ 2024-01-10 18:56:30 ^3300037373-6-1290-1354
📌 按照企业发展阶段的经典模型，企业的生命周期可以分为初创期、发展期、成熟期和衰退期。
⏱ 2024-01-10 18:56:47 ^3300037373-6-5993-6053
2.1 需求的出发点和分析 📌 面对范围广泛的消费者市场，处于市场竞争地位的各类型经营企业，在各自业务领域中都存在类似的问题，即需要知道哪些消费者，在什么地方，愿意以什么样的代价，购买什么样的商品和服务。
⏱ 2024-01-10 18:57:03 ^3300037373-10-1029-1115
读书笔记 本书评论</description></item><item><title/><link>https://ormissia.github.io/notes/my_notes/notes/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6/%E5%A5%BD%E5%A5%BD%E8%B0%88%E6%81%8B%E7%88%B1%E8%AE%A9%E4%BB%96%E7%88%B1%E4%B8%8A%E4%BD%A0%E7%9A%8415%E4%B8%AA%E7%A7%98%E8%AF%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/my_notes/notes/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6/%E5%A5%BD%E5%A5%BD%E8%B0%88%E6%81%8B%E7%88%B1%E8%AE%A9%E4%BB%96%E7%88%B1%E4%B8%8A%E4%BD%A0%E7%9A%8415%E4%B8%AA%E7%A7%98%E8%AF%80/</guid><description>好好谈恋爱：让他爱上你的15个秘诀 #读书笔记 #心理 #心理学应用
元数据 [!abstract] 好好谈恋爱：让他爱上你的15个秘诀
书名： 好好谈恋爱：让他爱上你的15个秘诀 作者： 文森 简介： 【编辑推荐】 ★精通五国语言的情感专家为你解决情感困惑 ★作者全球粉丝量超过80万人，视频全平台播放量超过1亿次，帮助数万名女性成功解决情感困惑。 ★一本书帮你实现幸福爱情 ★书中包含150多条心理学依据、11个独创情感理论和15节恋爱必修课 【内容简介】 如果你不懂如何驾驶却要开车，安全到达目的地会很困难；同样，如果不懂如何好好谈恋爱，拥有幸福的爱情将会成为很难实现的梦想。“谈恋爱”并不是人们生来就会的本事，就像骑自行车、说一门外语或是弹钢琴，都少不了后天的学习与练习。问题是，没有人教我们“谈恋爱”这门人生必修课。 如何才能吸引你喜欢的人，让他对你动心？如何让他为你认真付出感情？如何避免被玩弄感情，提前判断出一个人是否真正适合你？如何让一段感情经久不衰？ 文森老师作为国际知名情感专家，以风趣幽默的语言、生动形象的比喻和引人入胜的案例为你提供这些问题的答案以及让女性头疼的情感困惑的解答方案。在书中，作者精心提出了诸如“长期吸引力公式”“爱情博弈论”“择偶金字塔”“达·芬奇偏见”等等15个恋爱秘诀，帮助你快速成长为高价值女神，从而收获理想的爱情。 【作者简介】 文森是西班牙情感专家，西班牙两性心理协会认证导师。他多年来深入钻研两性关系、心理学、认知行为治疗（CBT）等课题。文森老师的恋爱课程学员遍布世界五大洲，全球粉丝量超过八十万人，视频全平台播放量超过一亿次。他教授的课程已成功帮助数万名女性解决了情感问题，获得幸福爱情，也教授了若干畅销情感课程，如《聊天女王》及《男人的真相》等。 出版时间 2022-08-01 00:00:00 ISBN： 9787521627275 分类： 心理-心理学应用 出版社： 中国法制出版社有限公司 PC地址：https://weread.qq.com/web/reader/198328e0813ab74d3g010fb9 高亮划线 PART 1 ATTRACTION SECRETS 吸引力的秘密 📌 “柯立芝效应”(Coolidge Effect)这一概念，￼用来形容雄性动物对于新出现的异性有较高的交配意愿，反而会对周遭已有过交配经验的异性进入“性不应期”，在这段时间内会短暂地失去与之交配的兴趣。￼
⏱ 2024-01-01 09:35:23 ^3300036670-5-7130-7757
📌 女人会采用狙击枪策略。
⏱ 2024-01-01 09:38:43 ^3300036670-5-9909-10114
📌 男人的性策略就是机关枪策略
⏱ 2024-01-01 09:38:51 ^3300036670-5-10227-10240
📌 男女之间性策略的不同，也致使在两性关系中，男人往往扮演追求者、女人往往扮演筛选者的角色。男人像机关枪一样“开火”，尽可能多地追求不同的女生，直到“打中”一个。女人则像狙击手，在一堆追求者中瞄准好再“开火”，筛选出最佳人选。
⏱ 2024-01-01 09:39:22 ^3300036670-5-10614-10725
第二章 爱情是一件公平的事 为了得到你想要的爱情，你得配得上它 Deserve The Relationship You Want 📌 为了得到你想要的，你得先配得上它。 这个世界还没有疯狂到去奖励一群不值得的人。</description></item><item><title/><link>https://ormissia.github.io/notes/my_notes/notes/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6/%E6%80%BB%E4%BC%9A%E8%BF%87%E5%8E%BB-%E6%80%BB%E4%BC%9A%E5%88%B0%E6%9D%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/my_notes/notes/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6/%E6%80%BB%E4%BC%9A%E8%BF%87%E5%8E%BB-%E6%80%BB%E4%BC%9A%E5%88%B0%E6%9D%A5/</guid><description>总会过去 总会到来 #读书笔记 #个人成长 #励志成长
元数据 [!abstract] 总会过去 总会到来
书名： 总会过去 总会到来 作者： 王潇 简介： 继《趁早》《按自己的意愿过一生》后，励志偶像“潇洒姐”第三部人生成长故事书，这一次，她真诚袒露自己创业路上的至暗时刻，育儿、婚姻中的摸索和体悟，剖析自己如何被“别人的声音”和“自己的欲念”绑架，又如何重新梳理自己的思路，坚定地摈弃那些“连自己都不相信”的事，在喧嚣中安静地杀出一条“血路”的。她用亲身经历告诉我们一定找到并坚定信念，相信相信的力量。 出版时间 2022-09-01 00:00:00 ISBN： 9787533969530 分类： 个人成长-励志成长 出版社： 浙江文艺出版社 PC地址：https://weread.qq.com/web/reader/89f32de0813ab7297g01839c 高亮划线 第一章 盛夏的伏笔 📌 不存在完全正确的选择。 选了什么，接下来就要把它变成正确的选择。
⏱ 2024-01-10 09:38:16 ^3300030958-4-462-551
风华绝代 📌 热爱不是用来思辨的，热爱在思辨到来前，早就产生了。
⏱ 2024-01-10 09:40:03 ^3300030958-7-431-456
📌 好工作和好的恋爱一样，足够迷恋其中优美灿烂的部分，才能忍受其他时刻的煎熬，因为这两面总会相伴而生。但如果无法在心中为之尖叫和燃烧，付出就失去了根基。后来我明白，在很多时尚爱好者梦寐以求的场合，我也没有能享受当下，我总是在解决问题。
⏱ 2024-01-10 09:38:57 ^3300030958-7-570-685
📌 真正的生活方式是当你脱掉演出服，完全由自己来支配思想、时间、身体和金钱的时候，你到底会怎样生活。
⏱ 2024-01-10 09:39:39 ^3300030958-7-3869-3917
📌 我虽然远远达不到热爱的程度，但在群星闪耀时，我感激过这份工作，它让我在某几个瞬间见识到那种全情奔赴的激动。
⏱ 2024-01-10 09:40:50 ^3300030958-7-4746-4799
都是运动员 📌 我发现这些瞬间之中，只有很小一部分是夺冠和冲线的高光时刻，里面更多的是在记录惊慌、困惑、悲伤和恐惧，还有那些在折磨和质疑中的呼吸和哭泣，在现场被放大了数倍，真实得令人心碎。
⏱ 2024-01-10 09:41:15 ^3300030958-8-3711-3797
📌 原来真正厉害的人，装备都隐退了，手中已无剑，本身就是剑锋。</description></item><item><title/><link>https://ormissia.github.io/notes/my_notes/notes/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6/%E6%91%84%E5%BD%B1%E4%B8%8E%E5%BF%83%E7%90%86%E5%AD%A6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/my_notes/notes/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6/%E6%91%84%E5%BD%B1%E4%B8%8E%E5%BF%83%E7%90%86%E5%AD%A6/</guid><description>摄影与心理学 #读书笔记 #艺术 #摄影
元数据 [!abstract] 摄影与心理学
书名： 摄影与心理学 作者： 陈磊编著 简介： 对于摄影初学者最大的烦恼莫过于，看到美丽的景物，可是拍下来的照片却与自己想象的结果大相径庭。本书从视觉心理学的角度去分析摄影者进行创作的过程。本书共分为4章，第一章探讨了格式塔与摄影三原则，即照片表现的主题，怎样把注意力吸引到主体上，如何使画面简洁，第二章探讨了格式塔的视觉原理即闭合性、连续性、相似性、接近性以及共同命运性等，了解这一点对于构图非常有帮助。第三章讨论了讨对主体形象的把握，它对拍摄效果的影响更为实际有效。第四章则研究了摄影对于色彩的要求，什么是真实的色彩，哪些是我们需要的色彩。本书探讨了心理学对于摄影的影响，了解了我们头脑中映射的图像和现实图像之间的差距，我们如何去从现实中提炼出我们头脑中的理想影像，这对于摄影创作大有裨益。本书适合摄影爱好者和职业摄影师学习参考。 出版时间 2021-03-01 00:00:00 ISBN： 9787115530530 分类： 艺术-摄影 出版社： 人民邮电出版社 PC地址：https://weread.qq.com/web/reader/00f32bb072323bc100faac6 高亮划线 1.2 大脑中的“美图秀秀” 📌 眼中看到的和大脑中显现的图像是不一样的。人的眼睛观察到的是全面的景物，而大脑只呈现特定的、美化了的部分形象。
⏱ 2024-01-08 19:13:59 ^36846529-8-1778-1832
1.4 人脑黑箱 📌 自然界本不存在形象/背景关系，而是由大脑的选择组织起了这种关系。
⏱ 2024-01-08 19:23:52 ^36846529-10-7431-7463
1.6 主体突出——让主体与背景分离 📌 有经验的摄影师要有意识地运用构图的艺术手段——让主体与背景区分出来，并突出主体，弱化背景。
⏱ 2024-01-10 09:22:48 ^36846529-12-610-655
📌 在摄影技术上，让主体与背景分离，手段有很多。常用的有以下几种：
对准主体对焦，让主体更清晰； 使用大光圈虚化背景； 让主体在更重要的位置； 利用明暗对比，比如主体明亮，背景阴暗； 利用色彩对比，让主体与背景颜色有所区别； 还可以使用摄影后期手段，来区分主体与背景。 ⏱ 2024-01-10 09:23:07 ^36846529-12-657-879
📌 科学的脚步太快，抛下了感情和心灵。
⏱ 2024-01-10 09:24:02 ^36846529-12-4185-4202
2.1 再探格式塔 📌 如果画面中的局部凌乱无关联，则会使整体含义丧失。</description></item><item><title/><link>https://ormissia.github.io/notes/my_notes/notes/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6/%E6%91%84%E5%BD%B1%E5%85%A5%E9%97%A8%E6%95%99%E4%BD%A0%E8%BD%BB%E6%9D%BE%E6%8B%8D%E5%A4%A7%E7%89%87/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/my_notes/notes/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6/%E6%91%84%E5%BD%B1%E5%85%A5%E9%97%A8%E6%95%99%E4%BD%A0%E8%BD%BB%E6%9D%BE%E6%8B%8D%E5%A4%A7%E7%89%87/</guid><description>摄影入门：教你轻松拍大片 #读书笔记 #艺术 #摄影
元数据 [!abstract] 摄影入门：教你轻松拍大片
书名： 摄影入门：教你轻松拍大片 作者： 张晨曦 简介： 本书是一部面向大众的摄影教程，从摄影的基本概念出发，系统、全面地讲述了摄影的基础知识和技艺，包括购置和使用相机、曝光控制、动感的表现、景深控制、摄影构图、摄影用光、色彩、影调、质感、手机摄影、相机与镜头、辅助器材、风光摄影、花卉摄影、人像摄影等，对近几年流行的新技术和新方法进行了论述，如景深合成、曝光合成、向右曝光、堆栈技术、星野摄影等。本书知识架构层次清晰，逐层展开，讲解简练、细致、到位，插图精美，图文并茂，全书重点和关键词都用彩字突显，一目了然。 本书可作为初级入门摄影爱好者的自学参考书，也可作为高等院校摄影课以及各种摄影培训的教材。 出版时间 2018-03-01 00:00:00 ISBN： 9787302489092 分类： 艺术-摄影 出版社： 清华大学出版社 PC地址：https://weread.qq.com/web/reader/ba8325b07161e59bba81d1d 高亮划线 第9章 色彩、影调、质感 📌 色彩的三要素如下： （1）色别（色相）。指出具体是哪种颜色。 （2）明度。色彩的明暗、深浅程度。 （3）饱和度（纯度）。颜色的纯度和鲜艳程度。 它们是鉴别和评价色彩的主要依据。
⏱ 2024-01-06 08:40:22 ^23192987-70-1411-1711
读书笔记 本书评论</description></item><item><title/><link>https://ormissia.github.io/notes/my_notes/notes/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6/%E6%98%9F%E6%9C%9F%E5%85%AD%E6%99%9A%E6%88%91%E4%BB%AC%E5%8E%BB%E6%95%A3%E6%AD%A5%E5%90%A7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/my_notes/notes/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6/%E6%98%9F%E6%9C%9F%E5%85%AD%E6%99%9A%E6%88%91%E4%BB%AC%E5%8E%BB%E6%95%A3%E6%AD%A5%E5%90%A7/</guid><description>星期六晚我们去散步吧 #读书笔记 #文学 #现代诗歌
元数据 [!abstract] 星期六晚我们去散步吧
书名： 星期六晚我们去散步吧 作者： 隔花人 简介： 世间万物都有它自己的生命和生存的意义，花有花的语言，风有风的方向，种子有种子的选择，每个与你相遇的人都有他出现的理由。作者以童真的视角，将大多数人忽略的美好一一落笔成诗。 ·这本诗集很轻，三言两语自成宇宙， 这本诗集很重，千山万水装满心事。 每个人都是诗人，每个诗人都是孩子。 ·全书共收录作者136首诗集，作者以童真的视角，直接、清晰、简单、灵动的写下当下年轻人的内心问题、人生困惑以及生活中那些被大多数人忽略的美好。配以简单、黑白且有寓意的漫画，引起当下年轻人的喜欢和思考。 出版时间 2023-03-01 00:00:00 ISBN： 9787221176165 分类： 文学-现代诗歌 出版社： 贵州人民出版社 PC地址：https://weread.qq.com/web/reader/d59326c0813ab7bbdg017221 高亮划线 自我 📌 自我 灯在墙上的投影 也是一盏灯 如果它不打开自己 便看不清自己 ￼
⏱ 2024-01-04 19:12:07 ^3300054377-153-339-685
无聊的大多数 📌 无聊的大多数 重复的日子 是在日历上签到 每一天都力透纸背 每一天都在等待报废
⏱ 2024-01-04 18:38:56 ^3300054377-160-339-495
温水 📌 温水 嚼了很久口香糖 才发现没味道 日子过得没滋没味 也是过了很久才发现的 ￼
⏱ 2024-01-04 19:12:51 ^3300054377-161-339-690
路灯 📌 路灯 它弯着腰 想要抚摸我的头 我一言不发 用光洗了个澡 ￼</description></item><item><title/><link>https://ormissia.github.io/notes/my_notes/notes/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6/%E7%93%A6%E5%B0%94%E7%99%BB%E6%B9%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/my_notes/notes/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6/%E7%93%A6%E5%B0%94%E7%99%BB%E6%B9%96/</guid><description>瓦尔登湖 #读书笔记 #文学 #散文杂著
元数据 [!abstract] 瓦尔登湖
书名： 瓦尔登湖 作者： 亨利·戴维·梭罗 简介： 《瓦尔登湖》是美国作家梭罗独居瓦尔登湖畔的记录，描绘了他两年多时间里的所见、所闻和所思。 1845年3月，梭罗来到瓦尔登湖，动手搭建一座十英尺宽、十五英尺长的小木屋；7月4日，也就是美国的独立纪念日，终于如愿以偿地开始了那段在后世成为传奇的独居生活。两年后，他带着在湖边生活时完成的书稿，永远地离开了那座亲手所建的木屋。之后七年间七易其稿，直到1854年8月9日才正式出版。 出版时间 2013-07-01 00:00:00 ISBN： 9787201082134 分类： 文学-散文杂著 出版社： 天津人民出版社 PC地址：https://weread.qq.com/web/reader/0af32e00813ab77f7g0103c3 高亮划线 生计 📌 人只有想起自己的无知才能有长进，但他如此忙于使用已有的知识，又如何能想得起来呢？
⏱ 2024-01-08 18:46:57 ^3300044710-4-5187-5227
📌 人性最美好的品质就像水果表皮的白霜，只有通过最谨慎的处理才能得到保留。然而我们无论对待自己，还是对待他人，都不曾如此温柔。
⏱ 2024-01-08 18:47:42 ^3300044710-4-5265-5326
📌 大多数人生活在无言的绝望中。所谓的委曲求全其实是积重难返的绝望。你们从绝望的城市走进绝望的乡村，只能以水貂皮和麝鼠皮做成的华贵服装来自我安慰。就连各种所谓的游戏和娱乐，也隐藏着一种反复出现然而谁也没有察觉的绝望。这些游戏和娱乐并不愉快，因为它们是在工作之后才出现的。但智慧的特征之一就是不去做绝望的事。
⏱ 2024-01-08 18:52:26 ^3300044710-4-7317-7468
📌 没有哪种思考或做事的方式，无论它是多么的古老，值得我们盲目地去跟从。
⏱ 2024-01-08 18:54:36 ^3300044710-4-7772-7806
📌 身处文明社会的我们其实应该到蛮荒的边疆去生活，才能更好地了解什么是生活的必需品，
⏱ 2024-01-08 18:57:13 ^3300044710-4-11548-11588
读书笔记 本书评论</description></item><item><title/><link>https://ormissia.github.io/notes/my_notes/notes/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6/%E8%89%B2%E5%BD%A9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/my_notes/notes/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6/%E8%89%B2%E5%BD%A9/</guid><description>色彩 #读书笔记 #艺术 #绘画
元数据 [!abstract] 色彩
书名： 色彩 作者： 王海燕 杜建伟 简介： 《色彩》教材侧重于写生色彩，从色彩基础理论到色彩写生的观察方法和具体的表现技法全面展开。本书共分为6章：第1章主要介绍色彩基础理论，包括色彩的产生、绘画色彩的分类、绘画色彩基础、色彩的心理与联想；第2章介绍色彩的对比与和谐；第3章介绍色彩写生的表现方式，色彩的透视规律，色彩写生构图，色彩写生的观察与表现，写生色彩变化的一般规律以及色彩的临摹与默写；第4章介绍色彩静物写生的具体方法；第5章介绍色彩风景写生，包括色彩风景速写，色彩风景写生步骤，天空、山水、建筑等的画法，并针对学生容易出现的问题如色彩调配、写生中常见的问题等方面一一列举了解决的方法；第6章是优秀作品欣赏，包括国外大师的色彩风景、静物写生，还有国内当代有代表性画家的色彩写生作品，以供读者开阔眼界并作为临摹的范本。《色彩》面向美术学和设计专业的大学本科生学习而编写，适合本科、高职高专等院校美术相关专业的学生学习参考，也适合热爱色彩写生的美术爱好者进行自学参考。 出版时间 2018-09-01 00:00:00 ISBN： 9787122321909 分类： 艺术-绘画 出版社： 化学工业出版社 PC地址：https://weread.qq.com/web/reader/1a932420718998231a9fbf9 高亮划线 第1章 色彩基础理论 📌 有彩色系是由光的波长和振幅决定的，波长决定色相，振幅决定色调。有彩色系的颜色都具有三个基本特征：色相、纯度、明度。
⏱ 2024-01-10 12:09:11 ^25794595-5-1379-1436
📌 色彩的明度可用黑白度来表示，越接近白色，明度越高；越接近黑色，明度越低。黑与白作为颜料，可以调节物体色的反射率，使物体色提高明度或降低明度。
⏱ 2024-01-10 12:10:29 ^25794595-5-1955-2025
📌 无彩色系的颜色只有一种基本性质——明度。
⏱ 2024-01-10 21:57:06 ^25794595-5-2054-2074
📌 从表现方式上，色彩主要分为写生色彩、装饰色彩、主观色彩、意象色彩4大类型
⏱ 2024-01-10 21:57:21 ^25794595-5-2131-2167
读书笔记 本书评论</description></item><item><title/><link>https://ormissia.github.io/notes/my_notes/notes/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6/%E9%9C%8D%E4%B9%B1%E6%97%B6%E6%9C%9F%E7%9A%84%E7%88%B1%E6%83%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/my_notes/notes/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6/%E9%9C%8D%E4%B9%B1%E6%97%B6%E6%9C%9F%E7%9A%84%E7%88%B1%E6%83%85/</guid><description>霍乱时期的爱情 #读书笔记 #文学 #外国文学
元数据 [!abstract] 霍乱时期的爱情
书名： 霍乱时期的爱情 作者： [哥]加西亚•马尔克斯 简介： 多年以后，当胡维纳尔乌尔比诺医生翻看霍乱时期的记录，发现父亲所采用的方法，仁爱多于科学。他的勤奋，他的牺牲精神，尤其是他个人的胆识，这一切都让他无愧于这座城市从灾难中死而复生后给予他的那些荣耀，他的名字理所应当和那些不计其数的战争英雄列在一起，因为比起这场战斗，那些战争可能要不光彩得多。《霍乱时期的爱情》，一本讲述战争、时疫、分别与重逢的暖心杰作，献给此时此刻的我们。 出版时间 2020-03-01 00:00:00 ISBN： 9787544297059 分类： 文学-外国文学 出版社： 南海出版公司 PC地址：https://weread.qq.com/web/reader/99632b00719376c6996d2d2 高亮划线 4 📌 她辩解说，爱情，首先是一种本能，“要么生下来就会，要么永远都不会”。
⏱ 2024-01-10 18:23:09 ^26441414-17-29324-29358
📌 两个几乎完全互不了解的人，没有任何血缘关系，性格不同，文化不同，甚至性别都不相同，却突然间不得不承诺生活在一起，睡在同一张床上，分享彼此也许注定有所分歧的命运，这一切本身就是完全违背科学的。
⏱ 2024-01-10 18:24:02 ^26441414-17-38541-38636
📌 婚姻的问题在于，它终结于每晚做爱之后，却在第二天早餐之前又必须重新建立起来。
⏱ 2024-01-10 18:23:45 ^26441414-17-38640-38678
📌 有时，他们从疯狂的节日庆典回到家，在门后伺机而动的怀旧之情也会一下子将他们扑倒在地，于是就会有一次美妙的爆发，一切又回到往昔，五分钟后，他们就又像蜜月中连门襟都无暇扣上的恋人们一样了。
⏱ 2024-01-10 18:24:32 ^26441414-17-39088-39180
📌 她用一种更为简单的方式为它下了定义：“社交生活的关键在于学会控制恐惧，夫妻生活的关键在于学会控制厌恶。”
⏱ 2024-01-10 18:25:25 ^26441414-17-40339-40391
5 📌 可以不忠，但不可背信弃义
⏱ 2024-01-10 18:26:55 ^26441414-18-38624-38636
6 📌 一个世纪前，人们毁掉了我和这个可怜男人的生活，因为我们太年轻；现在，他们又想在我们身上故伎重施，因为我们太老了。
⏱ 2024-01-10 18:27:29 ^26441414-19-39220-39276
读书笔记 本书评论</description></item><item><title/><link>https://ormissia.github.io/notes/my_notes/notes/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6/%E9%A6%99%E6%B0%B4%E5%90%8C%E5%90%8D%E7%94%B5%E5%BD%B1%E5%8E%9F%E8%91%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/my_notes/notes/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6/%E9%A6%99%E6%B0%B4%E5%90%8C%E5%90%8D%E7%94%B5%E5%BD%B1%E5%8E%9F%E8%91%97/</guid><description>香水（同名电影原著） #读书笔记 #文学 #外国文学
元数据 [!abstract] 香水（同名电影原著）
书名： 香水（同名电影原著） 作者： 帕·聚斯金德 简介： 豆瓣8.5分高分电影《香水》原著。格雷诺耶出生在巴黎最臭的鱼市上。他天生没有体味，而嗅觉却异常灵敏。长大后他成了巴黎一香水大师的学徒，从而也渐渐产生了用香水征服世界的野心。一天，他发现一少女的气味令人着迷，无意中杀死了该少女，并嗅光了她的体香。之后，他先后杀死了26个少女，萃取了她们的体昧，并蒸馏出神奇的香水。当他的罪行败露，被押赴刑场时，他释放了一瓶奇特的香水…… 出版时间 2016-10-01 00:00:00 ISBN： 9787532745449 分类： 文学-外国文学 出版社： 上海译文出版社 PC地址：https://weread.qq.com/web/reader/4e5324a0716b071b4e588ff 高亮划线 11 📌 人的不幸来源于他不肯安分守己地呆在自己应呆的房间里。
⏱ 2024-01-10 09:48:29 ^23791387-69-4007-4033
📌 目光所及，到处都是一派狂热病似的忙碌景象。男男女女都在读书。教士们蹲在咖啡馆里。若是警察进行干预，抓了这些高级坏蛋中的一个并把他投入监狱，那么出版商们就大声疾呼，递上申请书，上流社会的先生们和女士们就施加他们的影响，直至警察在几周之后又把这个高级坏蛋释放，或是把他流放到外国，而他在那儿又可以不受阻碍地撰写论战性的小册子。
⏱ 2024-01-10 09:48:48 ^23791387-69-4538-4699
📌 购买桥上的房子是个错误，而购买坐落在桥西侧的房子，更是个双重的错误。如今他经常望着奔流而去的河水。他觉得，他自己、他的房子以及他在几十年中赚得的财产，仿佛像河水一样流去。
⏱ 2024-01-10 09:49:10 ^23791387-69-5707-5792
读书笔记 本书评论</description></item><item><title/><link>https://ormissia.github.io/notes/my_notes/notes/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%AC4%E7%89%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/my_notes/notes/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%AC4%E7%89%88/</guid><description>高性能MySQL（第4版） #读书笔记 #计算机 #数据库
元数据 [!abstract] 高性能MySQL（第4版）
书名： 高性能MySQL（第4版） 作者： Silvia Botros Jeremy Tinley 简介： 《高性能 MySQL》一直是 MySQL 领域的经典之作，影响了一代又一代的 DBA 和技术人员，从第3 版出版到第 4 版出版过去了近十年，MySQL 也从 5.5 版本更新到了 8.0 版本。第 4 版中增加了大量对 MySQL 5.7 和 8.0 版本新特性的介绍，删除了一些在新版本中已经废弃或者不再常用的功能，还增加了对云数据库的介绍，减少了在官方文档中已有的基础使用和配置相关的内容。这些年，MySQL 经过在大量大规模互联网场景中的应用验证，使得本书在继续关注高性能之外，还用了较多的篇幅来介绍如何实现 MySQL 的大规模可扩展应用和合规性问题，这是相比第 3 版最大的不同，也是本书封面上所写的“经过大规模运维验证的策略”的体现。本书适合数据库管理员（DBA）阅读，也适合系统运维和开发人员参考学习。不管你是数据库新手还是专家，相信都能从本书中有所收获。 出版时间 2022-09-01 00:00:00 ISBN： 9787121442575 分类： 计算机-数据库 出版社： 电子工业出版社 PC地址：https://weread.qq.com/web/reader/00a32b70813ab746fg018ec7 高亮划线 第6章 schema设计与管理 📌 DATETIME和TIMESAMP列可以存储相同类型的数据：时间和日期，精确到秒。然而TIMESTAMP只使用DATETIME一半的存储空间，还会根据时区变化，而且具有特殊的自动更新能力。另一方面，TIMESTAMP允许的时间范围要小得多，有时候它的特殊能力会成为障碍。
⏱ 2024-01-02 14:32:36 ^3300035678-16-2521-2656
📌 MySQL可以为整数类型指定宽度，例如，INT(11)，这对大多数应用毫无意义：它不会限制值的合法范围，只是规定了MySQL的一些交互工具（例如，MySQL命令行客户端）用来显示字符的个数。对于存储和计算来说，INT(1)和INT(20)是相同的。
⏱ 2024-01-02 14:36:30 ^3300035678-16-3741-3865
📌 在一些大容量的场景，可以考虑使用BIGINT代替DECIMAL，将需要存储的货币单位根据小数的位数乘以相应的倍数即可。假设要存储财务数据并精确到万分之一分，则可以把所有金额乘以一百万，然后将结果存储在BIGINT里，这样可以同时避免浮点存储计算不精确和DECIMAL精确计算代价高的问题。
⏱ 2024-01-02 14:39:40 ^3300035678-16-4511-4655</description></item><item><title/><link>https://ormissia.github.io/notes/my_notes/notes/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/my_notes/notes/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/</guid><description>杂七杂八 #读书笔记
经学家看见《易》，道学家看见淫，才子看见缠绵，高官家看见排满，流言家看见宫闱秘事 见天地，见众生，见自己 别嫌弃教你妈妈用手机，她曾经教你用筷子 你终会明白，前途比爱情重要，你还会明白，爱情比前途更难得，但最后你会明白，对的人会站在你的前途里 想要瓦解一个民族，只要抽掉男人的脊梁和血性，拿走女人的廉耻和善良，社会风气坏了，几代人也难以修复 如果个体的困顿和集体无关，那集体的荣辱又与个体有什么关系呢 智者不入爱河，建设美丽祖国 正应了那句古话，人死王八活。摇身一变，成正经人了。池边一蹲充了龙王，抹点锅底灰楞充灶王爷，乍一看还真看不出个子午寅卯来。可盐从哪咸醋打哪酸，脸一抹拉这日子就想重新过了，是两撇的都明白，那不可能 虽然说强扭的瓜不甜，但有的时候我并不在乎它甜不甜。我只想把它扭下来，扭下来我就高兴了 所谓有趣的灵魂，实际上就是这个人的信息密度和知识层面，都远高于你。并愿俯下身去听你说那毫无营养的废话和你交流，提出一些你没有听过的观点，颠覆了你短浅的想象力及三观 此去经年，应是良辰好景虚设。便纵有千种风情，更与何人说 没事，只不过一切恢复原状罢了，我本来就是一无所有的 在人海里相遇的人，终究要还给人海 我感到难过不是因为你欺骗了我，而是因为我再也不能相信你了 我以为爱情可以填满人生的遗憾，然而制造更多遗憾的却偏偏是爱情 太阳不是突然下山的，而所有的离开都是蓄谋已久 世上存在着不能流泪的悲伤，这种悲伤无法向人解释，即使解释人家也不会理解，它永远一成不变，如无风夜晚的雪花，静静沉在心底 我注意过，即使是那些声称&amp;quot;一切都是命中注定的，而我们无力改变&amp;quot;的人，在过马路时都会左右看 乞丐不会嫉妒百万富翁，但是他肯定会嫉妒收入更高的乞丐 情不知所起，一往而深 欲买桂花同载酒，终不似，少年游 聊美国不聊福利高科技，聊越南不聊人权收入低。聊日本着重聊军国主义，聊国际就谈巴铁好兄弟。北欧各国挨冻缺天然气，美国遍地是罪犯和枪击。日韩西瓜和牛肉吃不起，加拿大明显美国的小弟。若要拿出事实讲些道理，定是阁下生活不太如意 新的资产阶级发展壮大了起来，底层还在幻想他们自己消灭自己 人的欲望，就如同高山滚石一般，一旦开始，就再也停不下来了 小时候家的北边有一个铁匠叫苏大哥，虽然有一些矛盾，但有忙也会帮，看到苏大哥在修自行车，我就笑了，苏大哥也笑着说，笑什么笑，将来你比我还能修 看到苏大哥修自行车，我笑了，苏大哥说: 你笑牛魔酬宾，你爸给你留的自行车比我的还容易坏，你将来修得更狠 君子生非异也，善假于物也 尊重历史发展规律，客观事实不会改变，自然环境恶劣动物就会停止繁殖 西晋在永嘉之乱中，整个社会上弥漫着废晋弃晋的气氛，有人想自立山头，有人想南下避难，有人依附胡人，唯独没有一个人想拯救大晋 因为害怕失望，索性就不再抱有期望 每次坦诚去对待别人后不出意外又被上了一课 并不是所有人都拥有自救的能力，长年累月形成的自卑，敏感，焦虑，不是说顿悟一下就能自信起来的，这需要一个极其漫长的过程并且不能中断，一但中断那种感觉就像是被人拉了一把后又眼睁睁看着自己摔下去 曾经有一段低谷期，我每天至少读一小时，有时一天三到四小时。我一直相信阅读会让我的生活变得更好，让我越来越强大。然而后来我发现，我似乎读书是为了逃避社交和生活，所以我通过阅读麻痹自己，生活依旧没有越变越好，问题仍然存在 人和人刚分开的时候，其实是没有痛感的，那时候更多的是错愕，那份痛苦会随着时间的推移，在每个回忆袭来的瞬间跑出来吞噬你，完完全全地吞噬，一条街道、一首歌、一种气味，都足以成为凌迟你的凶器</description></item><item><title/><link>https://ormissia.github.io/notes/my_notes/notes/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%81%AB%E7%9A%84%E7%B2%BE%E7%A5%9E%E5%88%86%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/my_notes/notes/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%81%AB%E7%9A%84%E7%B2%BE%E7%A5%9E%E5%88%86%E6%9E%90/</guid><description>火的精神分析 #读书笔记
当我们谈论某客体，我们就会以为自己是客观的。但是，在我我们最初的选择中，与其说我们指定客体，不如说客体指定着我们，并且我们相信：我们对于世界的基本思想往往是一些有关我们的精神青春的机密。（P 44）</description></item><item><title/><link>https://ormissia.github.io/notes/my_notes/notes/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%9C%A9%E6%99%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/my_notes/notes/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%9C%A9%E6%99%95/</guid><description>眩晕 #读书笔记
在这样的冲动过后，一股模糊的焦虑感开始涌上心头，我感到一阵恶心和眩晕。我尝试捕捉的画面失去了轮廓，我的思想在我还未能确切地把握之前就瓦解了。当我不得不依靠着墙壁甚至躲到门道里，虽然有时担心会陷入瘫痪或脑疾发作，我却想不出任何其他抵御的方法，除了一直行走到深夜，直到筋疲力尽为止。（P 30）</description></item><item><title/><link>https://ormissia.github.io/notes/my_notes/notes/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%BE%BD%E8%9B%87/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ormissia.github.io/notes/my_notes/notes/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%BE%BD%E8%9B%87/</guid><description>羽蛇 #读书笔记
人必须重生。斩断生活的毒须，驱走堕落的巨蛇，那曾被毁坏的脆弱的生活必须获得新的存在（P 48） &amp;hellip; 在精美而发着音乐声的寂静里，独自面对自己展开的灵魂（P 48）</description></item></channel></rss>