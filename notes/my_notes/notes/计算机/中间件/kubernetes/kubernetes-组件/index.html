<!doctype html><html lang=zh-cn><head><title></title>
<meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="ie=edge"><link rel=stylesheet href=/application.87ecd420aa4299c8e4b21123c5360ef38ce9d1370c88559d014914f4a65e6b89.css integrity="sha256-h+zUIKpCmcjkshEjxTYO84zp0TcMiFWdAUkU9KZea4k="><link rel=icon type=image/png href=/images/favicon_hu8376fd15465fef26ffe66b6bcf0ca686_13669_42x0_resize_box_3.png><meta property="og:title" content><meta property="og:description" content="Kubernetes 组件 #k8s #kubernetes #容器 #云 #go #golang
控制平面组件（Control Plane Components） 控制平面组件会为集群做出全局决策，比如资源的调度。 以及检测和响应集群事件，例如当不满足部署的 replicas 字段时， 要启动新的 pod）。
控制平面组件可以在集群中的任何节点上运行。 然而，为了简单起见，设置脚本通常会在同一个计算机上启动所有控制平面组件， 并且不会在此计算机上运行用户容器。 请参阅使用 kubeadm 构建高可用性集群 中关于跨多机器控制平面设置的示例。
kube-apiserver API 服务器是 Kubernetes 控制平面的组件， 该组件负责公开了 Kubernetes API，负责处理接受请求的工作。 API 服务器是 Kubernetes 控制平面的前端。
Kubernetes API 服务器的主要实现是 kube-apiserver。 kube-apiserver 设计上考虑了水平扩缩，也就是说，它可通过部署多个实例来进行扩缩。 你可以运行 kube-apiserver 的多个实例，并在这些实例之间平衡流量。
etcd 一致且高可用的键值存储，用作 Kubernetes 所有集群数据的后台数据库。
如果你的 Kubernetes 集群使用 etcd 作为其后台数据库， 请确保你针对这些数据有一份 备份计划。
你可以在官方文档中找到有关 etcd 的深入知识。
kube-scheduler kube-scheduler 是控制平面的组件， 负责监视新创建的、未指定运行节点（node）的 Pods， 并选择节点来让 Pod 在上面运行。
调度决策考虑的因素包括单个 Pod 及 Pods 集合的资源需求、软硬件及策略约束、 亲和性及反亲和性规范、数据位置、工作负载间的干扰及最后时限。"><meta property="og:type" content="article"><meta property="og:url" content="https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E4%B8%AD%E9%97%B4%E4%BB%B6/kubernetes/kubernetes-%E7%BB%84%E4%BB%B6/"><meta property="article:section" content="notes"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="Kubernetes 组件 #k8s #kubernetes #容器 #云 #go #golang
控制平面组件（Control Plane Components） 控制平面组件会为集群做出全局决策，比如资源的调度。 以及检测和响应集群事件，例如当不满足部署的 replicas 字段时， 要启动新的 pod）。
控制平面组件可以在集群中的任何节点上运行。 然而，为了简单起见，设置脚本通常会在同一个计算机上启动所有控制平面组件， 并且不会在此计算机上运行用户容器。 请参阅使用 kubeadm 构建高可用性集群 中关于跨多机器控制平面设置的示例。
kube-apiserver API 服务器是 Kubernetes 控制平面的组件， 该组件负责公开了 Kubernetes API，负责处理接受请求的工作。 API 服务器是 Kubernetes 控制平面的前端。
Kubernetes API 服务器的主要实现是 kube-apiserver。 kube-apiserver 设计上考虑了水平扩缩，也就是说，它可通过部署多个实例来进行扩缩。 你可以运行 kube-apiserver 的多个实例，并在这些实例之间平衡流量。
etcd 一致且高可用的键值存储，用作 Kubernetes 所有集群数据的后台数据库。
如果你的 Kubernetes 集群使用 etcd 作为其后台数据库， 请确保你针对这些数据有一份 备份计划。
你可以在官方文档中找到有关 etcd 的深入知识。
kube-scheduler kube-scheduler 是控制平面的组件， 负责监视新创建的、未指定运行节点（node）的 Pods， 并选择节点来让 Pod 在上面运行。
调度决策考虑的因素包括单个 Pod 及 Pods 集合的资源需求、软硬件及策略约束、 亲和性及反亲和性规范、数据位置、工作负载间的干扰及最后时限。"><script>theme=localStorage.getItem("darkmode:color-scheme")||"system",theme=="system"&&(window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?theme="dark":theme="light"),document.documentElement.setAttribute("data-theme",theme)</script></head><body class="type-notes kind-page" data-spy=scroll data-target=#TableOfContents data-offset=80><div class="container-fluid bg-secondary wrapper"><nav class="navbar navbar-expand-xl top-navbar shadow" id=top-navbar><div class=container><button class="navbar-toggler navbar-light" id=sidebar-toggler type=button>
<i data-feather=sidebar></i>
</button>
<a class=navbar-brand href=/><img src=/images/ormissia_hu763a76473558eea2a316ef50b45aaecf_966068_42x0_resize_box_3.png id=logo alt=Logo>
Ormissia's Blog</a>
<button class="navbar-toggler navbar-light" id=navbar-toggler type=button data-toggle=collapse data-target=#top-nav-items aria-label=menu>
<i data-feather=menu></i></button><div class="collapse navbar-collapse dynamic-navbar" id=top-nav-items><ul class="nav navbar-nav ml-auto"><li class=nav-item><a class=nav-link href=/#home>主页</a></li><li class=nav-item><a class=nav-link href=/#about>技能</a></li><li class=nav-item><a class=nav-link href=/#recent-posts>最近</a></li><li class=nav-item><a class=nav-link href=/#education>历程</a></li><li class=nav-item><a class=nav-link href=/#projects>项目</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>更多的</a><div class=dropdown-menu aria-labelledby=navbarDropdown><a class=dropdown-item href=/#achievements>成就</a></div></li><div id=top-navbar-divider></div><li class=nav-item><a class=nav-link id=blog-link href=/posts>博文</a></li><li class=nav-item><a class=nav-link id=note-link href=/notes>笔记</a></li><li class=nav-item><a class=nav-link href=https://github.com/ormissia>GitHub</a></li></ul></div></div><img src=/images/ormissia_hu763a76473558eea2a316ef50b45aaecf_966068_42x0_resize_box_3.png class=d-none id=main-logo alt=Logo>
<img src=/images/ormissia_hu763a76473558eea2a316ef50b45aaecf_966068_42x0_resize_box_3.png class=d-none id=inverted-logo alt="Inverted Logo"></nav><section class=sidebar-section id=sidebar-section><div class=sidebar-holder><div class=sidebar id=sidebar><form class=mx-auto method=get action=/search><input type=text name=keyword placeholder=搜索 data-search id=search-box></form><div class=sidebar-tree><ul class=tree id=tree><li id=list-heading><a href=/notes data-filter=all>笔记</a></li><div class=subtree><li><i data-feather=plus-circle></i><a class=list-link href=/notes/go/> Go</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/go/basic/> Basics</a><ul><li><a class=list-link href=/notes/go/basic/basic/ title=Basic>Basic</a></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/go/advance/> Advance</a><ul><li><a class=list-link href=/notes/go/advance/time/ title=time>time</a></li><li><a class=list-link href=/notes/go/advance/gomod/ title="go mod">go mod</a></li><li><a class=list-link href=/notes/go/advance/chan/ title="go chan">go chan</a></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/go/algorithm/> Algorithm</a><ul><li><a class=list-link href=/notes/go/algorithm/basic/ title=Basic>Basic</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/java/> Java</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/java/basic/> Basics</a><ul><li><a class=list-link href=/notes/java/basic/basic_type/ title="Basic Types">Basic Types</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/scala/> Scala</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/scala/basic/> Basic</a><ul><li><a class=list-link href=/notes/scala/basic/basic_type/ title="Basic Types">Basic Types</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/python/> Python</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/python/basic/> Basic</a><ul><li><a class=list-link href=/notes/python/basic/basic/ title=Basic>Basic</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/js/> JavaScript</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/js/basic/> Basic</a><ul><li><a class=list-link href=/notes/js/basic/basic/ title=Basic>Basic</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/sql/> SQL</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/sql/dml/> DML</a><ul><li><a class=list-link href=/notes/sql/dml/dml/ title="SQL DML">SQL DML</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/linux/> Linux</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/linux/shell/> Shell</a><ul><li><a class=list-link href=/notes/linux/shell/basic/ title=Basic>Basic</a></li><li><a class=list-link href=/notes/linux/shell/advance/ title=Advance>Advance</a></li><li><a class=list-link href=/notes/linux/shell/vi/ title=vi>vi</a></li><li><a class=list-link href=/notes/linux/shell/script/ title=Script>Script</a></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/linux/system/> System</a><ul><li><a class=list-link href=/notes/linux/system/system/ title=Memory>Memory</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/hbase/> Hbase</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/hbase/shell/> Shell</a><ul><li><a class=list-link href=/notes/hbase/shell/basic/ title=Basic>Basic</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/kafka/> Kafka</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/kafka/shell/> Shell</a><ul><li><a class=list-link href=/notes/kafka/shell/basic/ title=Basic>Basic</a></li></ul></li></ul></li></div></ul></div></div></div></section><section class=content-section id=content-section><div class="content container-fluid" id=content><div class="container-fluid note-card-holder" id=note-card-holder><h1 id=kubernetes-组件>Kubernetes 组件</h1><p>#k8s #kubernetes #容器 #云 #go #golang</p><p><img src=https://d33wubrfki0l68.cloudfront.net/2475489eaf20163ec0f54ddc1d92aa8d4c87c96b/e7c81/images/docs/components-of-kubernetes.svg alt="Kubernetes 的组件"></p><h2 id=控制平面组件control-plane-componentshttpskubernetesiozh-cndocsconceptsoverviewcomponentscontrol-plane-components><a href=https://kubernetes.io/zh-cn/docs/concepts/overview/components/#control-plane-components target=_blank rel=noopener>控制平面组件（Control Plane Components）</a></h2><p>控制平面组件会为集群做出全局决策，比如资源的调度。 以及检测和响应集群事件，例如当不满足部署的 <code>replicas</code> 字段时， 要启动新的 <a href=https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/ target=_blank rel=noopener>pod</a>）。</p><p>控制平面组件可以在集群中的任何节点上运行。 然而，为了简单起见，设置脚本通常会在同一个计算机上启动所有控制平面组件， 并且不会在此计算机上运行用户容器。 请参阅<a href=https://kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/high-availability/ target=_blank rel=noopener>使用 kubeadm 构建高可用性集群</a> 中关于跨多机器控制平面设置的示例。</p><h3 id=kube-apiserverhttpskubernetesiozh-cndocsconceptsoverviewcomponentskube-apiserver><a href=https://kubernetes.io/zh-cn/docs/concepts/overview/components/#kube-apiserver target=_blank rel=noopener>kube-apiserver</a></h3><p>API 服务器是 Kubernetes <a href="https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-control-plane" target=_blank rel=noopener>控制平面</a>的组件， 该组件负责公开了 Kubernetes API，负责处理接受请求的工作。 API 服务器是 Kubernetes 控制平面的前端。</p><p>Kubernetes API 服务器的主要实现是 <a href=https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kube-apiserver/ target=_blank rel=noopener>kube-apiserver</a>。 <code>kube-apiserver</code> 设计上考虑了水平扩缩，也就是说，它可通过部署多个实例来进行扩缩。 你可以运行 <code>kube-apiserver</code> 的多个实例，并在这些实例之间平衡流量。</p><h3 id=etcdhttpskubernetesiozh-cndocsconceptsoverviewcomponentsetcd><a href=https://kubernetes.io/zh-cn/docs/concepts/overview/components/#etcd target=_blank rel=noopener>etcd</a></h3><p>一致且高可用的键值存储，用作 Kubernetes 所有集群数据的后台数据库。</p><p>如果你的 Kubernetes 集群使用 etcd 作为其后台数据库， 请确保你针对这些数据有一份 <a href=https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/configure-upgrade-etcd/#backing-up-an-etcd-cluster target=_blank rel=noopener>备份</a>计划。</p><p>你可以在官方<a href=https://etcd.io/docs/ target=_blank rel=noopener>文档</a>中找到有关 etcd 的深入知识。</p><h3 id=kube-schedulerhttpskubernetesiozh-cndocsconceptsoverviewcomponentskube-scheduler><a href=https://kubernetes.io/zh-cn/docs/concepts/overview/components/#kube-scheduler target=_blank rel=noopener>kube-scheduler</a></h3><p><code>kube-scheduler</code> 是<a href="https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-control-plane" target=_blank rel=noopener>控制平面</a>的组件， 负责监视新创建的、未指定运行<a href=https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/ target=_blank rel=noopener>节点（node）</a>的 <a href=https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/ target=_blank rel=noopener>Pods</a>， 并选择节点来让 Pod 在上面运行。</p><p>调度决策考虑的因素包括单个 Pod 及 Pods 集合的资源需求、软硬件及策略约束、 亲和性及反亲和性规范、数据位置、工作负载间的干扰及最后时限。</p><h3 id=kube-controller-managerhttpskubernetesiozh-cndocsconceptsoverviewcomponentskube-controller-manager><a href=https://kubernetes.io/zh-cn/docs/concepts/overview/components/#kube-controller-manager target=_blank rel=noopener>kube-controller-manager</a></h3><p><a href=https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank rel=noopener>kube-controller-manager</a> 是<a href="https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-control-plane" target=_blank rel=noopener>控制平面</a>的组件， 负责运行<a href=https://kubernetes.io/zh-cn/docs/concepts/architecture/controller/ target=_blank rel=noopener>控制器</a>进程。</p><p>从逻辑上讲， 每个<a href=https://kubernetes.io/zh-cn/docs/concepts/architecture/controller/ target=_blank rel=noopener>控制器</a>都是一个单独的进程， 但是为了降低复杂性，它们都被编译到同一个可执行文件，并在同一个进程中运行。</p><p>这些控制器包括：</p><ul><li>节点控制器（Node Controller）：负责在节点出现故障时进行通知和响应</li><li>任务控制器（Job Controller）：监测代表一次性任务的 Job 对象，然后创建 Pods 来运行这些任务直至完成</li><li>端点分片控制器（EndpointSlice controller）：填充端点分片（EndpointSlice）对象（以提供 Service 和 Pod 之间的链接）。</li><li>服务账号控制器（ServiceAccount controller）：为新的命名空间创建默认的服务账号（ServiceAccount）。</li></ul><h3 id=cloud-controller-managerhttpskubernetesiozh-cndocsconceptsoverviewcomponentscloud-controller-manager><a href=https://kubernetes.io/zh-cn/docs/concepts/overview/components/#cloud-controller-manager target=_blank rel=noopener>cloud-controller-manager</a></h3><p>一个 Kubernetes <a href="https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-control-plane" target=_blank rel=noopener>控制平面</a>组件， 嵌入了特定于云平台的控制逻辑。 云控制器管理器（Cloud Controller Manager）允许你将你的集群连接到云提供商的 API 之上， 并将与该云平台交互的组件同与你的集群交互的组件分离开来。</p><p><code>cloud-controller-manager</code> 仅运行特定于云平台的控制器。 因此如果你在自己的环境中运行 Kubernetes，或者在本地计算机中运行学习环境， 所部署的集群不需要有云控制器管理器。</p><p>与 <code>kube-controller-manager</code> 类似，<code>cloud-controller-manager</code> 将若干逻辑上独立的控制回路组合到同一个可执行文件中， 供你以同一进程的方式运行。 你可以对其执行水平扩容（运行不止一个副本）以提升性能或者增强容错能力。</p><p>下面的控制器都包含对云平台驱动的依赖：</p><ul><li>节点控制器（Node Controller）：用于在节点终止响应后检查云提供商以确定节点是否已被删除</li><li>路由控制器（Route Controller）：用于在底层云基础架构中设置路由</li><li>服务控制器（Service Controller）：用于创建、更新和删除云提供商负载均衡器</li></ul><h2 id=node-组件httpskubernetesiozh-cndocsconceptsoverviewcomponentsnode-components><a href=https://kubernetes.io/zh-cn/docs/concepts/overview/components/#node-components target=_blank rel=noopener>Node 组件</a></h2><p>节点组件会在每个节点上运行，负责维护运行的 Pod 并提供 Kubernetes 运行环境。</p><h3 id=kubelethttpskubernetesiozh-cndocsconceptsoverviewcomponentskubelet><a href=https://kubernetes.io/zh-cn/docs/concepts/overview/components/#kubelet target=_blank rel=noopener>kubelet</a></h3><p><code>kubelet</code> 会在集群中每个<a href=https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/ target=_blank rel=noopener>节点（node）</a>上运行。 它保证<a href=https://kubernetes.io/zh-cn/docs/concepts/overview/what-is-kubernetes/#why-containers target=_blank rel=noopener>容器（containers）</a>都运行在 <a href=https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/ target=_blank rel=noopener>Pod</a> 中。</p><p>kubelet 接收一组通过各类机制提供给它的 PodSpecs， 确保这些 PodSpecs 中描述的容器处于运行状态且健康。 kubelet 不会管理不是由 Kubernetes 创建的容器。</p><h3 id=kube-proxyhttpskubernetesiozh-cndocsconceptsoverviewcomponentskube-proxy><a href=https://kubernetes.io/zh-cn/docs/concepts/overview/components/#kube-proxy target=_blank rel=noopener>kube-proxy</a></h3><p><a href=https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kube-proxy/ target=_blank rel=noopener>kube-proxy</a> 是集群中每个<a href=https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/ target=_blank rel=noopener>节点（node）</a>上所运行的网络代理， 实现 Kubernetes <a href=https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/ target=_blank rel=noopener>服务（Service）</a> 概念的一部分。</p><p>kube-proxy 维护节点上的一些网络规则， 这些网络规则会允许从集群内部或外部的网络会话与 Pod 进行网络通信。</p><p>如果操作系统提供了可用的数据包过滤层，则 kube-proxy 会通过它来实现网络规则。 否则，kube-proxy 仅做流量转发。</p><h3 id=容器运行时container-runtimehttpskubernetesiozh-cndocsconceptsoverviewcomponentscontainer-runtime><a href=https://kubernetes.io/zh-cn/docs/concepts/overview/components/#container-runtime target=_blank rel=noopener>容器运行时（Container Runtime）</a></h3><p>容器运行环境是负责运行容器的软件。</p><p>Kubernetes 支持许多容器运行环境，例如 <a href=https://containerd.io/docs/ target=_blank rel=noopener>containerd</a>、 <a href=https://cri-o.io/#what-is-cri-o target=_blank rel=noopener>CRI-O</a> 以及 <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md target=_blank rel=noopener>Kubernetes CRI (容器运行环境接口)</a> 的其他任何实现。</p><h2 id=插件addonshttpskubernetesiozh-cndocsconceptsoverviewcomponentsaddons><a href=https://kubernetes.io/zh-cn/docs/concepts/overview/components/#addons target=_blank rel=noopener>插件（Addons）</a></h2><p>插件使用 Kubernetes 资源（<a href=https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/daemonset/ target=_blank rel=noopener>DaemonSet</a>、 <a href=https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/ target=_blank rel=noopener>Deployment</a> 等）实现集群功能。 因为这些插件提供集群级别的功能，插件中命名空间域的资源属于 <code>kube-system</code> 命名空间。</p><p>下面描述众多插件中的几种。有关可用插件的完整列表，请参见 <a href=https://kubernetes.io/zh-cn/docs/concepts/cluster-administration/addons/ target=_blank rel=noopener>插件（Addons）</a>。</p><h3 id=dnshttpskubernetesiozh-cndocsconceptsoverviewcomponentsdns><a href=https://kubernetes.io/zh-cn/docs/concepts/overview/components/#dns target=_blank rel=noopener>DNS</a></h3><p>尽管其他插件都并非严格意义上的必需组件，但几乎所有 Kubernetes 集群都应该有<a href=https://kubernetes.io/zh-cn/docs/concepts/services-networking/dns-pod-service/ target=_blank rel=noopener>集群 DNS</a>， 因为很多示例都需要 DNS 服务。</p><p>集群 DNS 是一个 DNS 服务器，和环境中的其他 DNS 服务器一起工作，它为 Kubernetes 服务提供 DNS 记录。</p><p>Kubernetes 启动的容器自动将此 DNS 服务器包含在其 DNS 搜索列表中。</p><h3 id=web-界面仪表盘httpskubernetesiozh-cndocsconceptsoverviewcomponentsweb-ui-dashboard><a href=https://kubernetes.io/zh-cn/docs/concepts/overview/components/#web-ui-dashboard target=_blank rel=noopener>Web 界面（仪表盘）</a></h3><p><a href=https://kubernetes.io/zh-cn/docs/tasks/access-application-cluster/web-ui-dashboard/ target=_blank rel=noopener>Dashboard</a> 是 Kubernetes 集群的通用的、基于 Web 的用户界面。 它使用户可以管理集群中运行的应用程序以及集群本身， 并进行故障排除。</p><h3 id=容器资源监控httpskubernetesiozh-cndocsconceptsoverviewcomponentscontainer-resource-monitoring><a href=https://kubernetes.io/zh-cn/docs/concepts/overview/components/#container-resource-monitoring target=_blank rel=noopener>容器资源监控</a></h3><p><a href=https://kubernetes.io/zh-cn/docs/tasks/debug/debug-cluster/resource-usage-monitoring/ target=_blank rel=noopener>容器资源监控</a> 将关于容器的一些常见的时间序列度量值保存到一个集中的数据库中， 并提供浏览这些数据的界面。</p><h3 id=集群层面日志httpskubernetesiozh-cndocsconceptsoverviewcomponentscluster-level-logging><a href=https://kubernetes.io/zh-cn/docs/concepts/overview/components/#cluster-level-logging target=_blank rel=noopener>集群层面日志 </a></h3><p><a href=https://kubernetes.io/zh-cn/docs/concepts/cluster-administration/logging/ target=_blank rel=noopener>集群层面日志</a>机制负责将容器的日志数据保存到一个集中的日志存储中， 这种集中日志存储提供搜索和浏览接口。</p></div></div></section></div><footer id=footer class="container-fluid text-center align-content-center footer pb-2"><div class="container pt-5"><div class="row text-left"><div class="col-md-4 col-sm-12"><h5>联系方式:</h5><ul><li><span>QQ: </span><span>1432050813</span></li><li><a href=mailto:ormissia@outlook.com target=_blank rel=noopener><span><i class="fas fa-envelope"></i></span> <span>ormissia@outlook.com</span></a></li></ul></div></div></div><hr><div class=container><p id=disclaimer><strong>免责声明:</strong> 老铁看到底了，要负责的哦</p></div><hr><div class=container><div class="row text-left"><div class=col-md-4><a id=theme href=https://github.com/hugo-toha/toha target=_blank rel=noopener><img src=/images/theme-logo_hu8376fd15465fef26ffe66b6bcf0ca686_13669_32x0_resize_box_3.png alt="Toha Theme Logo">
Toha</a></div><div class="col-md-4 text-center">© 2021 Copyright.</div><div class="col-md-4 text-right"><a id=hugo href=https://gohugo.io/ target=_blank rel=noopener>Powered by
<img src=/images/hugo-logo.svg alt="Hugo Logo" height=18></a></div></div></div></footer><script src=/application.dd14ce5884a636a7014ae8dc2953b8089e2c54e6449da331e2726c712c81c910.js integrity="sha256-3RTOWISmNqcBSujcKVO4CJ4sVOZEnaMx4nJscSyByRA=" defer></script></body></html>