<!doctype html><html lang=zh-cn><head><title></title>
<meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="ie=edge"><link rel=stylesheet href=/application.87ecd420aa4299c8e4b21123c5360ef38ce9d1370c88559d014914f4a65e6b89.css integrity="sha256-h+zUIKpCmcjkshEjxTYO84zp0TcMiFWdAUkU9KZea4k="><link rel=icon type=image/png href=/images/favicon_hu8376fd15465fef26ffe66b6bcf0ca686_13669_42x0_resize_box_3.png><meta property="og:title" content><meta property="og:description" content="网络IO演进历程 #epoll #linux #网络 #网络模型
网络 IO 模型演进 阻塞 IO #BIO (Blocking IO) 非阻塞 IO #NIO (Nonblocking IO) IO 多路复用第一版 #select / #poll / #epoll 异步 IO #AIO (Async IO) BIO 阻塞 IO，顾名思义当用户发生了系统调用后，如果数据未从网卡到达内核态，内核态数据未准备好，此时会一直阻塞。直到数据就绪，然后从内核态拷贝到用户态再返回。
BIO 缺点，能支持的并发连接数比较少： 一台服务器能分配的线程数是有限的 大量线程频繁切换上下文会影响性能 核心矛盾：一个 client 分配一个线程是因为处理客户端读写是阻塞式的，为避免该阻塞影响接受后续新的 client 的连接，所以将阻塞逻辑交由单独的线程处理。
NIO 非阻塞 IO：见名知意，就是在第一阶段 (网卡-内核态) 数据未到达时不等待，然后直接返回。因此非阻塞 IO 需要不断的用户发起请求，轮询内核。
优点：将 socket 设为非阻塞后，在读取时如果数据未就绪就直接返回。可以通过一个线程管理多个 client 连接。 缺点：需要不断轮询内核，数据是否已经就绪，会造成很多无效的，太频繁的系统调用 (system call) 而造成资源浪费。 select/poll/epoll select 和 poll 的区别 select 能处理的最大连接，默认是 1024 个，可以通过修改配置来改变，但终究是有限个；而 poll 理论上可以支持无限个 select 和 poll 在管理海量的连接时，会频繁的从用户态拷贝到内核态，比较消耗资源 epoll 对文件描述符的操作有两种模式： LT（level trigger）和 ET（edge trigger）。"><meta property="og:type" content="article"><meta property="og:url" content="https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9Cio%E6%BC%94%E8%BF%9B%E5%8E%86%E7%A8%8B/"><meta property="article:section" content="notes"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="网络IO演进历程 #epoll #linux #网络 #网络模型
网络 IO 模型演进 阻塞 IO #BIO (Blocking IO) 非阻塞 IO #NIO (Nonblocking IO) IO 多路复用第一版 #select / #poll / #epoll 异步 IO #AIO (Async IO) BIO 阻塞 IO，顾名思义当用户发生了系统调用后，如果数据未从网卡到达内核态，内核态数据未准备好，此时会一直阻塞。直到数据就绪，然后从内核态拷贝到用户态再返回。
BIO 缺点，能支持的并发连接数比较少： 一台服务器能分配的线程数是有限的 大量线程频繁切换上下文会影响性能 核心矛盾：一个 client 分配一个线程是因为处理客户端读写是阻塞式的，为避免该阻塞影响接受后续新的 client 的连接，所以将阻塞逻辑交由单独的线程处理。
NIO 非阻塞 IO：见名知意，就是在第一阶段 (网卡-内核态) 数据未到达时不等待，然后直接返回。因此非阻塞 IO 需要不断的用户发起请求，轮询内核。
优点：将 socket 设为非阻塞后，在读取时如果数据未就绪就直接返回。可以通过一个线程管理多个 client 连接。 缺点：需要不断轮询内核，数据是否已经就绪，会造成很多无效的，太频繁的系统调用 (system call) 而造成资源浪费。 select/poll/epoll select 和 poll 的区别 select 能处理的最大连接，默认是 1024 个，可以通过修改配置来改变，但终究是有限个；而 poll 理论上可以支持无限个 select 和 poll 在管理海量的连接时，会频繁的从用户态拷贝到内核态，比较消耗资源 epoll 对文件描述符的操作有两种模式： LT（level trigger）和 ET（edge trigger）。"><script>theme=localStorage.getItem("darkmode:color-scheme")||"system",theme=="system"&&(window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?theme="dark":theme="light"),document.documentElement.setAttribute("data-theme",theme)</script></head><body class="type-notes kind-page" data-spy=scroll data-target=#TableOfContents data-offset=80><div class="container-fluid bg-secondary wrapper"><nav class="navbar navbar-expand-xl top-navbar shadow" id=top-navbar><div class=container><button class="navbar-toggler navbar-light" id=sidebar-toggler type=button>
<i data-feather=sidebar></i>
</button>
<a class=navbar-brand href=/><img src=/images/ormissia_hu763a76473558eea2a316ef50b45aaecf_966068_42x0_resize_box_3.png id=logo alt=Logo>
Ormissia's Blog</a>
<button class="navbar-toggler navbar-light" id=navbar-toggler type=button data-toggle=collapse data-target=#top-nav-items aria-label=menu>
<i data-feather=menu></i></button><div class="collapse navbar-collapse dynamic-navbar" id=top-nav-items><ul class="nav navbar-nav ml-auto"><li class=nav-item><a class=nav-link href=/#home>主页</a></li><li class=nav-item><a class=nav-link href=/#about>技能</a></li><li class=nav-item><a class=nav-link href=/#recent-posts>最近</a></li><li class=nav-item><a class=nav-link href=/#education>历程</a></li><li class=nav-item><a class=nav-link href=/#projects>项目</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>更多的</a><div class=dropdown-menu aria-labelledby=navbarDropdown><a class=dropdown-item href=/#achievements>成就</a></div></li><div id=top-navbar-divider></div><li class=nav-item><a class=nav-link id=blog-link href=/posts>博文</a></li><li class=nav-item><a class=nav-link id=note-link href=/notes>笔记</a></li><li class=nav-item><a class=nav-link href=https://github.com/ormissia>GitHub</a></li></ul></div></div><img src=/images/ormissia_hu763a76473558eea2a316ef50b45aaecf_966068_42x0_resize_box_3.png class=d-none id=main-logo alt=Logo>
<img src=/images/ormissia_hu763a76473558eea2a316ef50b45aaecf_966068_42x0_resize_box_3.png class=d-none id=inverted-logo alt="Inverted Logo"></nav><section class=sidebar-section id=sidebar-section><div class=sidebar-holder><div class=sidebar id=sidebar><form class=mx-auto method=get action=/search><input type=text name=keyword placeholder=搜索 data-search id=search-box></form><div class=sidebar-tree><ul class=tree id=tree><li id=list-heading><a href=/notes data-filter=all>笔记</a></li><div class=subtree><li><i data-feather=plus-circle></i><a class=list-link href=/notes/go/> Go</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/go/basic/> Basics</a><ul><li><a class=list-link href=/notes/go/basic/basic/ title=Basic>Basic</a></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/go/advance/> Advance</a><ul><li><a class=list-link href=/notes/go/advance/time/ title=time>time</a></li><li><a class=list-link href=/notes/go/advance/gomod/ title="go mod">go mod</a></li><li><a class=list-link href=/notes/go/advance/chan/ title="go chan">go chan</a></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/go/algorithm/> Algorithm</a><ul><li><a class=list-link href=/notes/go/algorithm/basic/ title=Basic>Basic</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/java/> Java</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/java/basic/> Basics</a><ul><li><a class=list-link href=/notes/java/basic/basic_type/ title="Basic Types">Basic Types</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/scala/> Scala</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/scala/basic/> Basic</a><ul><li><a class=list-link href=/notes/scala/basic/basic_type/ title="Basic Types">Basic Types</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/python/> Python</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/python/basic/> Basic</a><ul><li><a class=list-link href=/notes/python/basic/basic/ title=Basic>Basic</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/js/> JavaScript</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/js/basic/> Basic</a><ul><li><a class=list-link href=/notes/js/basic/basic/ title=Basic>Basic</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/sql/> SQL</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/sql/dml/> DML</a><ul><li><a class=list-link href=/notes/sql/dml/dml/ title="SQL DML">SQL DML</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/linux/> Linux</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/linux/shell/> Shell</a><ul><li><a class=list-link href=/notes/linux/shell/basic/ title=Basic>Basic</a></li><li><a class=list-link href=/notes/linux/shell/advance/ title=Advance>Advance</a></li><li><a class=list-link href=/notes/linux/shell/vi/ title=vi>vi</a></li><li><a class=list-link href=/notes/linux/shell/script/ title=Script>Script</a></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/linux/system/> System</a><ul><li><a class=list-link href=/notes/linux/system/system/ title=Memory>Memory</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/hbase/> Hbase</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/hbase/shell/> Shell</a><ul><li><a class=list-link href=/notes/hbase/shell/basic/ title=Basic>Basic</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/kafka/> Kafka</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/kafka/shell/> Shell</a><ul><li><a class=list-link href=/notes/kafka/shell/basic/ title=Basic>Basic</a></li></ul></li></ul></li></div></ul></div></div></div></section><section class=content-section id=content-section><div class="content container-fluid" id=content><div class="container-fluid note-card-holder" id=note-card-holder><h1 id=网络io演进历程>网络IO演进历程</h1><p>#epoll #linux #网络 #网络模型</p><h2 id=网络-io-模型演进>网络 IO 模型演进</h2><ol><li>阻塞 IO #BIO (Blocking IO)</li><li>非阻塞 IO #NIO (Nonblocking IO)</li><li>IO 多路复用第一版 #select / #poll / #epoll</li><li>异步 IO #AIO (Async IO)</li></ol><p><img src=%E8%AE%A1%E7%AE%97%E6%9C%BA/img/io_comparison.png alt=io></p><h2 id=bio>BIO</h2><blockquote><p>阻塞 IO，顾名思义当用户发生了系统调用后，如果数据未从网卡到达内核态，内核态数据未准备好，此时会一直阻塞。直到数据就绪，然后从内核态拷贝到用户态再返回。</p></blockquote><p><img src=%E8%AE%A1%E7%AE%97%E6%9C%BA/img/bio.png alt=bio></p><ul><li>BIO 缺点，能支持的并发连接数比较少：<ul><li>一台服务器能分配的线程数是有限的</li><li>大量线程频繁切换上下文会影响性能</li></ul></li></ul><blockquote><p>核心矛盾：一个 client 分配一个线程是因为处理客户端读写是阻塞式的，为避免该阻塞影响接受后续新的 client 的连接，所以将阻塞逻辑交由单独的线程处理。</p></blockquote><h2 id=nio>NIO</h2><blockquote><p>非阻塞 IO：见名知意，就是在第一阶段 (网卡-内核态) 数据未到达时不等待，然后直接返回。因此非阻塞 IO 需要不断的用户发起请求，轮询内核。</p></blockquote><p><img src=%E8%AE%A1%E7%AE%97%E6%9C%BA/img/nio.png alt=nio></p><ul><li>优点：将 socket 设为非阻塞后，在读取时如果数据未就绪就直接返回。可以通过一个线程管理多个 client 连接。</li><li>缺点：需要不断轮询内核，数据是否已经就绪，会造成很多无效的，太频繁的系统调用 (system call) 而造成资源浪费。</li></ul><h2 id=selectpollepoll>select/poll/epoll</h2><p><img src=%E8%AE%A1%E7%AE%97%E6%9C%BA/img/poll.png alt=poll></p><ul><li><code>select</code> 和 <code>poll</code> 的区别<ul><li><code>select</code> 能处理的最大连接，默认是 <code>1024</code> 个，可以通过修改配置来改变，但终究是有限个；而 <code>poll</code> 理论上可以支持无限个</li><li><code>select</code> 和 <code>poll</code> 在管理海量的连接时，会频繁的从用户态拷贝到内核态，比较消耗资源</li></ul></li></ul><p><code>epoll</code> 对文件描述符的操作有两种模式：<code> LT（level trigger）</code>和 <code>ET（edge trigger）</code>。</p><ul><li><code>LT 模式</code>：当 <code>epoll_wait</code> 检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用 <code>epoll_wait</code> 时，会再次响应应用程序并通知此事件。</li><li><code>ET 模式</code>：当 <code>epoll_wait</code> 检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用 <code>epoll_wait</code> 时，不会再次响应应用程序并通知此事件。</li></ul><blockquote><p>简言之：边沿触发仅触发一次，水平触发会一直触发。</p></blockquote><p><code>epoll</code> 高效的本质在于：</p><ul><li>减少了用户态和内核态的文件句柄拷贝</li><li>减少了对可读可写文件句柄的遍历</li><li><code>mmap</code> 加速了内核与用户空间的信息传递，<code>epoll</code> 是通过内核与用户 <code>mmap</code> 同一块内存，避免了无谓的内存拷贝</li><li><code>IO</code>性能不会随着监听的文件描述的数量增长而下降</li><li>使用红黑树存储fd，以及对应的回调函数，其插入，查找，删除的性能不错，相比于hash，不必预先分配很多的空间</li></ul><table><thead><tr><th>-</th><th><code>select</code></th><th><code>poll</code></th><th><code>epoll</code></th></tr></thead><tbody><tr><td>操作方式</td><td>遍历</td><td>遍历</td><td>回调</td></tr><tr><td>底层实现</td><td>数组</td><td>链表</td><td>哈希表</td></tr><tr><td>IO 效率</td><td>每次调用都进行线性遍历，时间复杂度为 O (n)</td><td>每次调用都进行线性遍历，时间复杂度为 O (n)</td><td>事件通知方式，每当 <code>fd</code> 就绪，系统注册的回调函数就会被调用，将就绪 <code>fd</code> 放到 <code>rdllist</code> 里面。时间复杂度 O (1)</td></tr><tr><td>最大连接数</td><td>1024（x86）或 2048（x64）</td><td>无上限</td><td>无上限</td></tr><tr><td>fd 拷贝</td><td>每次调用 <code>select</code>，都需要把 fd 集合从用户态拷贝到内核态</td><td>每次调用 <code>poll</code>，都需要把 <code>fd</code> 集合从用户态拷贝到内核态</td><td>调用 <code>epoll_ctl</code> 时拷贝进内核并保存，之后每次 <code>epoll_wait</code> 不拷贝</td></tr></tbody></table><h2 id=aio>AIO</h2><p>异步 IO
<img src=%E8%AE%A1%E7%AE%97%E6%9C%BA/img/aio.png alt=aio></p></div></div></section></div><footer id=footer class="container-fluid text-center align-content-center footer pb-2"><div class="container pt-5"><div class="row text-left"><div class="col-md-4 col-sm-12"><h5>联系方式:</h5><ul><li><span>QQ: </span><span>1432050813</span></li><li><a href=mailto:ormissia@outlook.com target=_blank rel=noopener><span><i class="fas fa-envelope"></i></span> <span>ormissia@outlook.com</span></a></li></ul></div></div></div><hr><div class=container><p id=disclaimer><strong>免责声明:</strong> 老铁看到底了，要负责的哦</p></div><hr><div class=container><div class="row text-left"><div class=col-md-4><a id=theme href=https://github.com/hugo-toha/toha target=_blank rel=noopener><img src=/images/theme-logo_hu8376fd15465fef26ffe66b6bcf0ca686_13669_32x0_resize_box_3.png alt="Toha Theme Logo">
Toha</a></div><div class="col-md-4 text-center">© 2021 Copyright.</div><div class="col-md-4 text-right"><a id=hugo href=https://gohugo.io/ target=_blank rel=noopener>Powered by
<img src=/images/hugo-logo.svg alt="Hugo Logo" height=18></a></div></div></div></footer><script src=/application.dd14ce5884a636a7014ae8dc2953b8089e2c54e6449da331e2726c712c81c910.js integrity="sha256-3RTOWISmNqcBSujcKVO4CJ4sVOZEnaMx4nJscSyByRA=" defer></script></body></html>