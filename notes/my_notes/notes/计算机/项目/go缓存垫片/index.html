<!doctype html><html lang=zh-cn><head><title></title>
<meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="ie=edge"><link rel=stylesheet href=/application.87ecd420aa4299c8e4b21123c5360ef38ce9d1370c88559d014914f4a65e6b89.css integrity="sha256-h+zUIKpCmcjkshEjxTYO84zp0TcMiFWdAUkU9KZea4k="><link rel=icon type=image/png href=/images/favicon_hu8376fd15465fef26ffe66b6bcf0ca686_13669_42x0_resize_box_3.png><meta property="og:title" content><meta property="og:description" content="Go 缓存垫片 #go #缓存 #框架 #延时双删
一个数据库与内存之间的缓存适配器，运用了控制反转的思想。引入之后无需重复为每种实体实现相同的缓存策略
项目背景 大多数情况下我们在代码中添加 #Redis 作为缓存中间件之后都会多出很多代码来。每给一个实体添加缓存，都需要加一大堆代码。久而久之，代码库变得非常冗杂而且难看。
举个栗子，一个带缓存的实体的查询逻辑的伪代码：
func (e *TestS) Select() { e, ok := SelectFromRedis() if !ok { et, ok := SelectFromDB() if !ok { return } e = et go func() { SaveToCache(e) }() return } return } 假如一个服务中有多个需要维护到缓存中的实体，再加上删除，修改等其他逻辑，就会出现非常多的相似代码，导致维护十分麻烦，而且复用性极低。即使写成工具类，当有新服务加入时，也需要将代码拷来拷去，显得十分不专业。
因此，写了这个缓存适配器框架，使用 #控制反转 的思想，代码中的实体只需实现指定接口，删除、修改、查询时只需要调用该库的对应方法即可，无需关心具体实现，框架会自动完成缓存相关逻辑。
使用示例 缓存客户端实现CacheClintImpl接口 type CacheClintImpl interface { Del(key string) (int64, error) SetString(key, value string) error GetString(k string) (string, error) } 实现参考redis_storage.go
初始化缓存客户端并将缓存客户端示例初始化到框架中 redis_ex."><meta property="og:type" content="article"><meta property="og:url" content="https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E9%A1%B9%E7%9B%AE/go%E7%BC%93%E5%AD%98%E5%9E%AB%E7%89%87/"><meta property="article:section" content="notes"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="Go 缓存垫片 #go #缓存 #框架 #延时双删
一个数据库与内存之间的缓存适配器，运用了控制反转的思想。引入之后无需重复为每种实体实现相同的缓存策略
项目背景 大多数情况下我们在代码中添加 #Redis 作为缓存中间件之后都会多出很多代码来。每给一个实体添加缓存，都需要加一大堆代码。久而久之，代码库变得非常冗杂而且难看。
举个栗子，一个带缓存的实体的查询逻辑的伪代码：
func (e *TestS) Select() { e, ok := SelectFromRedis() if !ok { et, ok := SelectFromDB() if !ok { return } e = et go func() { SaveToCache(e) }() return } return } 假如一个服务中有多个需要维护到缓存中的实体，再加上删除，修改等其他逻辑，就会出现非常多的相似代码，导致维护十分麻烦，而且复用性极低。即使写成工具类，当有新服务加入时，也需要将代码拷来拷去，显得十分不专业。
因此，写了这个缓存适配器框架，使用 #控制反转 的思想，代码中的实体只需实现指定接口，删除、修改、查询时只需要调用该库的对应方法即可，无需关心具体实现，框架会自动完成缓存相关逻辑。
使用示例 缓存客户端实现CacheClintImpl接口 type CacheClintImpl interface { Del(key string) (int64, error) SetString(key, value string) error GetString(k string) (string, error) } 实现参考redis_storage.go
初始化缓存客户端并将缓存客户端示例初始化到框架中 redis_ex."><script>theme=localStorage.getItem("darkmode:color-scheme")||"system",theme=="system"&&(window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?theme="dark":theme="light"),document.documentElement.setAttribute("data-theme",theme)</script></head><body class="type-notes kind-page" data-spy=scroll data-target=#TableOfContents data-offset=80><div class="container-fluid bg-secondary wrapper"><nav class="navbar navbar-expand-xl top-navbar shadow" id=top-navbar><div class=container><button class="navbar-toggler navbar-light" id=sidebar-toggler type=button>
<i data-feather=sidebar></i>
</button>
<a class=navbar-brand href=/><img src=/images/ormissia_hu763a76473558eea2a316ef50b45aaecf_966068_42x0_resize_box_3.png id=logo alt=Logo>
Ormissia's Blog</a>
<button class="navbar-toggler navbar-light" id=navbar-toggler type=button data-toggle=collapse data-target=#top-nav-items aria-label=menu>
<i data-feather=menu></i></button><div class="collapse navbar-collapse dynamic-navbar" id=top-nav-items><ul class="nav navbar-nav ml-auto"><li class=nav-item><a class=nav-link href=/#home>主页</a></li><li class=nav-item><a class=nav-link href=/#about>技能</a></li><li class=nav-item><a class=nav-link href=/#recent-posts>最近</a></li><li class=nav-item><a class=nav-link href=/#education>历程</a></li><li class=nav-item><a class=nav-link href=/#projects>项目</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>更多的</a><div class=dropdown-menu aria-labelledby=navbarDropdown><a class=dropdown-item href=/#achievements>成就</a></div></li><div id=top-navbar-divider></div><li class=nav-item><a class=nav-link id=blog-link href=/posts>博文</a></li><li class=nav-item><a class=nav-link id=note-link href=/notes>笔记</a></li><li class=nav-item><a class=nav-link href=https://github.com/ormissia>GitHub</a></li></ul></div></div><img src=/images/ormissia_hu763a76473558eea2a316ef50b45aaecf_966068_42x0_resize_box_3.png class=d-none id=main-logo alt=Logo>
<img src=/images/ormissia_hu763a76473558eea2a316ef50b45aaecf_966068_42x0_resize_box_3.png class=d-none id=inverted-logo alt="Inverted Logo"></nav><section class=sidebar-section id=sidebar-section><div class=sidebar-holder><div class=sidebar id=sidebar><form class=mx-auto method=get action=/search><input type=text name=keyword placeholder=搜索 data-search id=search-box></form><div class=sidebar-tree><ul class=tree id=tree><li id=list-heading><a href=/notes data-filter=all>笔记</a></li><div class=subtree><li><i data-feather=plus-circle></i><a class=list-link href=/notes/go/> Go</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/go/basic/> Basics</a><ul><li><a class=list-link href=/notes/go/basic/basic/ title=Basic>Basic</a></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/go/advance/> Advance</a><ul><li><a class=list-link href=/notes/go/advance/time/ title=time>time</a></li><li><a class=list-link href=/notes/go/advance/gomod/ title="go mod">go mod</a></li><li><a class=list-link href=/notes/go/advance/chan/ title="go chan">go chan</a></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/go/algorithm/> Algorithm</a><ul><li><a class=list-link href=/notes/go/algorithm/basic/ title=Basic>Basic</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/java/> Java</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/java/basic/> Basics</a><ul><li><a class=list-link href=/notes/java/basic/basic_type/ title="Basic Types">Basic Types</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/scala/> Scala</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/scala/basic/> Basic</a><ul><li><a class=list-link href=/notes/scala/basic/basic_type/ title="Basic Types">Basic Types</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/python/> Python</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/python/basic/> Basic</a><ul><li><a class=list-link href=/notes/python/basic/basic/ title=Basic>Basic</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/js/> JavaScript</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/js/basic/> Basic</a><ul><li><a class=list-link href=/notes/js/basic/basic/ title=Basic>Basic</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/sql/> SQL</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/sql/dml/> DML</a><ul><li><a class=list-link href=/notes/sql/dml/dml/ title="SQL DML">SQL DML</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/linux/> Linux</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/linux/shell/> Shell</a><ul><li><a class=list-link href=/notes/linux/shell/basic/ title=Basic>Basic</a></li><li><a class=list-link href=/notes/linux/shell/advance/ title=Advance>Advance</a></li><li><a class=list-link href=/notes/linux/shell/vi/ title=vi>vi</a></li><li><a class=list-link href=/notes/linux/shell/script/ title=Script>Script</a></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/linux/system/> System</a><ul><li><a class=list-link href=/notes/linux/system/system/ title=Memory>Memory</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/hbase/> Hbase</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/hbase/shell/> Shell</a><ul><li><a class=list-link href=/notes/hbase/shell/basic/ title=Basic>Basic</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/kafka/> Kafka</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/kafka/shell/> Shell</a><ul><li><a class=list-link href=/notes/kafka/shell/basic/ title=Basic>Basic</a></li></ul></li></ul></li></div></ul></div></div></div></section><section class=content-section id=content-section><div class="content container-fluid" id=content><div class="container-fluid note-card-holder" id=note-card-holder><h1 id=go-缓存垫片>Go 缓存垫片</h1><p>#go #缓存 #框架 #延时双删</p><blockquote><p>一个数据库与内存之间的缓存适配器，运用了控制反转的思想。引入之后无需重复为每种实体实现相同的缓存策略</p></blockquote><h2 id=项目背景>项目背景</h2><p>大多数情况下我们在代码中添加 #Redis 作为缓存中间件之后都会多出很多代码来。每给一个实体添加缓存，都需要加一大堆代码。久而久之，代码库变得非常冗杂而且难看。</p><p>举个栗子，一个带缓存的实体的查询逻辑的伪代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>e</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TestS</span>) <span style=color:#a6e22e>Select</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>e</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>SelectFromRedis</span>()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>ok</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>et</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>SelectFromDB</span>()
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>ok</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>e</span> = <span style=color:#a6e22e>et</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>SaveToCache</span>(<span style=color:#a6e22e>e</span>)
</span></span><span style=display:flex><span>		}()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>假如一个服务中有多个需要维护到缓存中的实体，再加上删除，修改等其他逻辑，就会出现非常多的相似代码，导致维护十分麻烦，而且复用性极低。即使写成工具类，当有新服务加入时，也需要将代码拷来拷去，显得十分不专业。</p><p>因此，写了这个缓存适配器框架，使用 #控制反转 的思想，代码中的实体只需实现指定接口，删除、修改、查询时只需要调用该库的对应方法即可，无需关心具体实现，框架会自动完成缓存相关逻辑。</p><h2 id=使用示例>使用示例</h2><ol><li>缓存客户端实现<code>CacheClintImpl</code>接口</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>CacheClintImpl</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Del</span>(<span style=color:#a6e22e>key</span> <span style=color:#66d9ef>string</span>) (<span style=color:#66d9ef>int64</span>, <span style=color:#66d9ef>error</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>SetString</span>(<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>value</span> <span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>error</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>GetString</span>(<span style=color:#a6e22e>k</span> <span style=color:#66d9ef>string</span>) (<span style=color:#66d9ef>string</span>, <span style=color:#66d9ef>error</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>实现参考<a href=https://github.com/ormissia/cache_shim/blob/master/example/redis_ex/redis_storage.go target=_blank rel=noopener>redis_storage.go</a></p><ol start=2><li>初始化缓存客户端并将缓存客户端示例初始化到框架中</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>redis_ex</span>.<span style=color:#a6e22e>Init</span>()
</span></span><span style=display:flex><span><span style=color:#a6e22e>cache_shim</span>.<span style=color:#a6e22e>InitCacheClient</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>redis_ex</span>.<span style=color:#a6e22e>RDB</span>)
</span></span></code></pre></div><ol start=3><li>需要做缓存的实体实现<code>CacheTypeImpl</code>接口</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// CacheType 需要缓存的实体接口定义  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>CacheType</span> <span style=color:#66d9ef>interface</span> {  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>CacheKey</span>() <span style=color:#66d9ef>string</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>Expiration</span>() <span style=color:#66d9ef>int</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>Delete</span>() <span style=color:#66d9ef>error</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>Select</span>() <span style=color:#66d9ef>error</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>Update</span>() <span style=color:#66d9ef>error</span>  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=4><li>需要做缓存的实体实现 <code>CacheTypeImpl</code> 接口
因为控制反转，这个时候不需要直接调用实体的 <code>Select()</code> 方法，直接调用 <code>cache_shim</code> 包中的 <code>Select()</code> 函数即可，框架将自动维护缓存中的数据。</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>_</span> = <span style=color:#a6e22e>t1</span>.<span style=color:#a6e22e>Insert</span>()
</span></span><span style=display:flex><span><span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>cache_shim</span>.<span style=color:#a6e22e>Select</span>[<span style=color:#f92672>*</span><span style=color:#a6e22e>db_ex</span>.<span style=color:#a6e22e>UserEx</span>](<span style=color:#a6e22e>t1</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;t.type: %T\tt: %v\terr: %v&#34;</span>,<span style=color:#a6e22e>t</span>,<span style=color:#a6e22e>t</span>,<span style=color:#a6e22e>err</span>)
</span></span></code></pre></div><ol start=5><li>向数据库中插入数据之后，使用框架提供的查询方法查询
代码参考<a href=https://github.com/ormissia/cache_shim/blob/master/example/main.go target=_blank rel=noopener>main.go</a></li></ol><blockquote><p>修改、删除同理</p></blockquote><h2 id=链接>链接</h2><ul><li><a href=https://github.com/ormissia/cache_shim target=_blank rel=noopener>项目源码</a></li></ul></div></div></section></div><footer id=footer class="container-fluid text-center align-content-center footer pb-2"><div class="container pt-5"><div class="row text-left"><div class="col-md-4 col-sm-12"><h5>联系方式:</h5><ul><li><span>QQ: </span><span>1432050813</span></li><li><a href=mailto:ormissia@outlook.com target=_blank rel=noopener><span><i class="fas fa-envelope"></i></span> <span>ormissia@outlook.com</span></a></li></ul></div></div></div><hr><div class=container><p id=disclaimer><strong>免责声明:</strong> 老铁看到底了，要负责的哦</p></div><hr><div class=container><div class="row text-left"><div class=col-md-4><a id=theme href=https://github.com/hugo-toha/toha target=_blank rel=noopener><img src=/images/theme-logo_hu8376fd15465fef26ffe66b6bcf0ca686_13669_32x0_resize_box_3.png alt="Toha Theme Logo">
Toha</a></div><div class="col-md-4 text-center">© 2021 Copyright.</div><div class="col-md-4 text-right"><a id=hugo href=https://gohugo.io/ target=_blank rel=noopener>Powered by
<img src=/images/hugo-logo.svg alt="Hugo Logo" height=18></a></div></div></div></footer><script src=/application.dd14ce5884a636a7014ae8dc2953b8089e2c54e6449da331e2726c712c81c910.js integrity="sha256-3RTOWISmNqcBSujcKVO4CJ4sVOZEnaMx4nJscSyByRA=" defer></script></body></html>