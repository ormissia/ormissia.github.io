<!doctype html><html lang=zh-cn><head><title></title>
<meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="ie=edge"><link rel=stylesheet href=/application.87ecd420aa4299c8e4b21123c5360ef38ce9d1370c88559d014914f4a65e6b89.css integrity="sha256-h+zUIKpCmcjkshEjxTYO84zp0TcMiFWdAUkU9KZea4k="><link rel=icon type=image/png href=/images/favicon_hu8376fd15465fef26ffe66b6bcf0ca686_13669_42x0_resize_box_3.png><meta property="og:title" content><meta property="og:description" content="Go 语法 #go #golang #语法 #编程语言
设置代理 go env -w GOPROXY=https://goproxy.cn,direct init () 函数 init() 函数的执行顺序：
对同一个 go 文件的 init() 调用顺序是从上到下的。 对同一个 package 中不同文件是按文件名字符串比较&#34;从小到大&#34;顺序调用各文件中的 init() 函数。 对于不同的 package，如果不相互依赖的话，按照 main 包中”先 import 的后调用”的顺序调用其包中的 init()，如果 package 存在依赖，则先调用最早被依赖的 package 中的 init()，最后调用 main 函数。 如果 init 函数中使用了 println() 或者 print() 你会发现在执行过程中这两个不会按照你想象中的顺序执行。这两个函数官方只推荐在测试环境中使用，对于正式环境不要使用。 基本类型 类型 长度 默认值 说明 bool 1 false byte 1 0 uint8 rune 4 0 Unicode Code Point, int32 int/uint 4/8 0 32 或 64 位 int8/uint8 1 0 -128 ~ 127, 0 ~ 255，byte是uint8 的别名 int16/uint16 2 0 -32768 ~ 32767, 0 ~ 65535 int32/uint32 4 0 -21亿~ 21亿, 0 ~ 42亿，rune是int32 的别名 int64/uint64 8 0 float32 4 0."><meta property="og:type" content="article"><meta property="og:url" content="https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AF%AD%E8%A8%80/go/go-%E8%AF%AD%E6%B3%95/"><meta property="article:section" content="notes"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="Go 语法 #go #golang #语法 #编程语言
设置代理 go env -w GOPROXY=https://goproxy.cn,direct init () 函数 init() 函数的执行顺序：
对同一个 go 文件的 init() 调用顺序是从上到下的。 对同一个 package 中不同文件是按文件名字符串比较&#34;从小到大&#34;顺序调用各文件中的 init() 函数。 对于不同的 package，如果不相互依赖的话，按照 main 包中”先 import 的后调用”的顺序调用其包中的 init()，如果 package 存在依赖，则先调用最早被依赖的 package 中的 init()，最后调用 main 函数。 如果 init 函数中使用了 println() 或者 print() 你会发现在执行过程中这两个不会按照你想象中的顺序执行。这两个函数官方只推荐在测试环境中使用，对于正式环境不要使用。 基本类型 类型 长度 默认值 说明 bool 1 false byte 1 0 uint8 rune 4 0 Unicode Code Point, int32 int/uint 4/8 0 32 或 64 位 int8/uint8 1 0 -128 ~ 127, 0 ~ 255，byte是uint8 的别名 int16/uint16 2 0 -32768 ~ 32767, 0 ~ 65535 int32/uint32 4 0 -21亿~ 21亿, 0 ~ 42亿，rune是int32 的别名 int64/uint64 8 0 float32 4 0."><script>theme=localStorage.getItem("darkmode:color-scheme")||"system",theme=="system"&&(window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?theme="dark":theme="light"),document.documentElement.setAttribute("data-theme",theme)</script></head><body class="type-notes kind-page" data-spy=scroll data-target=#TableOfContents data-offset=80><div class="container-fluid bg-secondary wrapper"><nav class="navbar navbar-expand-xl top-navbar shadow" id=top-navbar><div class=container><button class="navbar-toggler navbar-light" id=sidebar-toggler type=button>
<i data-feather=sidebar></i>
</button>
<a class=navbar-brand href=/><img src=/images/ormissia_hu763a76473558eea2a316ef50b45aaecf_966068_42x0_resize_box_3.png id=logo alt=Logo>
Ormissia's Blog</a>
<button class="navbar-toggler navbar-light" id=navbar-toggler type=button data-toggle=collapse data-target=#top-nav-items aria-label=menu>
<i data-feather=menu></i></button><div class="collapse navbar-collapse dynamic-navbar" id=top-nav-items><ul class="nav navbar-nav ml-auto"><li class=nav-item><a class=nav-link href=/#home>主页</a></li><li class=nav-item><a class=nav-link href=/#about>技能</a></li><li class=nav-item><a class=nav-link href=/#recent-posts>最近</a></li><li class=nav-item><a class=nav-link href=/#education>历程</a></li><li class=nav-item><a class=nav-link href=/#projects>项目</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>更多的</a><div class=dropdown-menu aria-labelledby=navbarDropdown><a class=dropdown-item href=/#achievements>成就</a></div></li><div id=top-navbar-divider></div><li class=nav-item><a class=nav-link id=blog-link href=/posts>博文</a></li><li class=nav-item><a class=nav-link id=note-link href=/notes>笔记</a></li><li class=nav-item><a class=nav-link href=https://github.com/ormissia>GitHub</a></li></ul></div></div><img src=/images/ormissia_hu763a76473558eea2a316ef50b45aaecf_966068_42x0_resize_box_3.png class=d-none id=main-logo alt=Logo>
<img src=/images/ormissia_hu763a76473558eea2a316ef50b45aaecf_966068_42x0_resize_box_3.png class=d-none id=inverted-logo alt="Inverted Logo"></nav><section class=sidebar-section id=sidebar-section><div class=sidebar-holder><div class=sidebar id=sidebar><form class=mx-auto method=get action=/search><input type=text name=keyword placeholder=搜索 data-search id=search-box></form><div class=sidebar-tree><ul class=tree id=tree><li id=list-heading><a href=/notes data-filter=all>笔记</a></li><div class=subtree><li><i data-feather=plus-circle></i><a class=list-link href=/notes/go/> Go</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/go/basic/> Basics</a><ul><li><a class=list-link href=/notes/go/basic/basic/ title=Basic>Basic</a></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/go/advance/> Advance</a><ul><li><a class=list-link href=/notes/go/advance/time/ title=time>time</a></li><li><a class=list-link href=/notes/go/advance/gomod/ title="go mod">go mod</a></li><li><a class=list-link href=/notes/go/advance/chan/ title="go chan">go chan</a></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/go/algorithm/> Algorithm</a><ul><li><a class=list-link href=/notes/go/algorithm/basic/ title=Basic>Basic</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/java/> Java</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/java/basic/> Basics</a><ul><li><a class=list-link href=/notes/java/basic/basic_type/ title="Basic Types">Basic Types</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/scala/> Scala</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/scala/basic/> Basic</a><ul><li><a class=list-link href=/notes/scala/basic/basic_type/ title="Basic Types">Basic Types</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/python/> Python</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/python/basic/> Basic</a><ul><li><a class=list-link href=/notes/python/basic/basic/ title=Basic>Basic</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/js/> JavaScript</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/js/basic/> Basic</a><ul><li><a class=list-link href=/notes/js/basic/basic/ title=Basic>Basic</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/sql/> SQL</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/sql/dml/> DML</a><ul><li><a class=list-link href=/notes/sql/dml/dml/ title="SQL DML">SQL DML</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/linux/> Linux</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/linux/shell/> Shell</a><ul><li><a class=list-link href=/notes/linux/shell/basic/ title=Basic>Basic</a></li><li><a class=list-link href=/notes/linux/shell/advance/ title=Advance>Advance</a></li><li><a class=list-link href=/notes/linux/shell/vi/ title=vi>vi</a></li><li><a class=list-link href=/notes/linux/shell/script/ title=Script>Script</a></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/linux/system/> System</a><ul><li><a class=list-link href=/notes/linux/system/system/ title=Memory>Memory</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/hbase/> Hbase</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/hbase/shell/> Shell</a><ul><li><a class=list-link href=/notes/hbase/shell/basic/ title=Basic>Basic</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/kafka/> Kafka</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/kafka/shell/> Shell</a><ul><li><a class=list-link href=/notes/kafka/shell/basic/ title=Basic>Basic</a></li></ul></li></ul></li></div></ul></div></div></div></section><section class=content-section id=content-section><div class="content container-fluid" id=content><div class="container-fluid note-card-holder" id=note-card-holder><h1 id=go-语法>Go 语法</h1><p>#go #golang #语法 #编程语言</p><h2 id=设置代理>设置代理</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>go env -w GOPROXY<span style=color:#f92672>=</span>https://goproxy.cn,direct
</span></span></code></pre></div><h2 id=init--函数>init () 函数</h2><p><code>init()</code> 函数的执行顺序：</p><ul><li>对同一个 <code>go</code> 文件的 <code>init()</code> 调用顺序是从上到下的。</li><li>对同一个 <code>package</code> 中不同文件是按文件名字符串比较"从小到大"顺序调用各文件中的 <code>init()</code> 函数。</li><li>对于不同的 <code>package</code>，如果不相互依赖的话，按照 <code>main</code> 包中”先 <code>import</code> 的后调用”的顺序调用其包中的 <code>init()</code>，如果 <code>package</code> 存在依赖，则先调用最早被依赖的 <code>package</code> 中的 <code>init()</code>，最后调用 <code>main</code> 函数。</li><li><em>如果 <code>init</code> 函数中使用了 <code>println()</code> 或者 <code>print()</code> 你会发现在执行过程中这两个不会按照你想象中的顺序执行。这两个函数官方只推荐在测试环境中使用，对于正式环境不要使用。</em></li></ul><h2 id=基本类型>基本类型</h2><table><thead><tr><th>类型</th><th>长度</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>bool</td><td>1</td><td>false</td><td></td></tr><tr><td>byte</td><td>1</td><td>0</td><td>uint8</td></tr><tr><td>rune</td><td>4</td><td>0</td><td>Unicode Code Point, int32</td></tr><tr><td>int/uint</td><td>4/8</td><td>0</td><td>32 或 64 位</td></tr><tr><td>int8/uint8</td><td>1</td><td>0</td><td>-128 ~ 127, 0 ~ 255，byte是uint8 的别名</td></tr><tr><td>int16/uint16</td><td>2</td><td>0</td><td>-32768 ~ 32767, 0 ~ 65535</td></tr><tr><td>int32/uint32</td><td>4</td><td>0</td><td>-21亿~ 21亿, 0 ~ 42亿，rune是int32 的别名</td></tr><tr><td>int64/uint64</td><td>8</td><td>0</td><td></td></tr><tr><td>float32</td><td>4</td><td>0.0</td><td></td></tr><tr><td>float64</td><td>8</td><td>0.0</td><td></td></tr><tr><td>complex64</td><td>8</td><td></td><td></td></tr><tr><td>complex128</td><td>16</td><td></td><td></td></tr><tr><td>uintptr</td><td>4/8</td><td></td><td></td></tr><tr><td>array</td><td></td><td></td><td></td></tr><tr><td>struct</td><td></td><td></td><td></td></tr><tr><td>string</td><td></td><td>""</td><td></td></tr><tr><td>slice</td><td></td><td>nil</td><td></td></tr><tr><td>map</td><td></td><td>nil</td><td></td></tr><tr><td>channel</td><td></td><td>nil</td><td></td></tr><tr><td>interface</td><td></td><td>nil</td><td>接口</td></tr><tr><td>function</td><td></td><td>nil</td><td>函数</td></tr></tbody></table><h3 id=字符串转义符>字符串转义符</h3><table><thead><tr><th>转义符</th><th>含义</th></tr></thead><tbody><tr><td>\r</td><td>(回车符) 返回当前行行首</td></tr><tr><td>\n</td><td>（换行符）向下移动一个字符</td></tr><tr><td>\t</td><td>制表符</td></tr><tr><td>'</td><td>单引号</td></tr><tr><td>"</td><td>双引号</td></tr><tr><td>/</td><td>斜杠</td></tr></tbody></table><h2 id=切片>#切片</h2><h3 id=切片定义>切片定义</h3><ul><li>使用 <code>make</code> 声明</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// make中后两个参数为len和cap，后者可以省略
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>100</span>)
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// len允许运行时期动态指定
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>f</span>() {  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>_</span> = make([]<span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>l</span>())  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>l</span>() <span style=color:#66d9ef>int</span> {  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>使用字面值声明</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 中括号中不应有数字，加上数字则声明的是数组
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>}
</span></span></code></pre></div><ul><li>从现有的数组中声明</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> [<span style=color:#ae81ff>6</span>]<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>} 
</span></span><span style=display:flex><span><span style=color:#a6e22e>ns1</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>[<span style=color:#ae81ff>1</span>:<span style=color:#ae81ff>3</span>:<span style=color:#ae81ff>4</span>]  
</span></span><span style=display:flex><span><span style=color:#a6e22e>ns2</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>[<span style=color:#ae81ff>1</span>:<span style=color:#ae81ff>3</span>]  
</span></span><span style=display:flex><span><span style=color:#a6e22e>ns3</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>[:<span style=color:#ae81ff>3</span>]  
</span></span><span style=display:flex><span><span style=color:#a6e22e>ns4</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>[<span style=color:#ae81ff>1</span>:]  
</span></span><span style=display:flex><span><span style=color:#a6e22e>ns5</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>[:]
</span></span></code></pre></div><h3 id=切片的遍历>切片的遍历</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>}  
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>a</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>s</span> {  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;addr_i: %p\taddr_a: %p\n&#34;</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>s</span>[<span style=color:#a6e22e>i</span>], <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>a</span>)  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// 此处注意：如果需要修改slice中的值，修改a的值是不起作用的，需要使用索引修改原切片值  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>a</span><span style=color:#f92672>++</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>s</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>+=</span> <span style=color:#ae81ff>10</span>  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>s</span>)
</span></span></code></pre></div><p>控制台打印：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>addr_i: 0x140000a8030   addr_a: 0x140000a4008
</span></span><span style=display:flex><span>addr_i: 0x140000a8038   addr_a: 0x140000a4008
</span></span><span style=display:flex><span>addr_i: 0x140000a8040   addr_a: 0x140000a4008
</span></span><span style=display:flex><span>addr_i: 0x140000a8048   addr_a: 0x140000a4008
</span></span><span style=display:flex><span>addr_i: 0x140000a8050   addr_a: 0x140000a4008
</span></span><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#ae81ff>10</span> <span style=color:#ae81ff>11</span> <span style=color:#ae81ff>12</span> <span style=color:#ae81ff>13</span> 14<span style=color:#f92672>]</span>
</span></span></code></pre></div><blockquote><p>根据打印可以看出：上述代码中变量 <code>a</code> 的地址始终是相同的</p></blockquote><h3 id=切片的传递>切片的传递</h3><blockquote><p><code>go</code> 中函数参数传递方式都为值传递。而对于切片来说，切片的结构中传递的是一个具体数组的地址。<strong>如果函数中的切片发生扩容，那么扩容之后的操作对于函数外部是不可见的</strong>。</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go></code></pre></div><blockquote><p>如果需要将改动传递到函数外部，要么将修改后的切片作为值返回，要么参数定义时使用切片指针。</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go></code></pre></div><h3 id=源码>源码</h3><blockquote><p>源码参考 <a href=https://github.com/golang/go/tree/release-branch.go1.19 target=_blank rel=noopener>go version go1.19.2 darwin/arm64</a></p></blockquote><ul><li><a href=https://github.com/golang/go/blob/release-branch.go1.19/src/runtime/slice.go target=_blank rel=noopener>src/runtime/slice.go</a></li></ul><h4 id=切片数据结构>切片数据结构</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>slice</span> <span style=color:#66d9ef>struct</span> {  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>array</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>len</span>   <span style=color:#66d9ef>int</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>cap</span>   <span style=color:#66d9ef>int</span>  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=创建切片>创建切片</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>makeslice</span>(<span style=color:#a6e22e>et</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>_type</span>, <span style=color:#a6e22e>len</span>, <span style=color:#a6e22e>cap</span> <span style=color:#66d9ef>int</span>) <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> {  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>mem</span>, <span style=color:#a6e22e>overflow</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>math</span>.<span style=color:#a6e22e>MulUintptr</span>(<span style=color:#a6e22e>et</span>.<span style=color:#a6e22e>size</span>, uintptr(<span style=color:#a6e22e>cap</span>))  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>overflow</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>mem</span> &gt; <span style=color:#a6e22e>maxAlloc</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>len</span> &lt; <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>len</span> &gt; <span style=color:#a6e22e>cap</span> {  
</span></span><span style=display:flex><span>      <span style=color:#75715e>// NOTE: Produce a &#39;len out of range&#39; error instead of a  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>// &#39;cap out of range&#39; error when someone does make([]T, bignumber).      // &#39;cap out of range&#39; is true too, but since the cap is only being      // supplied implicitly, saying len is clearer.      // See golang.org/issue/4085.      mem, overflow := math.MulUintptr(et.size, uintptr(len))  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>overflow</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>mem</span> &gt; <span style=color:#a6e22e>maxAlloc</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>len</span> &lt; <span style=color:#ae81ff>0</span> {  
</span></span><span style=display:flex><span>         <span style=color:#a6e22e>panicmakeslicelen</span>()  
</span></span><span style=display:flex><span>      }  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>panicmakeslicecap</span>()  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>mallocgc</span>(<span style=color:#a6e22e>mem</span>, <span style=color:#a6e22e>et</span>, <span style=color:#66d9ef>true</span>)  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 64位
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>makeslice64</span>(<span style=color:#a6e22e>et</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>_type</span>, <span style=color:#a6e22e>len64</span>, <span style=color:#a6e22e>cap64</span> <span style=color:#66d9ef>int64</span>) <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> {  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>len</span> <span style=color:#f92672>:=</span> int(<span style=color:#a6e22e>len64</span>)  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> int64(<span style=color:#a6e22e>len</span>) <span style=color:#f92672>!=</span> <span style=color:#a6e22e>len64</span> {  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>panicmakeslicelen</span>()  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>cap</span> <span style=color:#f92672>:=</span> int(<span style=color:#a6e22e>cap64</span>)  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> int64(<span style=color:#a6e22e>cap</span>) <span style=color:#f92672>!=</span> <span style=color:#a6e22e>cap64</span> {  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>panicmakeslicecap</span>()  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>makeslice</span>(<span style=color:#a6e22e>et</span>, <span style=color:#a6e22e>len</span>, <span style=color:#a6e22e>cap</span>)  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=切片扩容>切片扩容</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// growslice handles slice growth during append.// It is passed the slice element type, the old slice, and the desired new minimum capacity,  
</span></span></span><span style=display:flex><span><span style=color:#75715e>// and it returns a new slice with at least that capacity, with the old data// copied into it.  
</span></span></span><span style=display:flex><span><span style=color:#75715e>// The new slice&#39;s length is set to the old slice&#39;s length,  
</span></span></span><span style=display:flex><span><span style=color:#75715e>// NOT to the new requested capacity.  
</span></span></span><span style=display:flex><span><span style=color:#75715e>// This is for codegen convenience. The old slice&#39;s length is used immediately  
</span></span></span><span style=display:flex><span><span style=color:#75715e>// to calculate where to write new values during an append.// TODO: When the old backend is gone, reconsider this decision.  
</span></span></span><span style=display:flex><span><span style=color:#75715e>// The SSA backend might prefer the new length or to return only ptr/cap and save stack space.func growslice(et *_type, old slice, cap int) slice {  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>raceenabled</span> {  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>callerpc</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getcallerpc</span>()  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>racereadrangepc</span>(<span style=color:#a6e22e>old</span>.<span style=color:#a6e22e>array</span>, uintptr(<span style=color:#a6e22e>old</span>.<span style=color:#a6e22e>len</span><span style=color:#f92672>*</span>int(<span style=color:#a6e22e>et</span>.<span style=color:#a6e22e>size</span>)), <span style=color:#a6e22e>callerpc</span>, <span style=color:#a6e22e>abi</span>.<span style=color:#a6e22e>FuncPCABIInternal</span>(<span style=color:#a6e22e>growslice</span>))  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>msanenabled</span> {  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>msanread</span>(<span style=color:#a6e22e>old</span>.<span style=color:#a6e22e>array</span>, uintptr(<span style=color:#a6e22e>old</span>.<span style=color:#a6e22e>len</span><span style=color:#f92672>*</span>int(<span style=color:#a6e22e>et</span>.<span style=color:#a6e22e>size</span>)))  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>asanenabled</span> {  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>asanread</span>(<span style=color:#a6e22e>old</span>.<span style=color:#a6e22e>array</span>, uintptr(<span style=color:#a6e22e>old</span>.<span style=color:#a6e22e>len</span><span style=color:#f92672>*</span>int(<span style=color:#a6e22e>et</span>.<span style=color:#a6e22e>size</span>)))  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>cap</span> &lt; <span style=color:#a6e22e>old</span>.<span style=color:#a6e22e>cap</span> {  
</span></span><span style=display:flex><span>      panic(<span style=color:#a6e22e>errorString</span>(<span style=color:#e6db74>&#34;growslice: cap out of range&#34;</span>))  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>et</span>.<span style=color:#a6e22e>size</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {  
</span></span><span style=display:flex><span>      <span style=color:#75715e>// append should not create a slice with nil pointer but non-zero len.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>// We assume that append doesn&#39;t need to preserve old.array in this case.      return slice{unsafe.Pointer(&amp;zerobase), old.len, cap}  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>newcap</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>old</span>.<span style=color:#a6e22e>cap</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>doublecap</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>newcap</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>newcap</span>  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>cap</span> &gt; <span style=color:#a6e22e>doublecap</span> {  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>newcap</span> = <span style=color:#a6e22e>cap</span>  
</span></span><span style=display:flex><span>   } <span style=color:#66d9ef>else</span> {  
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>threshold</span> = <span style=color:#ae81ff>256</span>  
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>old</span>.<span style=color:#a6e22e>cap</span> &lt; <span style=color:#a6e22e>threshold</span> {  
</span></span><span style=display:flex><span>         <span style=color:#a6e22e>newcap</span> = <span style=color:#a6e22e>doublecap</span>  
</span></span><span style=display:flex><span>      } <span style=color:#66d9ef>else</span> {  
</span></span><span style=display:flex><span>         <span style=color:#75715e>// Check 0 &lt; newcap to detect overflow  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>         <span style=color:#75715e>// and prevent an infinite loop.         for 0 &lt; newcap &amp;&amp; newcap &lt; cap {  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// Transition from growing 2x for small slices  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// to growing 1.25x for large slices. This formula            // gives a smooth-ish transition between the two.            newcap += (newcap + 3*threshold) / 4  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>         }  
</span></span><span style=display:flex><span>         <span style=color:#75715e>// Set newcap to the requested cap when  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>         <span style=color:#75715e>// the newcap calculation overflowed.         if newcap &lt;= 0 {  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>newcap</span> = <span style=color:#a6e22e>cap</span>  
</span></span><span style=display:flex><span>         }  
</span></span><span style=display:flex><span>      }  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>overflow</span> <span style=color:#66d9ef>bool</span>  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>lenmem</span>, <span style=color:#a6e22e>newlenmem</span>, <span style=color:#a6e22e>capmem</span> <span style=color:#66d9ef>uintptr</span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// Specialize for common values of et.size.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// For 1 we don&#39;t need any division/multiplication.   // For goarch.PtrSize, compiler will optimize division/multiplication into a shift by a constant.   // For powers of 2, use a variable shift.   switch {  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>et</span>.<span style=color:#a6e22e>size</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>:  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>lenmem</span> = uintptr(<span style=color:#a6e22e>old</span>.<span style=color:#a6e22e>len</span>)  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>newlenmem</span> = uintptr(<span style=color:#a6e22e>cap</span>)  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>capmem</span> = <span style=color:#a6e22e>roundupsize</span>(uintptr(<span style=color:#a6e22e>newcap</span>))  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>overflow</span> = uintptr(<span style=color:#a6e22e>newcap</span>) &gt; <span style=color:#a6e22e>maxAlloc</span>  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>newcap</span> = int(<span style=color:#a6e22e>capmem</span>)  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>et</span>.<span style=color:#a6e22e>size</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>goarch</span>.<span style=color:#a6e22e>PtrSize</span>:  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>lenmem</span> = uintptr(<span style=color:#a6e22e>old</span>.<span style=color:#a6e22e>len</span>) <span style=color:#f92672>*</span> <span style=color:#a6e22e>goarch</span>.<span style=color:#a6e22e>PtrSize</span>  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>newlenmem</span> = uintptr(<span style=color:#a6e22e>cap</span>) <span style=color:#f92672>*</span> <span style=color:#a6e22e>goarch</span>.<span style=color:#a6e22e>PtrSize</span>  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>capmem</span> = <span style=color:#a6e22e>roundupsize</span>(uintptr(<span style=color:#a6e22e>newcap</span>) <span style=color:#f92672>*</span> <span style=color:#a6e22e>goarch</span>.<span style=color:#a6e22e>PtrSize</span>)  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>overflow</span> = uintptr(<span style=color:#a6e22e>newcap</span>) &gt; <span style=color:#a6e22e>maxAlloc</span><span style=color:#f92672>/</span><span style=color:#a6e22e>goarch</span>.<span style=color:#a6e22e>PtrSize</span>  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>newcap</span> = int(<span style=color:#a6e22e>capmem</span> <span style=color:#f92672>/</span> <span style=color:#a6e22e>goarch</span>.<span style=color:#a6e22e>PtrSize</span>)  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>isPowerOfTwo</span>(<span style=color:#a6e22e>et</span>.<span style=color:#a6e22e>size</span>):  
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>shift</span> <span style=color:#66d9ef>uintptr</span>  
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>goarch</span>.<span style=color:#a6e22e>PtrSize</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>8</span> {  
</span></span><span style=display:flex><span>         <span style=color:#75715e>// Mask shift for better code generation.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>         <span style=color:#a6e22e>shift</span> = uintptr(<span style=color:#a6e22e>sys</span>.<span style=color:#a6e22e>Ctz64</span>(uint64(<span style=color:#a6e22e>et</span>.<span style=color:#a6e22e>size</span>))) <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>63</span>  
</span></span><span style=display:flex><span>      } <span style=color:#66d9ef>else</span> {  
</span></span><span style=display:flex><span>         <span style=color:#a6e22e>shift</span> = uintptr(<span style=color:#a6e22e>sys</span>.<span style=color:#a6e22e>Ctz32</span>(uint32(<span style=color:#a6e22e>et</span>.<span style=color:#a6e22e>size</span>))) <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>31</span>  
</span></span><span style=display:flex><span>      }  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>lenmem</span> = uintptr(<span style=color:#a6e22e>old</span>.<span style=color:#a6e22e>len</span>) <span style=color:#f92672>&lt;&lt;</span> <span style=color:#a6e22e>shift</span>  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>newlenmem</span> = uintptr(<span style=color:#a6e22e>cap</span>) <span style=color:#f92672>&lt;&lt;</span> <span style=color:#a6e22e>shift</span>  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>capmem</span> = <span style=color:#a6e22e>roundupsize</span>(uintptr(<span style=color:#a6e22e>newcap</span>) <span style=color:#f92672>&lt;&lt;</span> <span style=color:#a6e22e>shift</span>)  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>overflow</span> = uintptr(<span style=color:#a6e22e>newcap</span>) &gt; (<span style=color:#a6e22e>maxAlloc</span> <span style=color:#f92672>&gt;&gt;</span> <span style=color:#a6e22e>shift</span>)  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>newcap</span> = int(<span style=color:#a6e22e>capmem</span> <span style=color:#f92672>&gt;&gt;</span> <span style=color:#a6e22e>shift</span>)  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>default</span>:  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>lenmem</span> = uintptr(<span style=color:#a6e22e>old</span>.<span style=color:#a6e22e>len</span>) <span style=color:#f92672>*</span> <span style=color:#a6e22e>et</span>.<span style=color:#a6e22e>size</span>  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>newlenmem</span> = uintptr(<span style=color:#a6e22e>cap</span>) <span style=color:#f92672>*</span> <span style=color:#a6e22e>et</span>.<span style=color:#a6e22e>size</span>  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>capmem</span>, <span style=color:#a6e22e>overflow</span> = <span style=color:#a6e22e>math</span>.<span style=color:#a6e22e>MulUintptr</span>(<span style=color:#a6e22e>et</span>.<span style=color:#a6e22e>size</span>, uintptr(<span style=color:#a6e22e>newcap</span>))  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>capmem</span> = <span style=color:#a6e22e>roundupsize</span>(<span style=color:#a6e22e>capmem</span>)  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>newcap</span> = int(<span style=color:#a6e22e>capmem</span> <span style=color:#f92672>/</span> <span style=color:#a6e22e>et</span>.<span style=color:#a6e22e>size</span>)  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// The check of overflow in addition to capmem &gt; maxAlloc is needed  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// to prevent an overflow which can be used to trigger a segfault   // on 32bit architectures with this example program:   //   // type T [1&lt;&lt;27 + 1]int64   //   // var d T   // var s []T   //   // func main() {   //   s = append(s, d, d, d, d)   //   print(len(s), &#34;\n&#34;)   // }   if overflow || capmem &gt; maxAlloc {  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      panic(<span style=color:#a6e22e>errorString</span>(<span style=color:#e6db74>&#34;growslice: cap out of range&#34;</span>))  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>p</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>et</span>.<span style=color:#a6e22e>ptrdata</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>p</span> = <span style=color:#a6e22e>mallocgc</span>(<span style=color:#a6e22e>capmem</span>, <span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>false</span>)  
</span></span><span style=display:flex><span>      <span style=color:#75715e>// The append() that calls growslice is going to overwrite from old.len to cap (which will be the new length).  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>// Only clear the part that will not be overwritten.      memclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem)  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   } <span style=color:#66d9ef>else</span> {  
</span></span><span style=display:flex><span>      <span style=color:#75715e>// Note: can&#39;t use rawmem (which avoids zeroing of memory), because then GC can scan uninitialized memory.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#a6e22e>p</span> = <span style=color:#a6e22e>mallocgc</span>(<span style=color:#a6e22e>capmem</span>, <span style=color:#a6e22e>et</span>, <span style=color:#66d9ef>true</span>)  
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>lenmem</span> &gt; <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>writeBarrier</span>.<span style=color:#a6e22e>enabled</span> {  
</span></span><span style=display:flex><span>         <span style=color:#75715e>// Only shade the pointers in old.array since we know the destination slice p  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>         <span style=color:#75715e>// only contains nil pointers because it has been cleared during alloc.         bulkBarrierPreWriteSrcOnly(uintptr(p), uintptr(old.array), lenmem-et.size+et.ptrdata)  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      }  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>memmove</span>(<span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>old</span>.<span style=color:#a6e22e>array</span>, <span style=color:#a6e22e>lenmem</span>)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>slice</span>{<span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>old</span>.<span style=color:#a6e22e>len</span>, <span style=color:#a6e22e>newcap</span>}  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=map><code>map</code></h2><h3 id=map-定义>map 定义</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>m1</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>100</span>)   
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>m2</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>int</span>{  
</span></span><span style=display:flex><span>   <span style=color:#e6db74>&#34;a&#34;</span>: <span style=color:#ae81ff>1</span>,  
</span></span><span style=display:flex><span>   <span style=color:#e6db74>&#34;b&#34;</span>: <span style=color:#ae81ff>2</span>,  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=map-的基本使用>map 的基本使用</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>aValue</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>m</span>[<span style=color:#e6db74>&#34;a&#34;</span>]  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 第二个变量ok可用于判断当前key是否存在
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>bValue</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>m</span>[<span style=color:#e6db74>&#34;b&#34;</span>]
</span></span></code></pre></div><h2 id=map-的遍历>map 的遍历</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>k</span>, <span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>m</span> {  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>k</span>,<span style=color:#a6e22e>v</span>)  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=删除元素>删除元素</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>delete(<span style=color:#a6e22e>m</span>, <span style=color:#e6db74>&#34;a&#34;</span>)
</span></span></code></pre></div><h3 id=源码-1>源码</h3><blockquote><p>源码参考 <a href=https://github.com/golang/go/tree/release-branch.go1.19 target=_blank rel=noopener>go version go1.19.2 darwin/arm64</a></p></blockquote><ul><li><a href=https://github.com/golang/go/blob/release-branch.go1.19/src/runtime/map.go target=_blank rel=noopener>src/runtime/map.go</a></li></ul><h4 id=hash冲突>#hash冲突</h4><ul><li>#开放定址法 ：当要存储一对 <code>kv</code> ，发现 <code>hash(key)</code> 的下表已经被别的 <code>key</code> 占用时，就在这个数组中重新找空白没有被占用的位置存储这个 <code>key</code>。常见的有：<code>线性探测法</code>，<code>线性补偿探测法</code>， <code>随机探测法</code>。</li><li>#拉链法 ：可以简单理解成数组中元素指向链表的头结点的一种结构。当 <code>key</code> 发生 <code>hash</code> 冲突时，在冲突位置的元素上形成一个链表。当查找时，发现 <code>key</code> 冲突，顺着链表一直往下找，直到链表的尾节点，找不到则返回空。</li></ul><p>开放定址法和拉链法的优缺点：</p><ul><li>拉链法通常比线性探测法处理简单</li><li>线性探测查找是会被拉链法会更消耗时间</li><li>线性探测会更加容易导致扩容，而拉链不会</li><li>拉链存储了指针，所以空间上会比线性探测占用多一点</li><li>拉链是动态申请存储空间的，所以更适合链长不确定的</li></ul><h4 id=map-的结构>map 的结构</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// A header for a Go map.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>hmap</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Note: the format of the hmap is also encoded in cmd/compile/internal/reflectdata/reflect.go.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// Make sure this stays in sync with the compiler&#39;s definition.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>count</span>     <span style=color:#66d9ef>int</span> <span style=color:#75715e>// # live cells == size of map.  Must be first (used by len() builtin)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>flags</span>     <span style=color:#66d9ef>uint8</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>B</span>         <span style=color:#66d9ef>uint8</span>  <span style=color:#75715e>// log_2 of # of buckets (can hold up to loadFactor * 2^B items)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>noverflow</span> <span style=color:#66d9ef>uint16</span> <span style=color:#75715e>// approximate number of overflow buckets; see incrnoverflow for details
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>hash0</span>     <span style=color:#66d9ef>uint32</span> <span style=color:#75715e>// hash seed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>buckets</span>    <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> <span style=color:#75715e>// array of 2^B Buckets. may be nil if count==0.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>oldbuckets</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> <span style=color:#75715e>// previous bucket array of half the size, non-nil only when growing
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>nevacuate</span>  <span style=color:#66d9ef>uintptr</span>        <span style=color:#75715e>// progress counter for evacuation (buckets less than this have been evacuated)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>extra</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>mapextra</span> <span style=color:#75715e>// optional fields
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// mapextra holds fields that are not present on all maps.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>mapextra</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// If both key and elem do not contain pointers and are inline, then we mark bucket
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// type as containing no pointers. This avoids scanning such maps.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// However, bmap.overflow is a pointer. In order to keep overflow buckets
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// alive, we store pointers to all overflow buckets in hmap.extra.overflow and hmap.extra.oldoverflow.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// overflow and oldoverflow are only used if key and elem do not contain pointers.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// overflow contains overflow buckets for hmap.buckets.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// oldoverflow contains overflow buckets for hmap.oldbuckets.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// The indirection allows to store a pointer to the slice in hiter.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>overflow</span>    <span style=color:#f92672>*</span>[]<span style=color:#f92672>*</span><span style=color:#a6e22e>bmap</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>oldoverflow</span> <span style=color:#f92672>*</span>[]<span style=color:#f92672>*</span><span style=color:#a6e22e>bmap</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// nextOverflow holds a pointer to a free overflow bucket.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>nextOverflow</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>bmap</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// A bucket for a Go map.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>bmap</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// tophash generally contains the top byte of the hash value
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// for each key in this bucket. If tophash[0] &lt; minTopHash,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// tophash[0] is a bucket evacuation state instead.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>tophash</span> [<span style=color:#a6e22e>bucketCnt</span>]<span style=color:#66d9ef>uint8</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Followed by bucketCnt keys and then bucketCnt elems.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// NOTE: packing all the keys together and then all the elems together makes the
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// code a bit more complicated than alternating key/elem/key/elem/... but it allows
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// us to eliminate padding which would be needed for, e.g., map[int64]int8.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// Followed by an overflow pointer.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h4 id=map-set-以及扩容>map set 以及扩容</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Like mapaccess, but allocates a slot for the key if it is not present in the map.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>mapassign</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>maptype</span>, <span style=color:#a6e22e>h</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hmap</span>, <span style=color:#a6e22e>key</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>) <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> {  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {  
</span></span><span style=display:flex><span>      panic(<span style=color:#a6e22e>plainError</span>(<span style=color:#e6db74>&#34;assignment to entry in nil map&#34;</span>))  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>raceenabled</span> {  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>callerpc</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getcallerpc</span>()  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>pc</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>abi</span>.<span style=color:#a6e22e>FuncPCABIInternal</span>(<span style=color:#a6e22e>mapassign</span>)  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>racewritepc</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>h</span>), <span style=color:#a6e22e>callerpc</span>, <span style=color:#a6e22e>pc</span>)  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>raceReadObjectPC</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>callerpc</span>, <span style=color:#a6e22e>pc</span>)  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>msanenabled</span> {  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>msanread</span>(<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>key</span>.<span style=color:#a6e22e>size</span>)  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>asanenabled</span> {  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>asanread</span>(<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>key</span>.<span style=color:#a6e22e>size</span>)  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>flags</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>hashWriting</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>fatal</span>(<span style=color:#e6db74>&#34;concurrent map writes&#34;</span>)  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>hash</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>hasher</span>(<span style=color:#a6e22e>key</span>, uintptr(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>hash0</span>))  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// Set hashWriting after calling t.hasher, since t.hasher may panic,  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// in which case we have not actually done a write.   h.flags ^= hashWriting  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>buckets</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>buckets</span> = <span style=color:#a6e22e>newobject</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>bucket</span>) <span style=color:#75715e>// newarray(t.bucket, 1)  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>again</span>:  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>bucket</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>hash</span> <span style=color:#f92672>&amp;</span> <span style=color:#a6e22e>bucketMask</span>(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span>)  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>growing</span>() {  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>growWork</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>h</span>, <span style=color:#a6e22e>bucket</span>)  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>bmap</span>)(<span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>buckets</span>, <span style=color:#a6e22e>bucket</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>bucketsize</span>)))  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>top</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>tophash</span>(<span style=color:#a6e22e>hash</span>)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>inserti</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>uint8</span>  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>insertk</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>elem</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>bucketloop</span>:  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>for</span> {  
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> uintptr(<span style=color:#ae81ff>0</span>); <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>bucketCnt</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {  
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>tophash</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>!=</span> <span style=color:#a6e22e>top</span> {  
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>isEmpty</span>(<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>tophash</span>[<span style=color:#a6e22e>i</span>]) <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>inserti</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {  
</span></span><span style=display:flex><span>               <span style=color:#a6e22e>inserti</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>tophash</span>[<span style=color:#a6e22e>i</span>]  
</span></span><span style=display:flex><span>               <span style=color:#a6e22e>insertk</span> = <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>b</span>), <span style=color:#a6e22e>dataOffset</span><span style=color:#f92672>+</span><span style=color:#a6e22e>i</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>keysize</span>))  
</span></span><span style=display:flex><span>               <span style=color:#a6e22e>elem</span> = <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>b</span>), <span style=color:#a6e22e>dataOffset</span><span style=color:#f92672>+</span><span style=color:#a6e22e>bucketCnt</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>keysize</span>)<span style=color:#f92672>+</span><span style=color:#a6e22e>i</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>elemsize</span>))  
</span></span><span style=display:flex><span>            }  
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>tophash</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>==</span> <span style=color:#a6e22e>emptyRest</span> {  
</span></span><span style=display:flex><span>               <span style=color:#66d9ef>break</span> <span style=color:#a6e22e>bucketloop</span>  
</span></span><span style=display:flex><span>            }  
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>  
</span></span><span style=display:flex><span>         }  
</span></span><span style=display:flex><span>         <span style=color:#a6e22e>k</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>b</span>), <span style=color:#a6e22e>dataOffset</span><span style=color:#f92672>+</span><span style=color:#a6e22e>i</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>keysize</span>))  
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>indirectkey</span>() {  
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>k</span> = <span style=color:#f92672>*</span>((<span style=color:#f92672>*</span><span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>)(<span style=color:#a6e22e>k</span>))  
</span></span><span style=display:flex><span>         }  
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>key</span>.<span style=color:#a6e22e>equal</span>(<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>k</span>) {  
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>  
</span></span><span style=display:flex><span>         }  
</span></span><span style=display:flex><span>         <span style=color:#75715e>// already have a mapping for key. Update it.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>         <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>needkeyupdate</span>() {  
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>typedmemmove</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>k</span>, <span style=color:#a6e22e>key</span>)  
</span></span><span style=display:flex><span>         }  
</span></span><span style=display:flex><span>         <span style=color:#a6e22e>elem</span> = <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>b</span>), <span style=color:#a6e22e>dataOffset</span><span style=color:#f92672>+</span><span style=color:#a6e22e>bucketCnt</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>keysize</span>)<span style=color:#f92672>+</span><span style=color:#a6e22e>i</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>elemsize</span>))  
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>goto</span> <span style=color:#a6e22e>done</span>  
</span></span><span style=display:flex><span>      }  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>ovf</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>overflow</span>(<span style=color:#a6e22e>t</span>)  
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ovf</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {  
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>break</span>  
</span></span><span style=display:flex><span>      }  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>b</span> = <span style=color:#a6e22e>ovf</span>  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// Did not find mapping for key. Allocate new cell &amp; add entry.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// If we hit the max load factor or we have too many overflow buckets,   // and we&#39;re not already in the middle of growing, start growing.   if !h.growing() &amp;&amp; (overLoadFactor(h.count+1, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) {  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#a6e22e>hashGrow</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>h</span>)  
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>goto</span> <span style=color:#a6e22e>again</span> <span style=color:#75715e>// Growing the table invalidates everything, so try again  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>inserti</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {  
</span></span><span style=display:flex><span>      <span style=color:#75715e>// The current bucket and all the overflow buckets connected to it are full, allocate a new one.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#a6e22e>newb</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>newoverflow</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>b</span>)  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>inserti</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>newb</span>.<span style=color:#a6e22e>tophash</span>[<span style=color:#ae81ff>0</span>]  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>insertk</span> = <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>newb</span>), <span style=color:#a6e22e>dataOffset</span>)  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>elem</span> = <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>insertk</span>, <span style=color:#a6e22e>bucketCnt</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>keysize</span>))  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// store new key/elem at insert position  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>indirectkey</span>() {  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>kmem</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>newobject</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>key</span>)  
</span></span><span style=display:flex><span>      <span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>)(<span style=color:#a6e22e>insertk</span>) = <span style=color:#a6e22e>kmem</span>  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>insertk</span> = <span style=color:#a6e22e>kmem</span>  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>indirectelem</span>() {  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>vmem</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>newobject</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>elem</span>)  
</span></span><span style=display:flex><span>      <span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>)(<span style=color:#a6e22e>elem</span>) = <span style=color:#a6e22e>vmem</span>  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>typedmemmove</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>insertk</span>, <span style=color:#a6e22e>key</span>)  
</span></span><span style=display:flex><span>   <span style=color:#f92672>*</span><span style=color:#a6e22e>inserti</span> = <span style=color:#a6e22e>top</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>count</span><span style=color:#f92672>++</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>done</span>:  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>flags</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>hashWriting</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>fatal</span>(<span style=color:#e6db74>&#34;concurrent map writes&#34;</span>)  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>flags</span> <span style=color:#f92672>&amp;^=</span> <span style=color:#a6e22e>hashWriting</span>  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>indirectelem</span>() {  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>elem</span> = <span style=color:#f92672>*</span>((<span style=color:#f92672>*</span><span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>)(<span style=color:#a6e22e>elem</span>))  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>elem</span>  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=range><code>range</code></h2><h2 id=泛型>#泛型</h2><h3 id=泛型示例>泛型示例</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Sum 使用泛型
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Sum</span>[<span style=color:#a6e22e>T</span> <span style=color:#66d9ef>int64</span> | <span style=color:#66d9ef>float64</span>](<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span> <span style=color:#a6e22e>T</span>) <span style=color:#a6e22e>T</span> {  
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>a</span><span style=color:#f92672>+</span><span style=color:#a6e22e>b</span>  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=自定义泛型类型>自定义泛型类型</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// CustomInt 泛型与接口声明类似  type CustomInt interface {  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#66d9ef>int</span> | <span style=color:#66d9ef>int8</span> | <span style=color:#66d9ef>int16</span> | <span style=color:#66d9ef>int32</span> | <span style=color:#66d9ef>int64</span>  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// Sum T的类型为声明的CustomInt  func Sum[T CustomInt](a, b T) T {  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>a</span><span style=color:#f92672>+</span><span style=color:#a6e22e>b</span>  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>成员类型支持 <code>go</code> 中所有基本类型</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>CustomT</span> <span style=color:#66d9ef>interface</span> {  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>int</span> | <span style=color:#66d9ef>float32</span> | <span style=color:#66d9ef>bool</span> | <span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span> | <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>int</span>]<span style=color:#66d9ef>int</span> | [<span style=color:#ae81ff>10</span>]<span style=color:#66d9ef>int</span> | []<span style=color:#66d9ef>int</span> | <span style=color:#66d9ef>struct</span>{} | <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Client</span>  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>泛型中的 <code>~</code> 符号都是与类型一起出现的，用来表示支持该类型的衍生类型</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// int8的衍生类型  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>int8A</span> <span style=color:#66d9ef>int8</span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>int8B</span> = <span style=color:#66d9ef>int8</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// CustomInt 不仅支持int8, 还支持int8的衍生类型int8A和int8B  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>CustomInt</span> <span style=color:#66d9ef>interface</span> {  
</span></span><span style=display:flex><span>   <span style=color:#960050;background-color:#1e0010>~</span><span style=color:#66d9ef>int8</span>  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=使用带泛型的函数>使用带泛型的函数</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>a</span> <span style=color:#66d9ef>int</span> = <span style=color:#ae81ff>10</span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>int</span> = <span style=color:#ae81ff>20</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 方法1，正常调用，编译器会自动推断出传入类型是int
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>Sum</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 方法2，显式告诉函数传入的类型是int
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>Sum</span>[<span style=color:#66d9ef>int</span>](<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>)
</span></span></code></pre></div><h3 id=内置的泛型类型-any-和-comparable>内置的泛型类型 <code>any</code> 和 <code>comparable</code></h3><blockquote><p><code>any</code>: 表示 <code>go</code> 里面所有的内置基本类型，等价于 <code>interface{}</code></p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// any is an alias for interface{} and is equivalent to interface{} in all ways.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>any</span> = <span style=color:#66d9ef>interface</span>{}
</span></span></code></pre></div><blockquote><p><code>comparable</code>: 表示 <code>go</code> 里面所有内置的可比较类型：<code>int</code>、<code>uint</code>、<code>float</code>、<code>bool</code>、<code>struct</code>、指针等一切可以比较的类型</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// comparable is an interface that is implemented by all comparable types  
</span></span></span><span style=display:flex><span><span style=color:#75715e>// (booleans, numbers, strings, pointers, channels, arrays of comparable types,  
</span></span></span><span style=display:flex><span><span style=color:#75715e>// structs whose fields are all comparable types).  
</span></span></span><span style=display:flex><span><span style=color:#75715e>// The comparable interface may only be used as a type parameter constraint,  
</span></span></span><span style=display:flex><span><span style=color:#75715e>// not as the type of a variable.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>comparable</span> <span style=color:#66d9ef>interface</span>{ <span style=color:#a6e22e>comparable</span> }
</span></span></code></pre></div><h3 id=泛型与结构体>泛型与结构体</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>AgeT</span> <span style=color:#66d9ef>interface</span> {  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>int8</span> | <span style=color:#66d9ef>int16</span>  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>NameE</span> <span style=color:#66d9ef>interface</span> {  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>string</span>  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>User</span>[<span style=color:#a6e22e>T</span> <span style=color:#a6e22e>AgeT</span>, <span style=color:#a6e22e>E</span> <span style=color:#a6e22e>NameE</span>] <span style=color:#66d9ef>struct</span> {  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>age</span>  <span style=color:#a6e22e>T</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>name</span> <span style=color:#a6e22e>E</span>  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// GetAge 获取年龄  func (u *User[T, E]) GetAge() T {  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>u</span>.<span style=color:#a6e22e>age</span>  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// GetName 获取名字  func (u *User[T, E]) GetName() E {  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>u</span>.<span style=color:#a6e22e>name</span>  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 声明要使用的泛型的类型  var u User[int8, string]  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 赋值  u.age = 10  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>u</span>.<span style=color:#a6e22e>name</span> = <span style=color:#e6db74>&#34;ormissia&#34;</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 调用方法  age := u.GetAge()  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>name</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>u</span>.<span style=color:#a6e22e>GetName</span>()  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>age</span>, <span style=color:#a6e22e>name</span>)
</span></span><span style=display:flex><span><span style=color:#75715e>// 10 ormissia
</span></span></span></code></pre></div><h3 id=泛型与-switch>泛型与 <code>switch</code></h3><blockquote><p>泛型和 <code>switch</code> 配合使用时无法通过编译，只能先将泛型赋值给 <code>interface</code> 才可以和 <code>switch</code> 配合使用</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// GetX 编译不通过  func GetX[T any]() T {  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>t</span> <span style=color:#a6e22e>T</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>T</span> {  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>case</span> <span style=color:#66d9ef>int</span>:  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>t</span> = <span style=color:#ae81ff>18</span>  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>t</span>  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// Get 编译通过  func Get[T any]() T {  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>t</span> <span style=color:#a6e22e>T</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ti</span> <span style=color:#66d9ef>interface</span>{} = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>t</span>  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ti</span>.(<span style=color:#66d9ef>type</span>) {  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>case</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>int</span>:  
</span></span><span style=display:flex><span>      <span style=color:#f92672>*</span><span style=color:#a6e22e>v</span> = <span style=color:#ae81ff>18</span>  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>t</span>  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=泛型的实际使用>泛型的实际使用</h3><ul><li><a href=https://github.com/ormissia/cache_shim/blob/b295ded156d37f6a20d8811e740736a8c228cdbf/cache_strategy.go#L24 target=_blank rel=noopener>缓存适配器中泛型的使用</a> [[计算机/项目/Go缓存垫片]]</li></ul><h2 id=panic-与-recovery>panic 与 recovery</h2><ul><li>调用 <code>panic</code> 后会立刻停止执行当前函数的剩余代码，并在当前 Goroutine 中递归执行调用方的 <code>defer</code></li><li><code>recover</code> 可以中止 <code>panic</code> 造成的程序崩溃。它是一个只能在 <code>defer</code> 中发挥作用的函数，在其他作用域中调用不会发挥作用</li></ul><h2 id=channel>channel</h2><h2 id=switchcase>switch/case</h2><ul><li>单个 <code>case</code> 语句中，可以出现多个结果选项</li><li>只有在 <code>case</code> 中明确添加 <code>fallthrough</code> 关键字，才会明确执行紧跟的下一个<code>case</code></li></ul></div></div></section></div><footer id=footer class="container-fluid text-center align-content-center footer pb-2"><div class="container pt-5"><div class="row text-left"><div class="col-md-4 col-sm-12"><h5>联系方式:</h5><ul><li><span>QQ: </span><span>1432050813</span></li><li><a href=mailto:ormissia@outlook.com target=_blank rel=noopener><span><i class="fas fa-envelope"></i></span> <span>ormissia@outlook.com</span></a></li></ul></div></div></div><hr><div class=container><p id=disclaimer><strong>免责声明:</strong> 老铁看到底了，要负责的哦</p></div><hr><div class=container><div class="row text-left"><div class=col-md-4><a id=theme href=https://github.com/hugo-toha/toha target=_blank rel=noopener><img src=/images/theme-logo_hu8376fd15465fef26ffe66b6bcf0ca686_13669_32x0_resize_box_3.png alt="Toha Theme Logo">
Toha</a></div><div class="col-md-4 text-center">© 2021 Copyright.</div><div class="col-md-4 text-right"><a id=hugo href=https://gohugo.io/ target=_blank rel=noopener>Powered by
<img src=/images/hugo-logo.svg alt="Hugo Logo" height=18></a></div></div></div></footer><script src=/application.dd14ce5884a636a7014ae8dc2953b8089e2c54e6449da331e2726c712c81c910.js integrity="sha256-3RTOWISmNqcBSujcKVO4CJ4sVOZEnaMx4nJscSyByRA=" defer></script></body></html>