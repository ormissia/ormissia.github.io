<!doctype html><html lang=zh-cn><head><title></title>
<meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="ie=edge"><link rel=stylesheet href=/application.87ecd420aa4299c8e4b21123c5360ef38ce9d1370c88559d014914f4a65e6b89.css integrity="sha256-h+zUIKpCmcjkshEjxTYO84zp0TcMiFWdAUkU9KZea4k="><link rel=icon type=image/png href=/images/favicon_hu8376fd15465fef26ffe66b6bcf0ca686_13669_42x0_resize_box_3.png><meta property="og:title" content><meta property="og:description" content="Go GMP 调度模型 #go #golang #gmp #scheduler #抢占式调度 #goroutine #协程 #gmp
所谓 GMP，其中 G 是指 goroutine；M 是 Machine 的缩写，指的是工作线程；P 则是指处理器 Processor，代表了一组资源，M 要想执行 G 的代码，必须持有一个 P 才行。
简单来说，GMP 就是 Task、Worker、Resource 的关系，G 和 P 都是 Go 语言实现的抽象程度更高的组件，对于工作线程而言，Machine 一词表明了它与具体的操作系统和平台密切相关，对具体平台的适配和特殊处理等大多在这一层实现。
从 GM 到 GMP GM 模型调度的几个明显问题 用一个全局的 mutex 保护一个全局的 runq（就绪队列），造成对锁的竞争异常严重 G 每次执行都会被分发到随机的 M 上，造成在不同 M 之间频繁切换，破坏了程序的局部性 每个 M 都会关联一个内存分配缓存 mcache，造成大量内存开销，进一步使数据的局部性变差。实际上只有执行 Go 代码的 M 才真正需要 mcache，那些阻塞在系统调用中的 M 根本不需要，而实际执行 Go 代码的 M 可能仅占总数的 1% 在存在系统调用的情况下，工作线程经常被阻塞和解除阻塞，从而增加了很多开销 通过 runtime."><meta property="og:type" content="article"><meta property="og:url" content="https://ormissia.github.io/notes/my_notes/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AF%AD%E8%A8%80/go/go-gmp-%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B/"><meta property="article:section" content="notes"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="Go GMP 调度模型 #go #golang #gmp #scheduler #抢占式调度 #goroutine #协程 #gmp
所谓 GMP，其中 G 是指 goroutine；M 是 Machine 的缩写，指的是工作线程；P 则是指处理器 Processor，代表了一组资源，M 要想执行 G 的代码，必须持有一个 P 才行。
简单来说，GMP 就是 Task、Worker、Resource 的关系，G 和 P 都是 Go 语言实现的抽象程度更高的组件，对于工作线程而言，Machine 一词表明了它与具体的操作系统和平台密切相关，对具体平台的适配和特殊处理等大多在这一层实现。
从 GM 到 GMP GM 模型调度的几个明显问题 用一个全局的 mutex 保护一个全局的 runq（就绪队列），造成对锁的竞争异常严重 G 每次执行都会被分发到随机的 M 上，造成在不同 M 之间频繁切换，破坏了程序的局部性 每个 M 都会关联一个内存分配缓存 mcache，造成大量内存开销，进一步使数据的局部性变差。实际上只有执行 Go 代码的 M 才真正需要 mcache，那些阻塞在系统调用中的 M 根本不需要，而实际执行 Go 代码的 M 可能仅占总数的 1% 在存在系统调用的情况下，工作线程经常被阻塞和解除阻塞，从而增加了很多开销 通过 runtime."><script>theme=localStorage.getItem("darkmode:color-scheme")||"system",theme=="system"&&(window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?theme="dark":theme="light"),document.documentElement.setAttribute("data-theme",theme)</script></head><body class="type-notes kind-page" data-spy=scroll data-target=#TableOfContents data-offset=80><div class="container-fluid bg-secondary wrapper"><nav class="navbar navbar-expand-xl top-navbar shadow" id=top-navbar><div class=container><button class="navbar-toggler navbar-light" id=sidebar-toggler type=button>
<i data-feather=sidebar></i>
</button>
<a class=navbar-brand href=/><img src=/images/ormissia_hu763a76473558eea2a316ef50b45aaecf_966068_42x0_resize_box_3.png id=logo alt=Logo>
Ormissia's Blog</a>
<button class="navbar-toggler navbar-light" id=navbar-toggler type=button data-toggle=collapse data-target=#top-nav-items aria-label=menu>
<i data-feather=menu></i></button><div class="collapse navbar-collapse dynamic-navbar" id=top-nav-items><ul class="nav navbar-nav ml-auto"><li class=nav-item><a class=nav-link href=/#home>主页</a></li><li class=nav-item><a class=nav-link href=/#about>技能</a></li><li class=nav-item><a class=nav-link href=/#recent-posts>最近</a></li><li class=nav-item><a class=nav-link href=/#education>历程</a></li><li class=nav-item><a class=nav-link href=/#projects>项目</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>更多的</a><div class=dropdown-menu aria-labelledby=navbarDropdown><a class=dropdown-item href=/#achievements>成就</a></div></li><div id=top-navbar-divider></div><li class=nav-item><a class=nav-link id=blog-link href=/posts>博文</a></li><li class=nav-item><a class=nav-link id=note-link href=/notes>笔记</a></li><li class=nav-item><a class=nav-link href=https://github.com/ormissia>GitHub</a></li></ul></div></div><img src=/images/ormissia_hu763a76473558eea2a316ef50b45aaecf_966068_42x0_resize_box_3.png class=d-none id=main-logo alt=Logo>
<img src=/images/ormissia_hu763a76473558eea2a316ef50b45aaecf_966068_42x0_resize_box_3.png class=d-none id=inverted-logo alt="Inverted Logo"></nav><section class=sidebar-section id=sidebar-section><div class=sidebar-holder><div class=sidebar id=sidebar><form class=mx-auto method=get action=/search><input type=text name=keyword placeholder=搜索 data-search id=search-box></form><div class=sidebar-tree><ul class=tree id=tree><li id=list-heading><a href=/notes data-filter=all>笔记</a></li><div class=subtree><li><i data-feather=plus-circle></i><a class=list-link href=/notes/go/> Go</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/go/basic/> Basics</a><ul><li><a class=list-link href=/notes/go/basic/basic/ title=Basic>Basic</a></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/go/advance/> Advance</a><ul><li><a class=list-link href=/notes/go/advance/time/ title=time>time</a></li><li><a class=list-link href=/notes/go/advance/gomod/ title="go mod">go mod</a></li><li><a class=list-link href=/notes/go/advance/chan/ title="go chan">go chan</a></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/go/algorithm/> Algorithm</a><ul><li><a class=list-link href=/notes/go/algorithm/basic/ title=Basic>Basic</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/java/> Java</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/java/basic/> Basics</a><ul><li><a class=list-link href=/notes/java/basic/basic_type/ title="Basic Types">Basic Types</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/scala/> Scala</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/scala/basic/> Basic</a><ul><li><a class=list-link href=/notes/scala/basic/basic_type/ title="Basic Types">Basic Types</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/python/> Python</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/python/basic/> Basic</a><ul><li><a class=list-link href=/notes/python/basic/basic/ title=Basic>Basic</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/js/> JavaScript</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/js/basic/> Basic</a><ul><li><a class=list-link href=/notes/js/basic/basic/ title=Basic>Basic</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/sql/> SQL</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/sql/dml/> DML</a><ul><li><a class=list-link href=/notes/sql/dml/dml/ title="SQL DML">SQL DML</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/linux/> Linux</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/linux/shell/> Shell</a><ul><li><a class=list-link href=/notes/linux/shell/basic/ title=Basic>Basic</a></li><li><a class=list-link href=/notes/linux/shell/advance/ title=Advance>Advance</a></li><li><a class=list-link href=/notes/linux/shell/vi/ title=vi>vi</a></li><li><a class=list-link href=/notes/linux/shell/script/ title=Script>Script</a></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/linux/system/> System</a><ul><li><a class=list-link href=/notes/linux/system/system/ title=Memory>Memory</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/hbase/> Hbase</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/hbase/shell/> Shell</a><ul><li><a class=list-link href=/notes/hbase/shell/basic/ title=Basic>Basic</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/kafka/> Kafka</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/kafka/shell/> Shell</a><ul><li><a class=list-link href=/notes/kafka/shell/basic/ title=Basic>Basic</a></li></ul></li></ul></li></div></ul></div></div></div></section><section class=content-section id=content-section><div class="content container-fluid" id=content><div class="container-fluid note-card-holder" id=note-card-holder><h1 id=go-gmp-调度模型>Go GMP 调度模型</h1><p>#go #golang #gmp #scheduler #抢占式调度 #goroutine #协程 #gmp</p><blockquote><p>所谓 <code>GMP</code>，其中 <code>G</code> 是指 <code>goroutine</code>；<code>M</code> 是 <code>Machine</code> 的缩写，指的是工作线程；<code>P</code> 则是指处理器 <code>Processor</code>，代表了一组资源，<code>M</code> 要想执行 <code>G</code> 的代码，必须持有一个 <code>P</code> 才行。</p></blockquote><blockquote><p>简单来说，<code>GMP</code> 就是 <code>Task</code>、<code>Worker</code>、<code>Resource</code> 的关系，<code>G</code> 和 <code>P</code> 都是 <code>Go</code> 语言实现的抽象程度更高的组件，对于工作线程而言，<code>Machine</code> 一词表明了它与具体的操作系统和平台密切相关，对具体平台的适配和特殊处理等大多在这一层实现。</p></blockquote><h2 id=从-gm-到-gmp>从 GM 到 GMP</h2><h3 id=gm-模型调度的几个明显问题>GM 模型调度的几个明显问题</h3><ol><li>用一个全局的 <code>mutex</code> 保护一个全局的 <code>runq</code>（就绪队列），造成对锁的竞争异常严重</li><li><code>G</code> 每次执行都会被分发到随机的 <code>M</code> 上，造成在不同 <code>M</code> 之间频繁切换，破坏了程序的局部性</li><li>每个 <code>M</code> 都会关联一个内存分配缓存 <code>mcache</code>，造成大量内存开销，进一步使数据的局部性变差。实际上只有执行 <code>Go</code> 代码的 <code>M</code> 才真正需要 <code>mcache</code>，那些阻塞在系统调用中的 <code>M</code> 根本不需要，而实际执行 <code>Go</code> 代码的 <code>M</code> 可能仅占总数的 <code>1%</code></li><li>在存在系统调用的情况下，工作线程经常被阻塞和解除阻塞，从而增加了很多开销</li></ol><blockquote><p>通过 <code>runtime.GOMAXPROCS()</code> 函数可以精准的控制 <code>P</code> 的个数</p></blockquote><h2 id=gmp-的数据结构>GMP 的数据结构</h2><h3 id=g>G</h3><h4 id=源码>源码</h4><p><code>runtime.g</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>g</span> <span style=color:#66d9ef>struct</span> {  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// Stack parameters.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// stack describes the actual stack memory: [stack.lo, stack.hi).  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// stackguard0 is the stack pointer compared in the Go stack growth prologue.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// stackguard1 is the stack pointer compared in the C stack growth prologue.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// It is stack.lo+StackGuard on g0 and gsignal stacks.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// It is ~0 on other goroutine stacks, to trigger a call to morestackc (and crash).  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>stack</span>       <span style=color:#a6e22e>stack</span>   <span style=color:#75715e>// offset known to runtime/cgo  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>stackguard0</span> <span style=color:#66d9ef>uintptr</span> <span style=color:#75715e>// offset known to liblink  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>stackguard1</span> <span style=color:#66d9ef>uintptr</span> <span style=color:#75715e>// offset known to liblink  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>_panic</span>    <span style=color:#f92672>*</span><span style=color:#a6e22e>_panic</span> <span style=color:#75715e>// innermost panic - offset known to liblink  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>_defer</span>    <span style=color:#f92672>*</span><span style=color:#a6e22e>_defer</span> <span style=color:#75715e>// innermost defer  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>m</span>         <span style=color:#f92672>*</span><span style=color:#a6e22e>m</span>      <span style=color:#75715e>// current m; offset known to arm liblink  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>sched</span>     <span style=color:#a6e22e>gobuf</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>syscallsp</span> <span style=color:#66d9ef>uintptr</span> <span style=color:#75715e>// if status==Gsyscall, syscallsp = sched.sp to use during gc   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>syscallpc</span> <span style=color:#66d9ef>uintptr</span> <span style=color:#75715e>// if status==Gsyscall, syscallpc = sched.pc to use during gc   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>stktopsp</span>  <span style=color:#66d9ef>uintptr</span> <span style=color:#75715e>// expected sp at top of stack, to check in traceback  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// param is a generic pointer parameter field used to pass   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// values in particular contexts where other storage for the   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// parameter would be difficult to find. It is currently used   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// in three ways:   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// 1. When a channel operation wakes up a blocked goroutine, it sets param to   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>//    point to the sudog of the completed blocking operation.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// 2. By gcAssistAlloc1 to signal back to its caller that the goroutine completed   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>//    the GC cycle. It is unsafe to do so in any other way, because the goroutine&#39;s   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>//    stack may have moved in the meantime.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// 3. By debugCallWrap to pass parameters to a new goroutine because allocating a   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>//    closure in the runtime is forbidden.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>param</span>        <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>atomicstatus</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Uint32</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>stackLock</span>    <span style=color:#66d9ef>uint32</span> <span style=color:#75715e>// sigprof/scang lock; TODO: fold in to atomicstatus  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>goid</span>         <span style=color:#66d9ef>uint64</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>schedlink</span>    <span style=color:#a6e22e>guintptr</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>waitsince</span>    <span style=color:#66d9ef>int64</span>      <span style=color:#75715e>// approx time when the g become blocked   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>waitreason</span>   <span style=color:#a6e22e>waitReason</span> <span style=color:#75715e>// if status==Gwaiting  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>preempt</span>       <span style=color:#66d9ef>bool</span> <span style=color:#75715e>// preemption signal, duplicates stackguard0 = stackpreempt   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>preemptStop</span>   <span style=color:#66d9ef>bool</span> <span style=color:#75715e>// transition to _Gpreempted on preemption; otherwise, just 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>deschedule</span>   <span style=color:#a6e22e>preemptShrink</span> <span style=color:#66d9ef>bool</span> <span style=color:#75715e>// shrink stack at synchronous safe point  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// asyncSafePoint is set if g is stopped at an asynchronous   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// safe point. This means there are frames on the stack  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// without precise pointer information.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>asyncSafePoint</span> <span style=color:#66d9ef>bool</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>paniconfault</span> <span style=color:#66d9ef>bool</span> <span style=color:#75715e>// panic (instead of crash) on unexpected fault address  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>gcscandone</span>   <span style=color:#66d9ef>bool</span> <span style=color:#75715e>// g has scanned stack; protected by _Gscan bit in status   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>throwsplit</span>   <span style=color:#66d9ef>bool</span> <span style=color:#75715e>// must not split stack  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// activeStackChans indicates that there are unlocked channels   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// pointing into this goroutine&#39;s stack. If true, stack  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// copying needs to acquire channel locks to protect these  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// areas of the stack.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>activeStackChans</span> <span style=color:#66d9ef>bool</span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// parkingOnChan indicates that the goroutine is about to   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// park on a chansend or chanrecv. Used to signal an unsafe point  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// for stack shrinking.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>parkingOnChan</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Bool</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>raceignore</span>     <span style=color:#66d9ef>int8</span>     <span style=color:#75715e>// ignore race detection events  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>sysblocktraced</span> <span style=color:#66d9ef>bool</span>     <span style=color:#75715e>// StartTrace has emitted EvGoInSyscall about this goroutine   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>tracking</span>       <span style=color:#66d9ef>bool</span>     <span style=color:#75715e>// whether we&#39;re tracking this G for sched latency statistics   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>trackingSeq</span>    <span style=color:#66d9ef>uint8</span>    <span style=color:#75715e>// used to decide whether to track this G  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>trackingStamp</span>  <span style=color:#66d9ef>int64</span>    <span style=color:#75715e>// timestamp of when the G last started being tracked  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>runnableTime</span>   <span style=color:#66d9ef>int64</span>    <span style=color:#75715e>// the amount of time spent runnable, cleared when running, only used when tracking  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>sysexitticks</span>   <span style=color:#66d9ef>int64</span>    <span style=color:#75715e>// cputicks when syscall has returned (for tracing)   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>traceseq</span>       <span style=color:#66d9ef>uint64</span>   <span style=color:#75715e>// trace event sequencer   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>tracelastp</span>     <span style=color:#a6e22e>puintptr</span> <span style=color:#75715e>// last P emitted an event for this goroutine  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>lockedm</span>        <span style=color:#a6e22e>muintptr</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>sig</span>            <span style=color:#66d9ef>uint32</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>writebuf</span>       []<span style=color:#66d9ef>byte</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>sigcode0</span>       <span style=color:#66d9ef>uintptr</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>sigcode1</span>       <span style=color:#66d9ef>uintptr</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>sigpc</span>          <span style=color:#66d9ef>uintptr</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>gopc</span>           <span style=color:#66d9ef>uintptr</span>         <span style=color:#75715e>// pc of go statement that created this goroutine  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>ancestors</span>      <span style=color:#f92672>*</span>[]<span style=color:#a6e22e>ancestorInfo</span> <span style=color:#75715e>// ancestor information goroutine(s) that created this goroutine (only used if debug.tracebackancestors)  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>startpc</span>        <span style=color:#66d9ef>uintptr</span>         <span style=color:#75715e>// pc of goroutine function  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>racectx</span>        <span style=color:#66d9ef>uintptr</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>waiting</span>        <span style=color:#f92672>*</span><span style=color:#a6e22e>sudog</span>         <span style=color:#75715e>// sudog structures this g is waiting on (that have a valid elem ptr); in lock order   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>cgoCtxt</span>        []<span style=color:#66d9ef>uintptr</span>      <span style=color:#75715e>// cgo traceback context   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>labels</span>         <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> <span style=color:#75715e>// profiler labels  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>timer</span>          <span style=color:#f92672>*</span><span style=color:#a6e22e>timer</span>         <span style=color:#75715e>// cached timer for time.Sleep  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>selectDone</span>     <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Uint32</span>  <span style=color:#75715e>// are we participating in a select and did someone win the race?  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// goroutineProfiled indicates the status of this goroutine&#39;s stack for the   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// current in-progress goroutine profile   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>goroutineProfiled</span> <span style=color:#a6e22e>goroutineProfileStateHolder</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// Per-G GC state  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// gcAssistBytes is this G&#39;s GC assist credit in terms of   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// bytes allocated. If this is positive, then the G has credit   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// to allocate gcAssistBytes bytes without assisting. If this   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// is negative, then the G must correct this by performing   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// scan work. We track this in bytes to make it fast to update   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// and check for debt in the malloc hot path. The assist ratio   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// determines how this corresponds to scan work debt.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>gcAssistBytes</span> <span style=color:#66d9ef>int64</span>  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=部分字段用途>部分字段用途</h4><ul><li><code>stack</code>：描述了 <code>goroutine</code> 的栈空间</li><li><code>stackguard0</code>：</li><li><code>stackguard1</code>：原理同 <code>stackguard0</code> 差不多，只不过是被 <code>g0</code> 和 <code>gsignal</code> 中的 <code>C</code> 代码使用</li><li><code>m</code>：关联到正在执行当前 <code>G</code> 的工作线程 <code>M</code></li><li><code>sched</code>：被调度器用来保存 goroutine 的执行上下文</li><li><code>atomicstatus</code>：用来表示当前 <code>G</code> 的状态</li><li><code>goid</code>：当前 <code>goroutine</code> 的全局唯一 ID</li><li><code>schedlink</code>：被调度器用于实现内部链表、队列，对应的 <code>gunitptr</code> 类型从逻辑上等价于 <code>*g</code>，而底层类型却是个 <code>uintptr</code>，这样是为了避免写障碍</li><li><code>preempt</code>：为 <code>true</code> 时，调度器会在合适的时机触发一次抢占</li><li><code>lockedm</code>：关联到与当前 <code>G</code> 绑定的 <code>M</code>，可参考 <code>LockOSThread</code></li><li><code>waiting</code>：主要用于实现 <code>channel</code> 中的等待队列</li><li><code>timer</code>：<code>runtime</code> 内部实现的计时器类型，主要用来支持 <code>time.Sleep</code></li></ul><h4 id=atomicstatus-字段的取值及其含义>atomicstatus 字段的取值及其含义</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>const</span> (  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// G status  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>//   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// Beyond indicating the general state of a G, the G status   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// acts like a lock on the goroutine&#39;s stack (and hence its   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// ability to execute user code).   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>//   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// If you add to this list, add to the list   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// of &#34;okay during garbage collection&#34; status   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// in mgcmark.go too.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>//   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// TODO(austin): The _Gscan bit could be much lighter-weight.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// For example, we could choose not to run _Gscanrunnable   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// goroutines found in the run queue, rather than CAS-looping   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// until they become _Grunnable. And transitions like   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// _Gscanwaiting -&gt; _Gscanrunnable are actually okay because   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// they don&#39;t affect stack ownership.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// _Gidle means this goroutine was just allocated and has not   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// yet been initialized.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>_Gidle</span> = <span style=color:#66d9ef>iota</span> <span style=color:#75715e>// 0  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// _Grunnable means this goroutine is on a run queue. It is   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// not currently executing user code. The stack is not owned.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>_Grunnable</span> <span style=color:#75715e>// 1  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// _Grunning means this goroutine may execute user code. The   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// stack is owned by this goroutine. It is not on a run queue.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// It is assigned an M and a P (g.m and g.m.p are valid).   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>_Grunning</span> <span style=color:#75715e>// 2  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// _Gsyscall means this goroutine is executing a system call.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// It is not executing user code. The stack is owned by this   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// goroutine. It is not on a run queue. It is assigned an M.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>_Gsyscall</span> <span style=color:#75715e>// 3  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// _Gwaiting means this goroutine is blocked in the runtime.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// It is not executing user code. It is not on a run queue,   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// but should be recorded somewhere (e.g., a channel wait   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// queue) so it can be ready()d when necessary. The stack is   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// not owned *except* that a channel operation may read or   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// write parts of the stack under the appropriate channel   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// lock. Otherwise, it is not safe to access the stack after a   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// goroutine enters _Gwaiting (e.g., it may get moved).   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>_Gwaiting</span> <span style=color:#75715e>// 4  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// _Gmoribund_unused is currently unused, but hardcoded in gdb   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// scripts.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>_Gmoribund_unused</span> <span style=color:#75715e>// 5  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// _Gdead means this goroutine is currently unused. It may be   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// just exited, on a free list, or just being initialized. It   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// is not executing user code. It may or may not have a stack  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// allocated. The G and its stack (if any) are owned by the M   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// that is exiting the G or that obtained the G from the free   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// list.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>_Gdead</span> <span style=color:#75715e>// 6  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// _Genqueue_unused is currently unused.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>_Genqueue_unused</span> <span style=color:#75715e>// 7  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// _Gcopystack means this goroutine&#39;s stack is being moved. It   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// is not executing user code and is not on a run queue. The   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// stack is owned by the goroutine that put it in _Gcopystack.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>_Gcopystack</span> <span style=color:#75715e>// 8  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// _Gpreempted means this goroutine stopped itself for a   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// suspendG preemption. It is like _Gwaiting, but nothing is  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// yet responsible for ready()ing it. Some suspendG must CAS   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// the status to _Gwaiting to take responsibility for   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// ready()ing this G.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>_Gpreempted</span> <span style=color:#75715e>// 9  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// _Gscan combined with one of the above states other than   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// _Grunning indicates that GC is scanning the stack. The  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// goroutine is not executing user code and the stack is owned   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// by the goroutine that set the _Gscan bit.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>//   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// _Gscanrunning is different: it is used to briefly block  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// state transitions while GC signals the G to scan its own   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// stack. This is otherwise like _Grunning.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>//   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// atomicstatus&amp;~Gscan gives the state the goroutine will   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// return to when the scan completes.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>_Gscan</span>          = <span style=color:#ae81ff>0x1000</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>_Gscanrunnable</span>  = <span style=color:#a6e22e>_Gscan</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>_Grunnable</span>  <span style=color:#75715e>// 0x1001  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>_Gscanrunning</span>   = <span style=color:#a6e22e>_Gscan</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>_Grunning</span>   <span style=color:#75715e>// 0x1002  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>_Gscansyscall</span>   = <span style=color:#a6e22e>_Gscan</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>_Gsyscall</span>   <span style=color:#75715e>// 0x1003  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>_Gscanwaiting</span>   = <span style=color:#a6e22e>_Gscan</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>_Gwaiting</span>   <span style=color:#75715e>// 0x1004  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>_Gscanpreempted</span> = <span style=color:#a6e22e>_Gscan</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>_Gpreempted</span> <span style=color:#75715e>// 0x1009  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>)
</span></span></code></pre></div><ul><li></li></ul><p>G 几种暂停的方式：</p><ul><li><code>gosched</code>：将当前的 <code>G</code> 暂停，保存堆栈状态，以 <code>_Grunable</code> 状态放入 Global 队列中，让当前 <code>M</code> 继续执行其他任务。无需对 <code>G</code> 执行唤醒操作，因为总会有 <code>M</code> 从 Global 队列取得并执行 G，抢占调度即使用该方式。</li><li><code>gopark</code>：与 <code>gosched</code> 的最大区别在于 <code>gopark</code> 没有将 <code>G</code> 放回执行队列，而是位于某个等待队列中（如 <code>channel</code> 的 <code>waitq</code>，此时 <code>G</code> 状态为 <code>_Gwaitting</code>）, 因此 <code>G</code> 必须被手动唤醒（通过 <code>goready</code>），否则会丢失任务。应用层阻塞通常使用这种方式。</li><li><code>notesleep</code>：既不让出 <code>M</code>，也不让 <code>G</code> 和 <code>P</code> 重新调度，直接让线程休眠直到被唤醒（<code>notewakeup</code>），该方式更快，通常用于 <code>gcMark</code>，<code>stopm</code> 这类自旋场景。</li><li><code>notesleepg</code>：阻塞 <code>G</code> 和 <code>M</code>，放开 <code>P</code>，<code>P</code> 可以和其它 <code>M</code> 绑定继续执行，比如可能阻塞的系统调用会主动调用 <code>entersyscallblock</code>，则会触发 <code>notesleepg</code>。</li><li><code>goexit</code>：立即终止 <code>G</code> 任务，不管其处于调用堆栈的哪个层次，在终止前，确保所有 <code>defer</code> 正确执行。</li></ul><h3 id=m>M</h3><h4 id=源码-1>源码</h4><p><code>runtime.m</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>m</span> <span style=color:#66d9ef>struct</span> {  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>g0</span>      <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>     <span style=color:#75715e>// goroutine with scheduling stack  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>morebuf</span> <span style=color:#a6e22e>gobuf</span>  <span style=color:#75715e>// gobuf arg to morestack  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>divmod</span>  <span style=color:#66d9ef>uint32</span> <span style=color:#75715e>// div/mod denominator for arm - known to liblink  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>_</span>       <span style=color:#66d9ef>uint32</span> <span style=color:#75715e>// align next field to 8 bytes  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// Fields not known to debuggers.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>procid</span>        <span style=color:#66d9ef>uint64</span>            <span style=color:#75715e>// for debuggers, but offset not hard-coded  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>gsignal</span>       <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>                <span style=color:#75715e>// signal-handling g  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>goSigStack</span>    <span style=color:#a6e22e>gsignalStack</span>      <span style=color:#75715e>// Go-allocated signal handling stack  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>sigmask</span>       <span style=color:#a6e22e>sigset</span>            <span style=color:#75715e>// storage for saved signal mask  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>tls</span>           [<span style=color:#a6e22e>tlsSlots</span>]<span style=color:#66d9ef>uintptr</span> <span style=color:#75715e>// thread-local storage (for x86 extern register)  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>mstartfn</span>      <span style=color:#66d9ef>func</span>()  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>curg</span>          <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>       <span style=color:#75715e>// current running goroutine  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>caughtsig</span>     <span style=color:#a6e22e>guintptr</span> <span style=color:#75715e>// goroutine running during fatal signal   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>p</span>             <span style=color:#a6e22e>puintptr</span> <span style=color:#75715e>// attached p for executing go code (nil if not executing go code)   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>nextp</span>         <span style=color:#a6e22e>puintptr</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>oldp</span>          <span style=color:#a6e22e>puintptr</span> <span style=color:#75715e>// the p that was attached before executing a syscall  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>id</span>            <span style=color:#66d9ef>int64</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>mallocing</span>     <span style=color:#66d9ef>int32</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>throwing</span>      <span style=color:#a6e22e>throwType</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>preemptoff</span>    <span style=color:#66d9ef>string</span> <span style=color:#75715e>// if != &#34;&#34;, keep curg running on this m  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>locks</span>         <span style=color:#66d9ef>int32</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>dying</span>         <span style=color:#66d9ef>int32</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>profilehz</span>     <span style=color:#66d9ef>int32</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>spinning</span>      <span style=color:#66d9ef>bool</span> <span style=color:#75715e>// m is out of work and is actively looking for work  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>blocked</span>       <span style=color:#66d9ef>bool</span> <span style=color:#75715e>// m is blocked on a note  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>newSigstack</span>   <span style=color:#66d9ef>bool</span> <span style=color:#75715e>// minit on C thread called sigaltstack  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>printlock</span>     <span style=color:#66d9ef>int8</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>incgo</span>         <span style=color:#66d9ef>bool</span>          <span style=color:#75715e>// m is executing a cgo call   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>isextra</span>       <span style=color:#66d9ef>bool</span>          <span style=color:#75715e>// m is an extra m  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>freeWait</span>      <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Uint32</span> <span style=color:#75715e>// Whether it is safe to free g0 and delete m (one of freeMRef, freeMStack, freeMWait)  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>fastrand</span>      <span style=color:#66d9ef>uint64</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>needextram</span>    <span style=color:#66d9ef>bool</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>traceback</span>     <span style=color:#66d9ef>uint8</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>ncgocall</span>      <span style=color:#66d9ef>uint64</span>        <span style=color:#75715e>// number of cgo calls in total  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>ncgo</span>          <span style=color:#66d9ef>int32</span>         <span style=color:#75715e>// number of cgo calls currently in progress  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>cgoCallersUse</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Uint32</span> <span style=color:#75715e>// if non-zero, cgoCallers in use temporarily   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>cgoCallers</span>    <span style=color:#f92672>*</span><span style=color:#a6e22e>cgoCallers</span>   <span style=color:#75715e>// cgo traceback if crashing in cgo call   park          note  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>alllink</span>       <span style=color:#f92672>*</span><span style=color:#a6e22e>m</span> <span style=color:#75715e>// on allm  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>schedlink</span>     <span style=color:#a6e22e>muintptr</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>lockedg</span>       <span style=color:#a6e22e>guintptr</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>createstack</span>   [<span style=color:#ae81ff>32</span>]<span style=color:#66d9ef>uintptr</span> <span style=color:#75715e>// stack that created this thread.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>lockedExt</span>     <span style=color:#66d9ef>uint32</span>      <span style=color:#75715e>// tracking for external LockOSThread  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>lockedInt</span>     <span style=color:#66d9ef>uint32</span>      <span style=color:#75715e>// tracking for internal lockOSThread  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>nextwaitm</span>     <span style=color:#a6e22e>muintptr</span>    <span style=color:#75715e>// next m waiting for lock  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>waitunlockf</span>   <span style=color:#66d9ef>func</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>, <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>) <span style=color:#66d9ef>bool</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>waitlock</span>      <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>waittraceev</span>   <span style=color:#66d9ef>byte</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>waittraceskip</span> <span style=color:#66d9ef>int</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>startingtrace</span> <span style=color:#66d9ef>bool</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>syscalltick</span>   <span style=color:#66d9ef>uint32</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>freelink</span>      <span style=color:#f92672>*</span><span style=color:#a6e22e>m</span> <span style=color:#75715e>// on sched.freem  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// these are here because they are too large to be on the stack  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// of low-level NOSPLIT functions.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>libcall</span>   <span style=color:#a6e22e>libcall</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>libcallpc</span> <span style=color:#66d9ef>uintptr</span> <span style=color:#75715e>// for cpu profiler  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>libcallsp</span> <span style=color:#66d9ef>uintptr</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>libcallg</span>  <span style=color:#a6e22e>guintptr</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>syscall</span>   <span style=color:#a6e22e>libcall</span> <span style=color:#75715e>// stores syscall parameters on windows  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>vdsoSP</span> <span style=color:#66d9ef>uintptr</span> <span style=color:#75715e>// SP for traceback while in VDSO call (0 if not in call)   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>vdsoPC</span> <span style=color:#66d9ef>uintptr</span> <span style=color:#75715e>// PC for traceback while in VDSO call  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   
</span></span><span style=display:flex><span>   <span style=color:#75715e>// preemptGen counts the number of completed preemption   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// signals. This is used to detect when a preemption is   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// requested, but fails.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>preemptGen</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Uint32</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// Whether this is a pending preemption signal on this M.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>signalPending</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Uint32</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>dlogPerM</span>  
</span></span><span style=display:flex><span>   
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>mOS</span>  
</span></span><span style=display:flex><span>   
</span></span><span style=display:flex><span>   <span style=color:#75715e>// Up to 10 locks held by this m, maintained by the lock ranking code.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>locksHeldLen</span> <span style=color:#66d9ef>int</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>locksHeld</span>    [<span style=color:#ae81ff>10</span>]<span style=color:#a6e22e>heldLockInfo</span>  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=部分字段用途-1>部分字段用途</h4><ul><li><code>g0</code>：并不是一个真正的 <code>goroutine</code>，他的栈是由操作系统分配的，初始大小比普通 <code>goroutine</code> 的栈要大，被用作调度器执行的栈</li><li><code>gsignal</code>：本质上是用来处理信号的栈，因为一些 <code>UNIX</code> 系统支持位信号处理器配置独立的栈</li><li><code>curg </code>：指向 <code>M </code>当前正在执行的 <code>G</code></li><li><code>p</code>：<code>GMP</code> 中的 <code>P</code>，即关联当当前 <code>M</code> 上的处理器</li><li><code>nextp</code>：用来将 <code>P</code> 传递给 <code>M</code>，调度器一般是在 <code>M</code> 阻塞时为 <code>m.nextp</code> 赋值，等到 <code>M</code> 开始运行后会尝试从 <code>nextp</code> 处获取 <code>P</code> 进行关联</li><li><code>oldp</code>：用来暂存执行系统调用之前关联的 <code>P</code></li><li><code>id</code>：<code>M</code> 的唯一 <code>ID</code></li><li><code>preemptoff</code>：不为空时表示要关闭对 <code>curg</code> 的抢占，字符串内容给出了相关的原因</li><li><code>locks</code>：记录了当前 <code>M</code> 持有的锁数量，不为 0 时能够阻止抢占发生</li><li><code>spinning</code>：表示当前 <code>M</code> 正处于自旋状态</li><li><code>park</code>：用来支持 <code>M</code> 的挂起与唤醒，可以很方便的实现每个 <code>M</code> 的单独挂起与唤醒</li><li><code>alllink</code>：把所有的 <code>M</code> 连起来，构成 <code>allm</code> 链表</li><li><code>schedlink</code>：被调度器用来实现链表，如空闲的 <code>M</code> 链表</li><li><code>lockedg</code>：关联到与当前 <code>M</code> 绑定的 <code>G</code>，可参考 <code>LockOSThread</code></li><li><code>freelink</code>：用来把已经退出运行的 <code>M</code> 连起来，构成 <code>sched.freem</code> 链表，方便下次分配时复用</li></ul><h3 id=p>P</h3><h4 id=源码-2>源码</h4><p><code>runtime.p</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>p</span> <span style=color:#66d9ef>struct</span> {  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>id</span>          <span style=color:#66d9ef>int32</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>status</span>      <span style=color:#66d9ef>uint32</span> <span style=color:#75715e>// one of pidle/prunning/...  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>link</span>        <span style=color:#a6e22e>puintptr</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>schedtick</span>   <span style=color:#66d9ef>uint32</span>     <span style=color:#75715e>// incremented on every scheduler call  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>syscalltick</span> <span style=color:#66d9ef>uint32</span>     <span style=color:#75715e>// incremented on every system call  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>sysmontick</span>  <span style=color:#a6e22e>sysmontick</span> <span style=color:#75715e>// last tick observed by sysmon  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>m</span>           <span style=color:#a6e22e>muintptr</span>   <span style=color:#75715e>// back-link to associated m (nil if idle)   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>mcache</span>      <span style=color:#f92672>*</span><span style=color:#a6e22e>mcache</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>pcache</span>      <span style=color:#a6e22e>pageCache</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>raceprocctx</span> <span style=color:#66d9ef>uintptr</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>deferpool</span>    []<span style=color:#f92672>*</span><span style=color:#a6e22e>_defer</span> <span style=color:#75715e>// pool of available defer structs (see panic.go)  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>deferpoolbuf</span> [<span style=color:#ae81ff>32</span>]<span style=color:#f92672>*</span><span style=color:#a6e22e>_defer</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// Cache of goroutine ids, amortizes accesses to runtime·sched.goidgen.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>goidcache</span>    <span style=color:#66d9ef>uint64</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>goidcacheend</span> <span style=color:#66d9ef>uint64</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// Queue of runnable goroutines. Accessed without lock.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>runqhead</span> <span style=color:#66d9ef>uint32</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>runqtail</span> <span style=color:#66d9ef>uint32</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>runq</span>     [<span style=color:#ae81ff>256</span>]<span style=color:#a6e22e>guintptr</span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// runnext, if non-nil, is a runnable G that was ready&#39;d by  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// the current G and should be run next instead of what&#39;s in   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// runq if there&#39;s time remaining in the running G&#39;s time   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// slice. It will inherit the time left in the current time  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// slice. If a set of goroutines is locked in a  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// communicate-and-wait pattern, this schedules that set as a   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// unit and eliminates the (potentially large) scheduling   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// latency that otherwise arises from adding the ready&#39;d  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// goroutines to the end of the run queue.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>//   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// Note that while other P&#39;s may atomically CAS this to zero,   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// only the owner P can CAS it to a valid G.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>runnext</span> <span style=color:#a6e22e>guintptr</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// Available G&#39;s (status == Gdead)   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>gFree</span> <span style=color:#66d9ef>struct</span> {  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>gList</span>  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>n</span> <span style=color:#66d9ef>int32</span>  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>sudogcache</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>sudog</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>sudogbuf</span>   [<span style=color:#ae81ff>128</span>]<span style=color:#f92672>*</span><span style=color:#a6e22e>sudog</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// Cache of mspan objects from the heap.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>mspancache</span> <span style=color:#66d9ef>struct</span> {  
</span></span><span style=display:flex><span>      <span style=color:#75715e>// We need an explicit length here because this field is used  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>// in allocation codepaths where write barriers are not allowed,      
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>// and eliminating the write barrier/keeping it eliminated from      
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>// slice updates is tricky, moreso than just managing the length      
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>// ourselves.      
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#a6e22e>len</span> <span style=color:#66d9ef>int</span>  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>buf</span> [<span style=color:#ae81ff>128</span>]<span style=color:#f92672>*</span><span style=color:#a6e22e>mspan</span>  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>tracebuf</span> <span style=color:#a6e22e>traceBufPtr</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// traceSweep indicates the sweep events should be traced.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// This is used to defer the sweep start event until a span   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// has actually been swept.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>traceSweep</span> <span style=color:#66d9ef>bool</span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// traceSwept and traceReclaimed track the number of bytes  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// swept and reclaimed by sweeping in the current sweep loop.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>traceSwept</span>, <span style=color:#a6e22e>traceReclaimed</span> <span style=color:#66d9ef>uintptr</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>palloc</span> <span style=color:#a6e22e>persistentAlloc</span> <span style=color:#75715e>// per-P to avoid mutex  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// The when field of the first entry on the timer heap.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// This is 0 if the timer heap is empty.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>timer0When</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Int64</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// The earliest known nextwhen field of a timer with   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// timerModifiedEarlier status. Because the timer may have been   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// modified again, there need not be any timer with this value.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// This is 0 if there are no timerModifiedEarlier timers.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>timerModifiedEarliest</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Int64</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// Per-P GC state   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>gcAssistTime</span>         <span style=color:#66d9ef>int64</span> <span style=color:#75715e>// Nanoseconds in assistAlloc  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>gcFractionalMarkTime</span> <span style=color:#66d9ef>int64</span> <span style=color:#75715e>// Nanoseconds in fractional mark worker (atomic)  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// limiterEvent tracks events for the GC CPU limiter.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>limiterEvent</span> <span style=color:#a6e22e>limiterEvent</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// gcMarkWorkerMode is the mode for the next mark worker to run in.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// That is, this is used to communicate with the worker goroutine   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// selected for immediate execution by   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// gcController.findRunnableGCWorker. When scheduling other goroutines,   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// this field must be set to gcMarkWorkerNotWorker.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>gcMarkWorkerMode</span> <span style=color:#a6e22e>gcMarkWorkerMode</span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// gcMarkWorkerStartTime is the nanotime() at which the most recent  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// mark worker started.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>gcMarkWorkerStartTime</span> <span style=color:#66d9ef>int64</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// gcw is this P&#39;s GC work buffer cache. The work buffer is   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// filled by write barriers, drained by mutator assists, and   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// disposed on certain GC state transitions.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>gcw</span> <span style=color:#a6e22e>gcWork</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// wbBuf is this P&#39;s GC write barrier buffer.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>//   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// TODO: Consider caching this in the running G.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>wbBuf</span> <span style=color:#a6e22e>wbBuf</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>runSafePointFn</span> <span style=color:#66d9ef>uint32</span> <span style=color:#75715e>// if 1, run sched.safePointFn at next safe point  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// statsSeq is a counter indicating whether this P is currently   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// writing any stats. Its value is even when not, odd when it is.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>statsSeq</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Uint32</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// Lock for timers. We normally access the timers while running   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// on this P, but the scheduler can also do it from a different P.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>timersLock</span> <span style=color:#a6e22e>mutex</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// Actions to take at some time. This is used to implement the  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// standard library&#39;s time package.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// Must hold timersLock to access.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>timers</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>timer</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// Number of timers in P&#39;s heap.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>numTimers</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Uint32</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// Number of timerDeleted timers in P&#39;s heap.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>deletedTimers</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Uint32</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// Race context used while executing timer functions.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>timerRaceCtx</span> <span style=color:#66d9ef>uintptr</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// maxStackScanDelta accumulates the amount of stack space held by   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// live goroutines (i.e. those eligible for stack scanning).   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// Flushed to gcController.maxStackScan once maxStackScanSlack  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// or -maxStackScanSlack is reached.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>maxStackScanDelta</span> <span style=color:#66d9ef>int64</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// gc-time statistics about current goroutines  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// Note that this differs from maxStackScan in that this   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// accumulates the actual stack observed to be used at GC time (hi - sp),   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// not an instantaneous measure of the total stack size that might need   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// to be scanned (hi - lo).   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>scannedStackSize</span> <span style=color:#66d9ef>uint64</span> <span style=color:#75715e>// stack size of goroutines scanned by this P   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>scannedStacks</span>    <span style=color:#66d9ef>uint64</span> <span style=color:#75715e>// number of goroutines scanned by this P  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// preempt is set to indicate that this P should be enter the   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// scheduler ASAP (regardless of what G is running on it).   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>preempt</span> <span style=color:#66d9ef>bool</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// pageTraceBuf is a buffer for writing out page allocation/free/scavenge traces.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>//   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// Used only if GOEXPERIMENT=pagetrace.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>pageTraceBuf</span> <span style=color:#a6e22e>pageTraceBuf</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// Padding is no longer needed. False sharing is now not a worry because p is large enough  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// that its size class is an integer multiple of the cache line size (for any of our architectures).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   }
</span></span></code></pre></div><h4 id=部分字段用途-2>部分字段用途</h4><ul><li><code>id</code>：<code>P</code> 的唯一 <code>ID</code>，等于当前 <code>P</code> 在 <code>allp</code> 中的数组下标</li><li><code>staus</code>： 表示 <code>P</code> 的状态</li><li><code>link</code>：是一个没有写屏障的指针，别调度器用来构造链表</li><li><code>schedtick</code>：记录了调度发生的次数，实际上在每一次发生 <code>goroutine</code> 切换且不继承时间片的情况下，该字段会加一</li><li><code>syscalltick</code>：每发生一次系统调用就会加一</li><li><code>sysmontick</code>：被监控线程用来存储上一次检查时的调度器时钟滴答，用以实现时间片算法</li><li><code>m</code>：本质上是个指针，反向关联到当前 <code>P</code> 绑定的 <code>M</code></li><li><code>goidcache</code>，<code>goidcacheend</code>：用来从全局 <code>sched</code>，<code>goidgen</code> 处申请 goid<code>，</code>分配空间，批量申请以减少全局范围的锁竞争</li><li><code>runqhead</code>，<code>runqtail</code>，<code>runq</code>：当前 <code>P</code> 的就绪队列，用一个数组和一头一尾两个下标实现了一个环形队列</li><li><code>runnext</code>：如果不为 <code>nil</code>，则指向一个被当前 <code>G</code> 准备好（就绪）的 <code>G</code>，接下来将会继承当前 <code>G</code> 的时间片开始运行。该字段的存在意义在于，假如有一组 <code>goroutine</code> 中有生产者和消费者，他们在一个 <code>channel</code> 上频繁地等待和唤醒，那么调度器就会把他们作为一个单元来调度。每次使用 <code>runnext</code> 比添加到本地 <code>runq</code> 尾部能大幅减少延迟</li><li><code>gFree</code>：用来缓存已经退出运行的 <code>G</code>，方便再次分配时进行复用</li><li><code>preempt</code>：在 <code>Go1.14</code> 版本引入，以支持新的异步抢占机制</li></ul><h4 id=status-字段的取值及其含义>status 字段的取值及其含义</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>const</span> (  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// P status  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// _Pidle means a P is not being used to run user code or the   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// scheduler. Typically, it&#39;s on the idle P list and available   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// to the scheduler, but it may just be transitioning between   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// other states.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>//   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// The P is owned by the idle list or by whatever is   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// transitioning its state. Its run queue is empty.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>_Pidle</span> = <span style=color:#66d9ef>iota</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// _Prunning means a P is owned by an M and is being used to   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// run user code or the scheduler. Only the M that owns this P   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// is allowed to change the P&#39;s status from _Prunning. The M  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// may transition the P to _Pidle (if it has no more work to   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// do), _Psyscall (when entering a syscall), or _Pgcstop (to   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// halt for the GC). The M may also hand ownership of the P  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// off directly to another M (e.g., to schedule a locked G).   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>_Prunning</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// _Psyscall means a P is not running user code. It has   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// affinity to an M in a syscall but is not owned by it and   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// may be stolen by another M. This is similar to _Pidle but   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// uses lightweight transitions and maintains M affinity.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>//   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// Leaving _Psyscall must be done with a CAS, either to steal   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// or retake the P. Note that there&#39;s an ABA hazard: even if   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// an M successfully CASes its original P back to _Prunning  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// after a syscall, it must understand the P may have been  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// used by another M in the interim.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>_Psyscall</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// _Pgcstop means a P is halted for STW and owned by the M   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// that stopped the world. The M that stopped the world   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// continues to use its P, even in _Pgcstop. Transitioning  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// from _Prunning to _Pgcstop causes an M to release its P and   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// park.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>//   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// The P retains its run queue and startTheWorld will restart   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// the scheduler on Ps with non-empty run queues.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>_Pgcstop</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// _Pdead means a P is no longer used (GOMAXPROCS shrank). We   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// reuse Ps if GOMAXPROCS increases. A dead P is mostly   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// stripped of its resources, though a few things remain   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// (e.g., trace buffers).   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>_Pdead</span>  
</span></span><span style=display:flex><span>)
</span></span></code></pre></div></div></div></section></div><footer id=footer class="container-fluid text-center align-content-center footer pb-2"><div class="container pt-5"><div class="row text-left"><div class="col-md-4 col-sm-12"><h5>联系方式:</h5><ul><li><span>QQ: </span><span>1432050813</span></li><li><a href=mailto:ormissia@outlook.com target=_blank rel=noopener><span><i class="fas fa-envelope"></i></span> <span>ormissia@outlook.com</span></a></li></ul></div></div></div><hr><div class=container><p id=disclaimer><strong>免责声明:</strong> 老铁看到底了，要负责的哦</p></div><hr><div class=container><div class="row text-left"><div class=col-md-4><a id=theme href=https://github.com/hugo-toha/toha target=_blank rel=noopener><img src=/images/theme-logo_hu8376fd15465fef26ffe66b6bcf0ca686_13669_32x0_resize_box_3.png alt="Toha Theme Logo">
Toha</a></div><div class="col-md-4 text-center">© 2021 Copyright.</div><div class="col-md-4 text-right"><a id=hugo href=https://gohugo.io/ target=_blank rel=noopener>Powered by
<img src=/images/hugo-logo.svg alt="Hugo Logo" height=18></a></div></div></div></footer><script src=/application.dd14ce5884a636a7014ae8dc2953b8089e2c54e6449da331e2726c712c81c910.js integrity="sha256-3RTOWISmNqcBSujcKVO4CJ4sVOZEnaMx4nJscSyByRA=" defer></script></body></html>