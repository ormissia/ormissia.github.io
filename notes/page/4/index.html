<!doctype html><html lang=zh-cn><head><title>Notes</title>
<meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="ie=edge"><link rel=stylesheet href=/application.87ecd420aa4299c8e4b21123c5360ef38ce9d1370c88559d014914f4a65e6b89.css integrity="sha256-h+zUIKpCmcjkshEjxTYO84zp0TcMiFWdAUkU9KZea4k="><link rel=icon type=image/png href=/images/favicon_hu8376fd15465fef26ffe66b6bcf0ca686_13669_42x0_resize_box_3.png><meta property="og:title" content="Notes"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://ormissia.github.io/notes/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Notes"><meta name=twitter:description content><script>theme=localStorage.getItem("darkmode:color-scheme")||"system",theme=="system"&&(window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?theme="dark":theme="light"),document.documentElement.setAttribute("data-theme",theme)</script></head><body class="type-notes kind-section" data-spy=scroll data-target=#TableOfContents data-offset=80><div class="container-fluid bg-secondary wrapper"><nav class="navbar navbar-expand-xl top-navbar shadow" id=top-navbar><div class=container><button class="navbar-toggler navbar-light" id=sidebar-toggler type=button>
<i data-feather=sidebar></i>
</button>
<a class=navbar-brand href=/><img src=/images/ormissia_hu763a76473558eea2a316ef50b45aaecf_966068_42x0_resize_box_3.png id=logo alt=Logo>
Ormissia's Blog</a>
<button class="navbar-toggler navbar-light" id=navbar-toggler type=button data-toggle=collapse data-target=#top-nav-items aria-label=menu>
<i data-feather=menu></i></button><div class="collapse navbar-collapse dynamic-navbar" id=top-nav-items><ul class="nav navbar-nav ml-auto"><li class=nav-item><a class=nav-link href=/#home>主页</a></li><li class=nav-item><a class=nav-link href=/#about>技能</a></li><li class=nav-item><a class=nav-link href=/#recent-posts>最近</a></li><li class=nav-item><a class=nav-link href=/#education>历程</a></li><li class=nav-item><a class=nav-link href=/#projects>项目</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>更多的</a><div class=dropdown-menu aria-labelledby=navbarDropdown><a class=dropdown-item href=/#achievements>成就</a></div></li><div id=top-navbar-divider></div><li class=nav-item><a class=nav-link id=blog-link href=/posts>博文</a></li><li class=nav-item><a class=nav-link id=note-link href=/notes>笔记</a></li><li class=nav-item><a class=nav-link href=https://github.com/ormissia>GitHub</a></li></ul></div></div><img src=/images/ormissia_hu763a76473558eea2a316ef50b45aaecf_966068_42x0_resize_box_3.png class=d-none id=main-logo alt=Logo>
<img src=/images/ormissia_hu763a76473558eea2a316ef50b45aaecf_966068_42x0_resize_box_3.png class=d-none id=inverted-logo alt="Inverted Logo"></nav><section class=sidebar-section id=sidebar-section><div class=sidebar-holder><div class=sidebar id=sidebar><form class=mx-auto method=get action=/search><input type=text name=keyword placeholder=搜索 data-search id=search-box></form><div class=sidebar-tree><ul class=tree id=tree><li id=list-heading><a href=/notes data-filter=all>笔记</a></li><div class=subtree><li><i data-feather=plus-circle></i><a class=list-link href=/notes/go/> Go</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/go/basic/> Basics</a><ul><li><a class=list-link href=/notes/go/basic/basic/ title=Basic>Basic</a></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/go/advance/> Advance</a><ul><li><a class=list-link href=/notes/go/advance/time/ title=time>time</a></li><li><a class=list-link href=/notes/go/advance/gomod/ title="go mod">go mod</a></li><li><a class=list-link href=/notes/go/advance/chan/ title="go chan">go chan</a></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/go/algorithm/> Algorithm</a><ul><li><a class=list-link href=/notes/go/algorithm/basic/ title=Basic>Basic</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/java/> Java</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/java/basic/> Basics</a><ul><li><a class=list-link href=/notes/java/basic/basic_type/ title="Basic Types">Basic Types</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/scala/> Scala</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/scala/basic/> Basic</a><ul><li><a class=list-link href=/notes/scala/basic/basic_type/ title="Basic Types">Basic Types</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/python/> Python</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/python/basic/> Basic</a><ul><li><a class=list-link href=/notes/python/basic/basic/ title=Basic>Basic</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/js/> JavaScript</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/js/basic/> Basic</a><ul><li><a class=list-link href=/notes/js/basic/basic/ title=Basic>Basic</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/sql/> SQL</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/sql/dml/> DML</a><ul><li><a class=list-link href=/notes/sql/dml/dml/ title="SQL DML">SQL DML</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/linux/> Linux</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/linux/shell/> Shell</a><ul><li><a class=list-link href=/notes/linux/shell/basic/ title=Basic>Basic</a></li><li><a class=list-link href=/notes/linux/shell/advance/ title=Advance>Advance</a></li><li><a class=list-link href=/notes/linux/shell/vi/ title=vi>vi</a></li><li><a class=list-link href=/notes/linux/shell/script/ title=Script>Script</a></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/linux/system/> System</a><ul><li><a class=list-link href=/notes/linux/system/system/ title=Memory>Memory</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/hbase/> Hbase</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/hbase/shell/> Shell</a><ul><li><a class=list-link href=/notes/hbase/shell/basic/ title=Basic>Basic</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/kafka/> Kafka</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/kafka/shell/> Shell</a><ul><li><a class=list-link href=/notes/kafka/shell/basic/ title=Basic>Basic</a></li></ul></li></ul></li></div></ul></div></div></div></section><section class=content-section id=content-section><div class="content container-fluid" id=content><div class="container-fluid note-card-holder" id=note-card-holder><h1 id=client-go>client-go</h1><p>#k8s #kubernetes #clientgo #apiserver #go #golang</p><h2 id=基础使用>基础使用</h2><h3 id=源码仓库httpsgithubcomkubernetesclient-go><a href=https://github.com/kubernetes/client-go target=_blank rel=noopener>源码仓库</a></h3><h3 id=依赖引入>依赖引入</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>go get k8s.io/client-go@latest
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>go get k8s.io/client-go@v0.20.4
</span></span></code></pre></div><h2 id=client-go-客户端>client-go 客户端</h2><h3 id=架构>架构</h3><p><img src=client-go-controller-interaction.jpeg alt></p><p><a href=https://github.com/kubernetes/sample-controller/blob/master/docs/controller-client-go.md target=_blank rel=noopener>图片来源</a></p><h4 id=客户端组件>客户端组件</h4><ul><li><code>Reflector</code>：反射器，定义在 <a href=https://github.com/kubernetes/client-go/blob/master/tools/cache/reflector.go target=_blank rel=noopener>type <em>Reflector</em> inside package <em>cache</em></a> 中，监视 <code>Kubernetes API</code> 的指定资源类型（种类）。完成此操作的函数是 <code>ListAndWatch</code>。监视可以用于内置资源，也可以用于自定义资源。当 <code>Reflector</code> 通过 <code>watch API</code> 接收到关于新资源实例存在的通知时，它使用相应的 <code>listing API</code> 获取新创建的对象并将其放入 <code>watchHandler</code> 函数内的 <code>Delta Fifo</code> 队列中。</li><li><code>Informer</code>：在 <a href=https://github.com/kubernetes/client-go/blob/master/tools/cache/controller.go target=_blank rel=noopener>base controller inside package <em>cache</em></a> 中定义的 <code>Informer</code> 从 <code>Delta Fifo</code> 队列中弹出对象。完成此操作的函数是 <code>processLoop</code>。这个基本控制器的工作是保存对象供以后检索，并调用我们的控制器将对象传递给它。</li><li><code>Indexer</code>：索引器提供对象的索引功能。在 <a href=https://github.com/kubernetes/client-go/blob/master/tools/cache/index.go target=_blank rel=noopener>type <em>Indexer</em> inside package <em>cache</em></a> 中定义。一个典型的索引用例是基于对象标签创建索引。<code>Indexer</code> 可以维护基于多个索引函数的索引。索引器使用线程安全的数据存储来存储对象及其键。<a href=https://github.com/kubernetes/client-go/blob/master/tools/cache/store.go target=_blank rel=noopener>type <em>Store</em> inside package <em>cache</em></a> 中定义了一个名为 <code>MetaNamespaceKeyFunc</code> 的默认函数，它生成 <code>&lt;namespace>/&lt;name></code> 的键作为该对象的组合。</li></ul><h4 id=自定义控制器组件>自定义控制器组件</h4><ul><li><code>Informer reference</code>：这是对知道如何使用自定义资源对象的 Informer 实例的引用。自定义控制器代码需要创建适当的 <code>Informer</code>。</li><li><code>Indexer reference</code>：这是对知道如何使用自定义资源对象的 <code>Indexer</code> 实例的引用。自定义控制器代码需要创建它。将使用此引用来检索对象以供以后处理。</li></ul><blockquote><p><code>client-go</code> 中的 <code>base controller</code> 提供了 <code>NewIndexerInformer</code> 函数来创建 <code>Informer</code> 和 <code>Indexer</code>。在代码中，可以<a href=https://github.com/kubernetes/client-go/blob/master/examples/workqueue/main.go#L174 target=_blank rel=noopener>直接调用此函数</a>或<a href=https://github.com/kubernetes/sample-controller/blob/master/main.go#L61 target=_blank rel=noopener>使用工厂方法来创建<code>Informer</code></a>。</p></blockquote><ul><li><code>Resource Event Handlers</code>：这些是回调函数，当 <code>Informer</code> 想要将对象传递给控制器时将调用这些回调函数。编写这些函数的典型模式是获取分派对象的键并将该键放入工作队列中以供进一步处理。</li><li><code>Work queue:</code>：这是在控制器代码中创建的队列，用于将对象的传递与其处理分离。编写资源事件处理程序函数以提取已交付对象的键并将其添加到工作队列中。</li><li><code>Process Item</code>：这是在代码中创建的函数，用于处理工作队列中的项目。可以有一个或多个其他函数进行实际处理。这些函数通常会使用 <a href=https://github.com/kubernetes/client-go/blob/master/examples/workqueue/main.go#L73 target=_blank rel=noopener>Indexer reference</a> 或 <code>Listing wrapper</code> 来检索与键对应的对象。</li></ul><h3 id=组件>组件</h3><p><code>client-go</code> 共提供了 4 种与 <code>Kubernetes APIServer</code> 交互的客户端。分别是 <code>RESTClient</code>、<code>DiscoveryClient</code>、<code>ClientSet</code>、<code>DynamicClient</code>。</p><ul><li><code>RESTClient</code>：最基础的客户端，主要是对 <code>HTTP</code> 请求进行了封装，支持 <code>Json</code> 和 <code>Protobuf</code> 格式的数据。</li><li><code>DiscoveryClient</code>：发现客户端，负责发现 <code>APIServer</code> 支持的资源组、资源版本和资源信息的。</li><li><code>ClientSet</code>：负责操作 <code>Kubernetes</code> 内置的资源对象，例如：<code>Pod</code>、<code>Service</code>等。</li><li><code>DynamicClient</code>：动态客户端，可以对任意的 <code>Kubernetes</code> 资源对象进行通用操作，包括 <code>CRD</code>。</li></ul><pre tabindex=0><code class=language-mermaid data-lang=mermaid>graph TD

A[DiscoveryClient]
B[ClientSet]
C[DynamicClient]
D[RESTClient]
E[net/http]
F[Kubernetes APIServer]

    A --&gt; D
    B --&gt; D
    C --&gt; D

	D --&gt; E
	E --&gt; F
</code></pre><h1 id=kubernetes-组件>Kubernetes 组件</h1><p>#k8s #kubernetes #容器 #云 #go #golang</p><p><img src=https://d33wubrfki0l68.cloudfront.net/2475489eaf20163ec0f54ddc1d92aa8d4c87c96b/e7c81/images/docs/components-of-kubernetes.svg alt="Kubernetes 的组件"></p><h2 id=控制平面组件control-plane-componentshttpskubernetesiozh-cndocsconceptsoverviewcomponentscontrol-plane-components><a href=https://kubernetes.io/zh-cn/docs/concepts/overview/components/#control-plane-components target=_blank rel=noopener>控制平面组件（Control Plane Components）</a></h2><p>控制平面组件会为集群做出全局决策，比如资源的调度。 以及检测和响应集群事件，例如当不满足部署的 <code>replicas</code> 字段时， 要启动新的 <a href=https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/ target=_blank rel=noopener>pod</a>）。</p><p>控制平面组件可以在集群中的任何节点上运行。 然而，为了简单起见，设置脚本通常会在同一个计算机上启动所有控制平面组件， 并且不会在此计算机上运行用户容器。 请参阅<a href=https://kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/high-availability/ target=_blank rel=noopener>使用 kubeadm 构建高可用性集群</a> 中关于跨多机器控制平面设置的示例。</p><h3 id=kube-apiserverhttpskubernetesiozh-cndocsconceptsoverviewcomponentskube-apiserver><a href=https://kubernetes.io/zh-cn/docs/concepts/overview/components/#kube-apiserver target=_blank rel=noopener>kube-apiserver</a></h3><p>API 服务器是 Kubernetes <a href="https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-control-plane" target=_blank rel=noopener>控制平面</a>的组件， 该组件负责公开了 Kubernetes API，负责处理接受请求的工作。 API 服务器是 Kubernetes 控制平面的前端。</p><p>Kubernetes API 服务器的主要实现是 <a href=https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kube-apiserver/ target=_blank rel=noopener>kube-apiserver</a>。 <code>kube-apiserver</code> 设计上考虑了水平扩缩，也就是说，它可通过部署多个实例来进行扩缩。 你可以运行 <code>kube-apiserver</code> 的多个实例，并在这些实例之间平衡流量。</p><h3 id=etcdhttpskubernetesiozh-cndocsconceptsoverviewcomponentsetcd><a href=https://kubernetes.io/zh-cn/docs/concepts/overview/components/#etcd target=_blank rel=noopener>etcd</a></h3><p>一致且高可用的键值存储，用作 Kubernetes 所有集群数据的后台数据库。</p><p>如果你的 Kubernetes 集群使用 etcd 作为其后台数据库， 请确保你针对这些数据有一份 <a href=https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/configure-upgrade-etcd/#backing-up-an-etcd-cluster target=_blank rel=noopener>备份</a>计划。</p><p>你可以在官方<a href=https://etcd.io/docs/ target=_blank rel=noopener>文档</a>中找到有关 etcd 的深入知识。</p><h3 id=kube-schedulerhttpskubernetesiozh-cndocsconceptsoverviewcomponentskube-scheduler><a href=https://kubernetes.io/zh-cn/docs/concepts/overview/components/#kube-scheduler target=_blank rel=noopener>kube-scheduler</a></h3><p><code>kube-scheduler</code> 是<a href="https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-control-plane" target=_blank rel=noopener>控制平面</a>的组件， 负责监视新创建的、未指定运行<a href=https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/ target=_blank rel=noopener>节点（node）</a>的 <a href=https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/ target=_blank rel=noopener>Pods</a>， 并选择节点来让 Pod 在上面运行。</p><p>调度决策考虑的因素包括单个 Pod 及 Pods 集合的资源需求、软硬件及策略约束、 亲和性及反亲和性规范、数据位置、工作负载间的干扰及最后时限。</p><h3 id=kube-controller-managerhttpskubernetesiozh-cndocsconceptsoverviewcomponentskube-controller-manager><a href=https://kubernetes.io/zh-cn/docs/concepts/overview/components/#kube-controller-manager target=_blank rel=noopener>kube-controller-manager</a></h3><p><a href=https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank rel=noopener>kube-controller-manager</a> 是<a href="https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-control-plane" target=_blank rel=noopener>控制平面</a>的组件， 负责运行<a href=https://kubernetes.io/zh-cn/docs/concepts/architecture/controller/ target=_blank rel=noopener>控制器</a>进程。</p><p>从逻辑上讲， 每个<a href=https://kubernetes.io/zh-cn/docs/concepts/architecture/controller/ target=_blank rel=noopener>控制器</a>都是一个单独的进程， 但是为了降低复杂性，它们都被编译到同一个可执行文件，并在同一个进程中运行。</p><p>这些控制器包括：</p><ul><li>节点控制器（Node Controller）：负责在节点出现故障时进行通知和响应</li><li>任务控制器（Job Controller）：监测代表一次性任务的 Job 对象，然后创建 Pods 来运行这些任务直至完成</li><li>端点分片控制器（EndpointSlice controller）：填充端点分片（EndpointSlice）对象（以提供 Service 和 Pod 之间的链接）。</li><li>服务账号控制器（ServiceAccount controller）：为新的命名空间创建默认的服务账号（ServiceAccount）。</li></ul><h3 id=cloud-controller-managerhttpskubernetesiozh-cndocsconceptsoverviewcomponentscloud-controller-manager><a href=https://kubernetes.io/zh-cn/docs/concepts/overview/components/#cloud-controller-manager target=_blank rel=noopener>cloud-controller-manager</a></h3><p>一个 Kubernetes <a href="https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-control-plane" target=_blank rel=noopener>控制平面</a>组件， 嵌入了特定于云平台的控制逻辑。 云控制器管理器（Cloud Controller Manager）允许你将你的集群连接到云提供商的 API 之上， 并将与该云平台交互的组件同与你的集群交互的组件分离开来。</p><p><code>cloud-controller-manager</code> 仅运行特定于云平台的控制器。 因此如果你在自己的环境中运行 Kubernetes，或者在本地计算机中运行学习环境， 所部署的集群不需要有云控制器管理器。</p><p>与 <code>kube-controller-manager</code> 类似，<code>cloud-controller-manager</code> 将若干逻辑上独立的控制回路组合到同一个可执行文件中， 供你以同一进程的方式运行。 你可以对其执行水平扩容（运行不止一个副本）以提升性能或者增强容错能力。</p><p>下面的控制器都包含对云平台驱动的依赖：</p><ul><li>节点控制器（Node Controller）：用于在节点终止响应后检查云提供商以确定节点是否已被删除</li><li>路由控制器（Route Controller）：用于在底层云基础架构中设置路由</li><li>服务控制器（Service Controller）：用于创建、更新和删除云提供商负载均衡器</li></ul><h2 id=node-组件httpskubernetesiozh-cndocsconceptsoverviewcomponentsnode-components><a href=https://kubernetes.io/zh-cn/docs/concepts/overview/components/#node-components target=_blank rel=noopener>Node 组件</a></h2><p>节点组件会在每个节点上运行，负责维护运行的 Pod 并提供 Kubernetes 运行环境。</p><h3 id=kubelethttpskubernetesiozh-cndocsconceptsoverviewcomponentskubelet><a href=https://kubernetes.io/zh-cn/docs/concepts/overview/components/#kubelet target=_blank rel=noopener>kubelet</a></h3><p><code>kubelet</code> 会在集群中每个<a href=https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/ target=_blank rel=noopener>节点（node）</a>上运行。 它保证<a href=https://kubernetes.io/zh-cn/docs/concepts/overview/what-is-kubernetes/#why-containers target=_blank rel=noopener>容器（containers）</a>都运行在 <a href=https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/ target=_blank rel=noopener>Pod</a> 中。</p><p>kubelet 接收一组通过各类机制提供给它的 PodSpecs， 确保这些 PodSpecs 中描述的容器处于运行状态且健康。 kubelet 不会管理不是由 Kubernetes 创建的容器。</p><h3 id=kube-proxyhttpskubernetesiozh-cndocsconceptsoverviewcomponentskube-proxy><a href=https://kubernetes.io/zh-cn/docs/concepts/overview/components/#kube-proxy target=_blank rel=noopener>kube-proxy</a></h3><p><a href=https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kube-proxy/ target=_blank rel=noopener>kube-proxy</a> 是集群中每个<a href=https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/ target=_blank rel=noopener>节点（node）</a>上所运行的网络代理， 实现 Kubernetes <a href=https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/ target=_blank rel=noopener>服务（Service）</a> 概念的一部分。</p><p>kube-proxy 维护节点上的一些网络规则， 这些网络规则会允许从集群内部或外部的网络会话与 Pod 进行网络通信。</p><p>如果操作系统提供了可用的数据包过滤层，则 kube-proxy 会通过它来实现网络规则。 否则，kube-proxy 仅做流量转发。</p><h3 id=容器运行时container-runtimehttpskubernetesiozh-cndocsconceptsoverviewcomponentscontainer-runtime><a href=https://kubernetes.io/zh-cn/docs/concepts/overview/components/#container-runtime target=_blank rel=noopener>容器运行时（Container Runtime）</a></h3><p>容器运行环境是负责运行容器的软件。</p><p>Kubernetes 支持许多容器运行环境，例如 <a href=https://containerd.io/docs/ target=_blank rel=noopener>containerd</a>、 <a href=https://cri-o.io/#what-is-cri-o target=_blank rel=noopener>CRI-O</a> 以及 <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md target=_blank rel=noopener>Kubernetes CRI (容器运行环境接口)</a> 的其他任何实现。</p><h2 id=插件addonshttpskubernetesiozh-cndocsconceptsoverviewcomponentsaddons><a href=https://kubernetes.io/zh-cn/docs/concepts/overview/components/#addons target=_blank rel=noopener>插件（Addons）</a></h2><p>插件使用 Kubernetes 资源（<a href=https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/daemonset/ target=_blank rel=noopener>DaemonSet</a>、 <a href=https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/ target=_blank rel=noopener>Deployment</a> 等）实现集群功能。 因为这些插件提供集群级别的功能，插件中命名空间域的资源属于 <code>kube-system</code> 命名空间。</p><p>下面描述众多插件中的几种。有关可用插件的完整列表，请参见 <a href=https://kubernetes.io/zh-cn/docs/concepts/cluster-administration/addons/ target=_blank rel=noopener>插件（Addons）</a>。</p><h3 id=dnshttpskubernetesiozh-cndocsconceptsoverviewcomponentsdns><a href=https://kubernetes.io/zh-cn/docs/concepts/overview/components/#dns target=_blank rel=noopener>DNS</a></h3><p>尽管其他插件都并非严格意义上的必需组件，但几乎所有 Kubernetes 集群都应该有<a href=https://kubernetes.io/zh-cn/docs/concepts/services-networking/dns-pod-service/ target=_blank rel=noopener>集群 DNS</a>， 因为很多示例都需要 DNS 服务。</p><p>集群 DNS 是一个 DNS 服务器，和环境中的其他 DNS 服务器一起工作，它为 Kubernetes 服务提供 DNS 记录。</p><p>Kubernetes 启动的容器自动将此 DNS 服务器包含在其 DNS 搜索列表中。</p><h3 id=web-界面仪表盘httpskubernetesiozh-cndocsconceptsoverviewcomponentsweb-ui-dashboard><a href=https://kubernetes.io/zh-cn/docs/concepts/overview/components/#web-ui-dashboard target=_blank rel=noopener>Web 界面（仪表盘）</a></h3><p><a href=https://kubernetes.io/zh-cn/docs/tasks/access-application-cluster/web-ui-dashboard/ target=_blank rel=noopener>Dashboard</a> 是 Kubernetes 集群的通用的、基于 Web 的用户界面。 它使用户可以管理集群中运行的应用程序以及集群本身， 并进行故障排除。</p><h3 id=容器资源监控httpskubernetesiozh-cndocsconceptsoverviewcomponentscontainer-resource-monitoring><a href=https://kubernetes.io/zh-cn/docs/concepts/overview/components/#container-resource-monitoring target=_blank rel=noopener>容器资源监控</a></h3><p><a href=https://kubernetes.io/zh-cn/docs/tasks/debug/debug-cluster/resource-usage-monitoring/ target=_blank rel=noopener>容器资源监控</a> 将关于容器的一些常见的时间序列度量值保存到一个集中的数据库中， 并提供浏览这些数据的界面。</p><h3 id=集群层面日志httpskubernetesiozh-cndocsconceptsoverviewcomponentscluster-level-logging><a href=https://kubernetes.io/zh-cn/docs/concepts/overview/components/#cluster-level-logging target=_blank rel=noopener>集群层面日志 </a></h3><p><a href=https://kubernetes.io/zh-cn/docs/concepts/cluster-administration/logging/ target=_blank rel=noopener>集群层面日志</a>机制负责将容器的日志数据保存到一个集中的日志存储中， 这种集中日志存储提供搜索和浏览接口。</p><h1 id=mysql>MySQL</h1><p>#mysql #数据库 #db #b加树</p><h2 id=基础>基础</h2><h3 id=事务>#事务</h3><blockquote><p>只有 <code>InnoDB</code> 引擎才支持事务</p></blockquote><blockquote><p><code>MySQL</code> 默认的事务隔离级别是可重复读（<code>REPEATABLE READ</code>）</p></blockquote><h4 id=acid-特性>#ACID 特性</h4><ol><li>原子性 (Atomicity)：</li><li>一致性 (Consistency)：</li><li>隔离性 (Isolation)：</li><li>持久性 (Durability)：</li></ol><h4 id=并发问题>并发问题</h4><ol><li><strong>脏读</strong>：当一个事务读取到另外一个事务修改但未提交的数据时，就可能发生脏读</li><li><strong>不可重复读</strong>：“不可重复读”现象发生在当执行 SELECT 操作时没有获得读锁或者 SELECT 操作执行完后马上释放了读锁；另外一个事务对数据进行了更新， 读到了不同的结果</li><li><strong>幻读</strong>：是&rsquo;&lsquo;不可重复读&rsquo;&lsquo;的一种特殊场景：当事务1两次执行&rsquo;&lsquo;SELECT &mldr; WHERE&rsquo;&lsquo;检索一定范围内数据的操作中间，事务2在这个表中创建了 (如 INSERT 或 DELETE)了一行新数据，这条新数据正好满足事务1的“WHERE”子句。事务1执行了两遍同样的查询语句，第二遍比第一遍多出了一条数据，就是幻读</li></ol><p>三者区别：
脏读：指读到了其他事务未提交的数据
不可重复读：读到了其他事务已提交的数据 (update)</p><p>不可重复读与幻读都是读到其他事务已提交的数据, 但是它们针对点不同
不可重复读：update
幻读：delete, insert</p><h4 id=乐观锁与悲观锁>乐观锁与悲观锁</h4><ul><li>#悲观锁 ：在整个数据处理过程中，将数据处于锁定状态。读取数据时给加锁，其它事务无法修改这些数据。修改删除数据时也要加锁，其它事务无法读取这些数据</li><li>#乐观锁 ：相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。乐观锁，大多是基于数据版本（ Version ）记录机制实现。在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据</li></ul><h4 id=隔离级别>#隔离级别</h4><table><thead><tr><th>事务隔离级别</th><th style=text-align:center>脏读</th><th style=text-align:center>不可重复读</th><th style=text-align:center>幻读</th></tr></thead><tbody><tr><td>读未提交</td><td style=text-align:center>✅</td><td style=text-align:center>✅</td><td style=text-align:center>✅</td></tr><tr><td>读已提交</td><td style=text-align:center>❎</td><td style=text-align:center>✅</td><td style=text-align:center>✅</td></tr><tr><td>可重复读</td><td style=text-align:center>❎</td><td style=text-align:center>❎</td><td style=text-align:center>✅</td></tr><tr><td>串行化</td><td style=text-align:center>❎</td><td style=text-align:center>❎</td><td style=text-align:center>❎</td></tr></tbody></table><ol><li><strong>读未提交</strong>：该隔离级别因为可以读取到其他事务中未提交的数据，而未提交的数据可能会发生回滚，因此我们把该级别读取到的数据称之为脏数据，把这个问题称之为脏读。</li><li><strong>读已提交</strong>：该隔离级别的事务能读取到已经提交事务的数据，因此它不会有脏读问题。但由于在事务的执行中可以读取到其他事务提交的结果，所以在不同时间的相同 SQL 查询中，可能会得到不同的结果，这种现象叫做不可重复读。</li><li><strong>可重复读</strong>：可重复读，是 <em>MySQL 的默认事务隔离级别</em>，它能确保同一事务多次查询的结果一致。但也会有新的问题，比如此级别的事务正在执行时，另一个事务成功的插入了某条数据，但因为它每次查询的结果都是一样的，所以会导致查询不到这条数据，自己重复插入时又失败（因为唯一约束的原因）。明明在事务中查询不到这条信息，但自己就是插入不进去，这就叫幻读 （Phantom Read）。</li><li><strong>序列化</strong>：序列化，事务最高隔离级别，它会强制事务排序，使之不会发生冲突，从而解决了脏读、不可重复读和幻读问题，但执行效率低。</li></ol><h3 id=mvcc-多版本并发控制>#MVCC (多版本并发控制)</h3><p>在 MySQL 中可重复读隔离级别就是通过 MVCC 来实现的乐观锁解决不可重复读问题。</p><h2 id=调优>调优</h2><h3 id=建表优化>建表优化</h3><ul><li>字段长度越小越好</li><li>时间选择时间类型</li><li>时间戳<ul><li><code>datetime</code></li><li><code>timestamp</code></li><li><code>date</code></li></ul></li><li>IP 选择整型<ul><li><code>select inet_aton('192.168.13.1');</code></li><li><code>select inet_ntoa(3232238849);</code></li></ul></li><li>尽量避免使用 <code>null</code>：会使索引等变复杂</li><li>主键选择<ul><li>代理主键（推荐）</li><li>自然主键</li></ul></li></ul><h3 id=字符集选择>字符集选择</h3><p><strong>一定要选择 <code>utf8mb4</code></strong></p><h3 id=查询优化>查询优化</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>show</span> profile
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>performance_chema
</span></span></code></pre></div><h3 id=数据库引擎>数据库引擎</h3><ul><li><code>MyISAM</code></li><li><code>InnoDB</code></li></ul><h3 id=适当的数据冗余>适当的数据冗余</h3><h3 id=拆分>拆分</h3><ul><li>垂直拆分</li><li>水平拆分</li></ul><h3 id=执行计划>执行计划</h3><h3 id=索引优化>索引优化</h3><h4 id=索引分类>索引分类</h4><ul><li>主键索引</li><li>唯一索引</li><li>普通索引</li><li>全文索引</li><li>组合索引</li></ul><h4 id=名词>名词</h4><ul><li>回表</li><li>覆盖索引：要查的字段在索引中存在，不需要回表的情况下为覆盖索引</li><li>最左匹配</li><li>索引下推：在最左匹配失效时使用索引下推</li></ul><h4 id=哈希索引>哈希索引</h4><h3 id=聚簇索引和非聚簇索引>聚簇索引和非聚簇索引</h3><p><code>InnoDB</code> 聚集索引的叶子节点存储行记录，因此， <code>InnoDB</code> 必须要有，且只有一个聚集索引：</p><ol><li>如果表定义了主键，则 <code>PK</code> 就是聚集索引</li><li>如果表没有定义主键，则第一个非空唯一索引（not NULL unique）列是聚集索引；</li><li>否则，<code>InnoDB</code> 会创建一个隐藏的 <code>row-id</code> 作为聚集索引；</li></ol><p>作者：技术灭霸<br>链接：https://www.jianshu.com/p/d0d3de6832b9<br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><ul><li>聚簇索引：不是单独的索引类型，而是一种数据存储方式，指的是数据行跟相邻的键值紧凑的存储在一起</li><li>非聚簇索引：数据文件跟索引文件分开存储</li></ul><h3 id=其它细节>其它细节</h3><ol><li>当使用索引列进行查询的时候尽量不要使用表达式，把计算放到业务层而不是数据库层
select id from tab where id = 4
select id from tab where id + 1 = 5</li><li>尽量使用主键查询，而不是其他索引，因为主键查询不会触发回表</li><li>使用前缀索引
前缀索引：很长的字符串使用开始的部分字符串创建索引</li><li>使用索引扫描来排序</li><li>如果明确知道只有一条返回结果，limit 1 能提高效率
加了查到数据就直接返回了</li><li>单表索引不宜超过 5 个</li><li>但索引字段数不宜超过 5 个</li></ol><h3 id=索引监控>索引监控</h3><h1 id=redis>Redis</h1><p>#redis #中间件 #缓存 #db #内存缓存</p><h2 id=基础数据类型>基础数据类型</h2><ul><li>string</li><li>list</li><li>hash</li><li>set</li><li>zset</li><li>bitmap</li></ul><h2 id=高级特性>高级特性</h2><h3 id=慢查询>#慢查询</h3><h3 id=pipeline>#pipeline</h3><p>多个命令一次请求减少网络开销</p><h3 id=事务>#事务</h3><h3 id=lua>#Lua</h3><p>原子操作</p><h3 id=stream>#Stream</h3><h2 id=底层原理>底层原理</h2><h3 id=持久化>持久化</h3><h4 id=rdb>RDB</h4><ul><li>save: 阻塞主线程</li><li>bgsave: 不阻塞主线程</li></ul><h4 id=aof>AOF</h4><h3 id=分布式锁>分布式锁</h3><ul><li><code>setnx</code></li><li><code>set lock_name 1 ex 10 nx</code></li></ul><h4 id=普通流程>普通流程</h4><ol><li>加锁：<code>set lock_name uuid ex 10 nx</code></li><li>业务操作</li><li>释放锁：<code>lua</code> 脚本，先 <code>get</code> 判断是否属于自己，再 <code>del</code> 释放锁</li></ol><h4 id=红锁流程>红锁流程</h4><ol><li>客户端获取当前时间戳T1</li><li>客户端依次向这 5 台 <code>redis</code> 实例（非集群）发起加锁请求</li><li>如果>=3个（大多数）成功，当前时间戳T2 - T1 &lt; 锁的过期时间则加锁成功</li><li>加锁成功，操作业务</li><li>加锁失败/释放锁，向5台<code>redis</code>发起释放锁请求</li></ol><h2 id=集群>集群</h2><h3 id=一主多从>一主多从</h3><h4 id=主从>主从</h4><h4 id=哨兵>哨兵</h4><p><img src=%E8%AE%A1%E7%AE%97%E6%9C%BA/img/redis_sentry.png alt=哨兵></p><h3 id=多主多从>多主多从</h3><blockquote><p>虚拟一致性哈希 -> 虚拟槽分区</p></blockquote><h2 id=常见问题及解决办法>常见问题及解决办法</h2><h3 id=缓存相关>缓存相关</h3><ul><li>#缓存一致性<ul><li>成因：由于网络延迟等因素导致缓存中数据与DB中数据不一致</li><li>解决办法：#延时双删</li></ul></li><li>#缓存穿透<ul><li>成因：DB中不存在的数据被频繁请求</li><li>解决办法：1. 数据进行插入操作同时添加到 #布隆过滤器 ，2. 缓存空对象</li></ul></li><li>#缓存击穿<ul><li>成因：同一个缓存中不存在的 <code>key</code> ，在一段时间（一般是极短时间）内第一个请求查询完 DB 后还未写入缓存，导致这段时间内后续请求又直接打到 DB</li><li>解决办法：查询前加锁</li></ul></li><li>#缓存雪崩<ul><li>成因：大量缓存数据同时过期导致请求直接打到DB</li><li>解决办法：在一定范围内随机过期时间，比如一小时随机加减十以内分钟数</li></ul></li></ul><h3 id=key相关>key相关</h3><ul><li>#热点key<ul><li>解决办法：<ol><li>使用 <code>redis</code> 命令：容易造成 <code>redis</code> 宕机</li><li>#TCP抓包 ：<ul><li>无入侵性，成本高</li><li><code>elk-packetbeat</code></li><li>容易造成机器网络波动，如丢包</li><li>维护成本高</li></ul></li><li>二级缓存</li><li>主从架构时，在从节点中扫描大 key</li><li>子 key #hash算法</li></ol></li></ul></li><li>#大key<ul><li>大概标准：<ul><li><code>string</code> 大于 <code>10kb</code></li><li></li></ul></li></ul></li><li>#数据倾斜</li></ul><h2 id=链接>链接</h2><ul><li>[[计算机/项目/Go缓存垫片]]</li></ul><h1 id=freertos>FreeRTOS</h1><p>#操作系统 #freertos #嵌入式</p><h1 id=linux>Linux</h1><p>#操作系统 #linux</p><h2 id=进程管理>进程管理</h2><h3 id=查看进程>查看进程</h3><h4 id=ps>ps</h4><p>查看某个时间点的进程信息。</p><p>示例：查看自己的进程</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>ps -l
</span></span></code></pre></div><p>示例：查看系统所有进程</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>ps aux
</span></span></code></pre></div><p>示例：查看特定的进程</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>ps aux | grep threadx
</span></span></code></pre></div><h4 id=pstree>pstree</h4><p>查看进程树。</p><p>示例：查看所有进程树</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>pstree -A
</span></span></code></pre></div><h4 id=top>top</h4><p>实时显示进程信息。</p><p>示例：两秒钟刷新一次</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>top -d <span style=color:#ae81ff>2</span>
</span></span></code></pre></div><h4 id=netstat>netstat</h4><p>查看占用端口的进程</p><p>示例：查看特定端口的进程</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>netstat -anp | grep port
</span></span></code></pre></div><h3 id=进程状态>进程状态</h3><table><thead><tr><th>状态</th><th>说明</th></tr></thead><tbody><tr><td>R</td><td>running or runnable (on run queue)正在执行或者可执行，此时进程位于执行队列中。</td></tr><tr><td>D</td><td>uninterruptible sleep (usually I/O)不可中断阻塞，通常为 IO 阻塞。</td></tr><tr><td>S</td><td>interruptible sleep (waiting for an event to complete) 可中断阻塞，此时进程正在等待某个事件完成。</td></tr><tr><td>Z</td><td>zombie (terminated but not reaped by its parent)僵死，进程已经终止但是尚未被其父进程获取信息。</td></tr><tr><td>T</td><td>stopped (either by a job control signal or because it is being traced) 结束，进程既可以被作业控制信号结束，也可能是正在被追踪。</td></tr></tbody></table><h3 id=孤儿进程>#孤儿进程</h3><p>一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。</p><p>孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。</p><p>由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。</p><h3 id=僵尸进程>#僵尸进程</h3><p>一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 <code>wait()</code> 或 <code>waitpid () </code>获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 <code>wait ()</code> 或 <code>waitpid ()</code>，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。</p><p>僵尸进程通过 ps 命令显示出来的状态为 Z（zombie）。</p><p>系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。</p><p>要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 进程所收养，这样 init 进程就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程。</p><h2 id=查看连接>查看连接</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>netstat -natp
</span></span></code></pre></div><h1 id=ubuntu>Ubuntu</h1><p>#linux #ubuntu #ssh</p><h2 id=开启-ssh-服务>开启 SSH 服务</h2><p>检查是否有 <code>ssh</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>ps -e | grep ssh
</span></span></code></pre></div><p>更新软件列表和软件</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo apt-get update
</span></span><span style=display:flex><span>sudo apt-get upgrade
</span></span></code></pre></div><p>安装 <code>ssh</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo apt-get install ssh
</span></span></code></pre></div><p>启动 <code>ssh</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo /etc/int.d/ssh start
</span></span></code></pre></div><p>再次检查是否有 <code>ssh</code>，当结果里看到 <code>sshd</code> 即为 <code>ssh</code> 服务端已启动</p><h1 id=操作系统零碎知识点>操作系统零碎知识点</h1><p>#操作系统</p><h2 id=进程--线程--协程-的区别>#进程 、 #线程 、 #协程 的区别</h2><ul><li>进程：操作系统分配资源的单位，进程包含了一组资源，其中有进程的唯一 ID、虚拟地址空间、打开文件描述符（或句柄表）等，还有至少一个线程，也就是主线程</li><li>线程：<code>CPU</code> 调度的基本单位，在多线程模式下，进程打算开的文件描述符表、文件系统信息、虚拟地址空间、和命名空间是被进程内所有线程共享的，但是每个线程拥有自己的内核数据结构、内核栈和用户栈、以及信号处理器</li><li>协程：</li></ul><p>异同：</p><ul><li>进程拥有自己独立的堆栈，堆栈均不共享</li><li>线程拥有独立的栈，共享堆</li><li>协程同线程一样共享堆但不共享栈</li></ul><h2 id=cpu密集型--io密集型>#CPU密集型 / #IO密集型</h2><ul><li>CPU 密集型任务一般更看重吞吐量，所以要尽量减少上下文切换，每次直接用完时间片就行了，<strong>所以对这种场景协程是非必要的</strong>。</li><li>IO 密集型任务可能更看重相应延迟，例如常见的 web 服务器</li></ul><h2 id=乐观锁--悲观锁>#乐观锁 / #悲观锁</h2><ul><li>悲观锁：访问资源的时候对资源加锁，未解锁之前，不允许其他访问者访问该资源</li><li>乐观锁：认为不会与其他访问冲突，因此默认不加锁，通常是通过对访问资源添加版本或是时间戳来控制数据的正确性</li></ul><h2 id=零拷贝>#零拷贝</h2><h1 id=动态规划>动态规划</h1><p>#算法 #动态规划</p><blockquote><p>基础思想：使用自然智慧写出递归代码，然后使用递归的依赖关系以及边界条件该出动态规划算法</p></blockquote><h2 id=模型>模型</h2><ul><li>自左向右的尝试模型</li><li>范围上的尝试模型</li><li>多样本位置全对应的尝试模型</li><li>寻找业务限制的尝试模型</li></ul><h1 id=单调栈结构>单调栈结构</h1><p>#算法 #栈 #单调栈</p></div><div class=paginator><ul class="pagination pagination-default"><li class=page-item><a href=/notes/ aria-label=First class=page-link role=button><span aria-hidden=true>&#171;&#171;</span></a></li><li class=page-item><a href=/notes/page/3/ aria-label=Previous class=page-link role=button><span aria-hidden=true>&#171;</span></a></li><li class=page-item><a href=/notes/page/2/ aria-label="Page 2" class=page-link role=button>2</a></li><li class=page-item><a href=/notes/page/3/ aria-label="Page 3" class=page-link role=button>3</a></li><li class="page-item active"><a aria-current=page aria-label="Page 4" class=page-link role=button>4</a></li><li class=page-item><a href=/notes/page/5/ aria-label="Page 5" class=page-link role=button>5</a></li><li class=page-item><a href=/notes/page/6/ aria-label="Page 6" class=page-link role=button>6</a></li><li class=page-item><a href=/notes/page/5/ aria-label=Next class=page-link role=button><span aria-hidden=true>&#187;</span></a></li><li class=page-item><a href=/notes/page/8/ aria-label=Last class=page-link role=button><span aria-hidden=true>&#187;&#187;</span></a></li></ul></div></div></section></div><footer id=footer class="container-fluid text-center align-content-center footer pb-2"><div class="container pt-5"><div class="row text-left"><div class="col-md-4 col-sm-12"><h5>联系方式:</h5><ul><li><span>QQ: </span><span>1432050813</span></li><li><a href=mailto:ormissia@outlook.com target=_blank rel=noopener><span><i class="fas fa-envelope"></i></span> <span>ormissia@outlook.com</span></a></li></ul></div></div></div><hr><div class=container><p id=disclaimer><strong>免责声明:</strong> 老铁看到底了，要负责的哦</p></div><hr><div class=container><div class="row text-left"><div class=col-md-4><a id=theme href=https://github.com/hugo-toha/toha target=_blank rel=noopener><img src=/images/theme-logo_hu8376fd15465fef26ffe66b6bcf0ca686_13669_32x0_resize_box_3.png alt="Toha Theme Logo">
Toha</a></div><div class="col-md-4 text-center">© 2021 Copyright.</div><div class="col-md-4 text-right"><a id=hugo href=https://gohugo.io/ target=_blank rel=noopener>Powered by
<img src=/images/hugo-logo.svg alt="Hugo Logo" height=18></a></div></div></div></footer><script src=/application.dd14ce5884a636a7014ae8dc2953b8089e2c54e6449da331e2726c712c81c910.js integrity="sha256-3RTOWISmNqcBSujcKVO4CJ4sVOZEnaMx4nJscSyByRA=" defer></script></body></html>