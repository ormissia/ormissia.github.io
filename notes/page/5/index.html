<!doctype html><html lang=zh-cn><head><title>Notes</title>
<meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="ie=edge"><link rel=stylesheet href=/application.87ecd420aa4299c8e4b21123c5360ef38ce9d1370c88559d014914f4a65e6b89.css integrity="sha256-h+zUIKpCmcjkshEjxTYO84zp0TcMiFWdAUkU9KZea4k="><link rel=icon type=image/png href=/images/favicon_hu8376fd15465fef26ffe66b6bcf0ca686_13669_42x0_resize_box_3.png><meta property="og:title" content="Notes"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://ormissia.github.io/notes/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Notes"><meta name=twitter:description content><script>theme=localStorage.getItem("darkmode:color-scheme")||"system",theme=="system"&&(window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?theme="dark":theme="light"),document.documentElement.setAttribute("data-theme",theme)</script></head><body class="type-notes kind-section" data-spy=scroll data-target=#TableOfContents data-offset=80><div class="container-fluid bg-secondary wrapper"><nav class="navbar navbar-expand-xl top-navbar shadow" id=top-navbar><div class=container><button class="navbar-toggler navbar-light" id=sidebar-toggler type=button>
<i data-feather=sidebar></i>
</button>
<a class=navbar-brand href=/><img src=/images/ormissia_hu763a76473558eea2a316ef50b45aaecf_966068_42x0_resize_box_3.png id=logo alt=Logo>
Ormissia's Blog</a>
<button class="navbar-toggler navbar-light" id=navbar-toggler type=button data-toggle=collapse data-target=#top-nav-items aria-label=menu>
<i data-feather=menu></i></button><div class="collapse navbar-collapse dynamic-navbar" id=top-nav-items><ul class="nav navbar-nav ml-auto"><li class=nav-item><a class=nav-link href=/#home>主页</a></li><li class=nav-item><a class=nav-link href=/#about>技能</a></li><li class=nav-item><a class=nav-link href=/#recent-posts>最近</a></li><li class=nav-item><a class=nav-link href=/#education>历程</a></li><li class=nav-item><a class=nav-link href=/#projects>项目</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>更多的</a><div class=dropdown-menu aria-labelledby=navbarDropdown><a class=dropdown-item href=/#achievements>成就</a></div></li><div id=top-navbar-divider></div><li class=nav-item><a class=nav-link id=blog-link href=/posts>博文</a></li><li class=nav-item><a class=nav-link id=note-link href=/notes>笔记</a></li><li class=nav-item><a class=nav-link href=https://github.com/ormissia>GitHub</a></li></ul></div></div><img src=/images/ormissia_hu763a76473558eea2a316ef50b45aaecf_966068_42x0_resize_box_3.png class=d-none id=main-logo alt=Logo>
<img src=/images/ormissia_hu763a76473558eea2a316ef50b45aaecf_966068_42x0_resize_box_3.png class=d-none id=inverted-logo alt="Inverted Logo"></nav><section class=sidebar-section id=sidebar-section><div class=sidebar-holder><div class=sidebar id=sidebar><form class=mx-auto method=get action=/search><input type=text name=keyword placeholder=搜索 data-search id=search-box></form><div class=sidebar-tree><ul class=tree id=tree><li id=list-heading><a href=/notes data-filter=all>笔记</a></li><div class=subtree><li><i data-feather=plus-circle></i><a class=list-link href=/notes/go/> Go</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/go/basic/> Basics</a><ul><li><a class=list-link href=/notes/go/basic/basic/ title=Basic>Basic</a></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/go/advance/> Advance</a><ul><li><a class=list-link href=/notes/go/advance/time/ title=time>time</a></li><li><a class=list-link href=/notes/go/advance/gomod/ title="go mod">go mod</a></li><li><a class=list-link href=/notes/go/advance/chan/ title="go chan">go chan</a></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/go/algorithm/> Algorithm</a><ul><li><a class=list-link href=/notes/go/algorithm/basic/ title=Basic>Basic</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/java/> Java</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/java/basic/> Basics</a><ul><li><a class=list-link href=/notes/java/basic/basic_type/ title="Basic Types">Basic Types</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/scala/> Scala</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/scala/basic/> Basic</a><ul><li><a class=list-link href=/notes/scala/basic/basic_type/ title="Basic Types">Basic Types</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/python/> Python</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/python/basic/> Basic</a><ul><li><a class=list-link href=/notes/python/basic/basic/ title=Basic>Basic</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/js/> JavaScript</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/js/basic/> Basic</a><ul><li><a class=list-link href=/notes/js/basic/basic/ title=Basic>Basic</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/sql/> SQL</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/sql/dml/> DML</a><ul><li><a class=list-link href=/notes/sql/dml/dml/ title="SQL DML">SQL DML</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/linux/> Linux</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/linux/shell/> Shell</a><ul><li><a class=list-link href=/notes/linux/shell/basic/ title=Basic>Basic</a></li><li><a class=list-link href=/notes/linux/shell/advance/ title=Advance>Advance</a></li><li><a class=list-link href=/notes/linux/shell/vi/ title=vi>vi</a></li><li><a class=list-link href=/notes/linux/shell/script/ title=Script>Script</a></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/linux/system/> System</a><ul><li><a class=list-link href=/notes/linux/system/system/ title=Memory>Memory</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/hbase/> Hbase</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/hbase/shell/> Shell</a><ul><li><a class=list-link href=/notes/hbase/shell/basic/ title=Basic>Basic</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/kafka/> Kafka</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/kafka/shell/> Shell</a><ul><li><a class=list-link href=/notes/kafka/shell/basic/ title=Basic>Basic</a></li></ul></li></ul></li></div></ul></div></div></div></section><section class=content-section id=content-section><div class="content container-fluid" id=content><div class="container-fluid note-card-holder" id=note-card-holder><h1 id=基础算法>基础算法</h1><p>#算法</p><h2 id=排序>#排序</h2><h3 id=选择排序>#选择排序</h3><h3 id=冒泡排序>#冒泡排序</h3><h3 id=插入排序>#插入排序</h3><h3 id=归并排序>#归并排序</h3><h3 id=快速排序>#快速排序</h3><h3 id=堆排序>#堆排序</h3><p>[[计算机/算法/数据结构#堆]]</p><h3 id=桶排序>#桶排序</h3><h2 id=查找>查找</h2><h3 id=二分查找>#二分查找</h3><h1 id=数据结构>数据结构</h1><p>#算法</p><h2 id=位运算>#位运算</h2><h3 id=位图>#位图</h3><h3 id=异或>#异或</h3><h3 id=同或>#同或</h3><h3 id=题目>题目</h3><h2 id=链表>#链表</h2><h3 id=单链表>#单链表</h3><h4 id=逆序>逆序</h4><h4 id=实现-队列>实现 #队列</h4><h4 id=实现栈>实现栈</h4><h3 id=双链表>#双链表</h3><h4 id=逆序-1>逆序</h4><h4 id=实现-双端队列>实现 #双端队列</h4><h3 id=题目-1>题目</h3><h4 id=多个-有序链表-合并>多个 #有序链表 合并</h4><blockquote><p>先把所有头结点放入小根堆</p></blockquote><h2 id=树>#树</h2><h3 id=二叉树>#二叉树</h3><h4 id=遍历>遍历</h4><ul><li>先序遍历</li><li>中序遍历</li><li>后序遍历</li><li>Morris 序遍历</li></ul><h4 id=堆>#堆</h4><h5 id=大根堆>#大根堆</h5><h5 id=小根堆>#小根堆</h5><h5 id=最小四叉堆>#最小四叉堆</h5><h4 id=搜索二叉树>#搜索二叉树</h4><blockquote><p>每一棵子树，左树的值比我小，右树的值比我大（中序遍历升序）</p></blockquote><h4 id=平衡二叉树>#平衡二叉树</h4><blockquote><p>左树和右树高度相差不超过1</p></blockquote><h2 id=sb-树>SB 树</h2><h4 id=平衡搜索二叉树>#平衡搜索二叉树</h4><h4 id=红黑树>#红黑树</h4><h4 id=题目-2>题目</h4><h3 id=b加树>#b加树</h3><p>[[计算机/中间件/MySQL]]</p><h2 id=图>图</h2><h1 id=资源限制技巧>资源限制技巧</h1><p>#算法</p><h2 id=布隆过滤器用于集合的建立与查询可以节省大量空间>布隆过滤器用于集合的建立与查询，可以节省大量空间</h2><h2 id=一致性哈希解决数据服务器的负载管理问题>一致性哈希解决数据服务器的负载管理问题</h2><h2 id=利用并查集结构做岛问题的并行计算>利用并查集结构做岛问题的并行计算</h2><h2 id=哈希函数可以把数据按照种类均匀分流>哈希函数可以把数据按照种类均匀分流</h2><h2 id=位图解决某一范围上数字的出现情况并可以节省大量空间>位图解决某一范围上数字的出现情况，并可以节省大量空间</h2><h2 id=利用分段统计思想进一步节省大量空间>利用分段统计思想，进一步节省大量空间</h2><h2 id=利用堆外排序来做多个处理单元的结果合并>利用堆、外排序来做多个处理单元的结果合并</h2><h1 id=http>HTTP</h1><p>#网络 #http</p><h2 id=基础概念>基础概念</h2><h3 id=请求和响应报文>请求和响应报文</h3><p>客户端发送一个请求报文给服务器，服务器根据请求报文中的信息进行处理，并将处理结果放入响应报文中返回给客户端。</p><p>请求报文结构：</p><ul><li>第一行是包含了请求方法、URL、协议版本；</li><li>接下来的多行都是请求首部 Header，每个首部都有一个首部名称，以及对应的值。</li><li>一个空行用来分隔首部和内容主体 Body</li><li>最后是请求的内容主体</li></ul><pre tabindex=0><code>GET http://www.example.com/ HTTP/1.1
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8
Cache-Control: max-age=0
Host: www.example.com
If-Modified-Since: Thu, 17 Oct 2019 07:18:26 GMT
If-None-Match: &#34;3147526947+gzip&#34;
Proxy-Connection: keep-alive
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 xxx

param1=1&amp;param2=2
</code></pre><p>响应报文结构：</p><ul><li>第一行包含协议版本、状态码以及描述，最常见的是 200 OK 表示请求成功了</li><li>接下来多行也是首部内容</li><li>一个空行分隔首部和内容主体</li><li>最后是响应的内容主体</li></ul><pre tabindex=0><code>HTTP/1.1 200 OK
Age: 529651
Cache-Control: max-age=604800
Connection: keep-alive
Content-Encoding: gzip
Content-Length: 648
Content-Type: text/html; charset=UTF-8
Date: Mon, 02 Nov 2020 17:53:39 GMT
Etag: &#34;3147526947+ident+gzip&#34;
Expires: Mon, 09 Nov 2020 17:53:39 GMT
Keep-Alive: timeout=4
Last-Modified: Thu, 17 Oct 2019 07:18:26 GMT
Proxy-Connection: keep-alive
Server: ECS (sjc/16DF)
Vary: Accept-Encoding
X-Cache: HIT

&lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Example Domain&lt;/title&gt;
	// 省略... 
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h3 id=url>URL</h3><p>HTTP 使用 URL（ <strong>U</strong>niform <strong>R</strong>esource <strong>L</strong>ocator，统一资源定位符）来定位资源，它是 URI（<strong>U</strong>niform <strong>R</strong>esource <strong>I</strong>dentifier，统一资源标识符）的子集，URL 在 URI 的基础上增加了定位能力。URI 除了包含 URL，还包含 URN（Uniform Resource Name，统一资源名称），它只是用来定义一个资源的名称，并不具备定位该资源的能力。例如 urn:isbn: 0451450523 用来定义一个书籍名称，但是却没有表示怎么找到这本书。</p><ul><li><a href=https://zh.wikipedia.org/wiki/%e7%bb%9f%e4%b8%80%e8%b5%84%e6%ba%90%e6%a0%87%e5%bf%97%e7%ac%a6 target=_blank rel=noopener>wikipedia：统一资源标志符</a></li><li><a href=https://en.wikipedia.org/wiki/URL target=_blank rel=noopener>wikipedia: URL</a></li><li><a href=https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.2.2 target=_blank rel=noopener>rfc2616：3.2.2 http URL</a></li><li><a href=https://stackoverflow.com/questions/176264/what-is-the-difference-between-a-uri-a-url-and-a-urn target=_blank rel=noopener>What is the difference between a URI, a URL and a URN?</a></li></ul><h2 id=http-方法>HTTP 方法</h2><p>客户端发送的 <strong>请求报文</strong> 第一行为请求行，包含了方法字段。</p><h3 id=get>GET</h3><blockquote><p>获取资源</p></blockquote><p>当前网络请求中，绝大部分使用的是 GET 方法。</p><h3 id=head>HEAD</h3><blockquote><p>获取报文首部</p></blockquote><p>和 GET 方法类似，但是不返回报文实体主体部分。</p><p>主要用于确认 URL 的有效性以及资源更新的日期时间等。</p><h3 id=post>POST</h3><blockquote><p>传输实体主体</p></blockquote><p>POST 主要用来传输数据，而 GET 主要用来获取资源。</p><p>更多 POST 与 GET 的比较请见第九章。</p><h3 id=put>PUT</h3><blockquote><p>上传文件</p></blockquote><p>由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>PUT /new.html HTTP/1.1
</span></span><span style=display:flex><span>Host: example.com
</span></span><span style=display:flex><span>Content-type: text/html
</span></span><span style=display:flex><span>Content-length: 16
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>&lt;<span style=color:#f92672>p</span>&gt;New File&lt;/<span style=color:#f92672>p</span>&gt;
</span></span></code></pre></div><h3 id=patch>PATCH</h3><blockquote><p>对资源进行部分修改</p></blockquote><p>PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>PATCH /file.txt HTTP/1.1
</span></span><span style=display:flex><span>Host: www.example.com
</span></span><span style=display:flex><span>Content-Type: application/example
</span></span><span style=display:flex><span>If-Match: &#34;e0023aa4e&#34;
</span></span><span style=display:flex><span>Content-Length: 100
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[description of changes]
</span></span></code></pre></div><h3 id=delete>DELETE</h3><blockquote><p>删除文件</p></blockquote><p>与 PUT 功能相反，并且同样不带验证机制。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>DELETE /file.html HTTP/1.1
</span></span></code></pre></div><h3 id=options>OPTIONS</h3><blockquote><p>查询支持的方法</p></blockquote><p>查询指定的 URL 能够支持的方法。</p><p>会返回 <code>Allow: GET, POST, HEAD, OPTIONS</code> 这样的内容。</p><h3 id=connect>CONNECT</h3><blockquote><p>要求在与代理服务器通信时建立隧道</p></blockquote><p>使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>CONNECT www.example.com:443 HTTP/1.1
</span></span></code></pre></div><h3 id=trace>TRACE</h3><blockquote><p>追踪路径</p></blockquote><p>服务器会将通信路径返回给客户端。</p><p>发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。</p><p>通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。</p><ul><li><a href=https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html target=_blank rel=noopener>rfc2616：9 Method Definitions</a></li></ul><h2 id=http-状态码>HTTP 状态码</h2><blockquote><p>服务器返回的 <strong>响应报文</strong> 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。</p></blockquote><table><thead><tr><th>状态码</th><th>类别</th><th>含义</th></tr></thead><tbody><tr><td>1XX</td><td>Informational（信息性状态码）</td><td>接收的请求正在处理</td></tr><tr><td>2XX</td><td>Success（成功状态码）</td><td>请求正常处理完毕</td></tr><tr><td>3XX</td><td>Redirection（重定向状态码）</td><td>需要进行附加操作以完成请求</td></tr><tr><td>4XX</td><td>Client Error（客户端错误状态码）</td><td>服务器无法处理请求</td></tr><tr><td>5XX</td><td>Server Error（服务器错误状态码）</td><td>服务器处理请求出错</td></tr></tbody></table><h3 id=1xx-信息>1XX 信息</h3><ul><li><strong>100 Continue</strong> ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</li></ul><h3 id=2xx-成功>2XX 成功</h3><ul><li><p><strong>200 OK</strong></p></li><li><p><strong>204 No Content</strong> ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</p></li><li><p><strong>206 Partial Content</strong> ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。</p></li></ul><h3 id=3xx-重定向>3XX 重定向</h3><ul><li><p><strong>301 Moved Permanently</strong> ：永久性重定向</p></li><li><p><strong>302 Found</strong> ：临时性重定向</p></li><li><p><strong>303 See Other</strong> ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。</p></li><li><p>注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。</p></li><li><p><strong>304 Not Modified</strong> ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。</p></li><li><p><strong>307 Temporary Redirect</strong> ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。</p></li></ul><h3 id=4xx-客户端错误>4XX 客户端错误</h3><ul><li><p><strong>400 Bad Request</strong> ：请求报文中存在语法错误。</p></li><li><p><strong>401 Unauthorized</strong> ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。</p></li><li><p><strong>403 Forbidden</strong> ：请求被拒绝。</p></li><li><p><strong>404 Not Found</strong></p></li></ul><h3 id=5xx-服务器错误>5XX 服务器错误</h3><ul><li><p><strong>500 Internal Server Error</strong> ：服务器正在执行请求时发生错误。</p></li><li><p><strong>503 Service Unavailable</strong> ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</p></li></ul><h2 id=http-首部>HTTP 首部</h2><p>有 4 种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段。</p><p>各种首部字段及其含义如下（不需要全记，仅供查阅）：</p><h3 id=通用首部字段>通用首部字段</h3><table><thead><tr><th>首部字段名</th><th>说明</th></tr></thead><tbody><tr><td>Cache-Control</td><td>控制缓存的行为</td></tr><tr><td>Connection</td><td>控制不再转发给代理的首部字段、管理持久连接</td></tr><tr><td>Date</td><td>创建报文的日期时间</td></tr><tr><td>Pragma</td><td>报文指令</td></tr><tr><td>Trailer</td><td>报文末端的首部一览</td></tr><tr><td>Transfer-Encoding</td><td>指定报文主体的传输编码方式</td></tr><tr><td>Upgrade</td><td>升级为其他协议</td></tr><tr><td>Via</td><td>代理服务器的相关信息</td></tr><tr><td>Warning</td><td>错误通知</td></tr></tbody></table><h3 id=请求首部字段>请求首部字段</h3><table><thead><tr><th>首部字段名</th><th>说明</th></tr></thead><tbody><tr><td>Accept</td><td>用户代理可处理的媒体类型</td></tr><tr><td>Accept-Charset</td><td>优先的字符集</td></tr><tr><td>Accept-Encoding</td><td>优先的内容编码</td></tr><tr><td>Accept-Language</td><td>优先的语言（自然语言）</td></tr><tr><td>Authorization</td><td>Web 认证信息</td></tr><tr><td>Expect</td><td>期待服务器的特定行为</td></tr><tr><td>From</td><td>用户的电子邮箱地址</td></tr><tr><td>Host</td><td>请求资源所在服务器</td></tr><tr><td>If-Match</td><td>比较实体标记（ETag）</td></tr><tr><td>If-Modified-Since</td><td>比较资源的更新时间</td></tr><tr><td>If-None-Match</td><td>比较实体标记（与 If-Match 相反）</td></tr><tr><td>If-Range</td><td>资源未更新时发送实体 Byte 的范围请求</td></tr><tr><td>If-Unmodified-Since</td><td>比较资源的更新时间（与 If-Modified-Since 相反）</td></tr><tr><td>Max-Forwards</td><td>最大传输逐跳数</td></tr><tr><td>Proxy-Authorization</td><td>代理服务器要求客户端的认证信息</td></tr><tr><td>Range</td><td>实体的字节范围请求</td></tr><tr><td>Referer</td><td>对请求中 URI 的原始获取方</td></tr><tr><td>TE</td><td>传输编码的优先级</td></tr><tr><td>User-Agent</td><td>HTTP 客户端程序的信息</td></tr></tbody></table><h3 id=响应首部字段>响应首部字段</h3><table><thead><tr><th>首部字段名</th><th>说明</th></tr></thead><tbody><tr><td>Accept-Ranges</td><td>是否接受字节范围请求</td></tr><tr><td>Age</td><td>推算资源创建经过时间</td></tr><tr><td>ETag</td><td>资源的匹配信息</td></tr><tr><td>Location</td><td>令客户端重定向至指定 URI</td></tr><tr><td>Proxy-Authenticate</td><td>代理服务器对客户端的认证信息</td></tr><tr><td>Retry-After</td><td>对再次发起请求的时机要求</td></tr><tr><td>Server</td><td>HTTP 服务器的安装信息</td></tr><tr><td>Vary</td><td>代理服务器缓存的管理信息</td></tr><tr><td>WWW-Authenticate</td><td>服务器对客户端的认证信息</td></tr></tbody></table><h3 id=实体首部字段>实体首部字段</h3><table><thead><tr><th>首部字段名</th><th>说明</th></tr></thead><tbody><tr><td>Allow</td><td>资源可支持的 HTTP 方法</td></tr><tr><td>Content-Encoding</td><td>实体主体适用的编码方式</td></tr><tr><td>Content-Language</td><td>实体主体的自然语言</td></tr><tr><td>Content-Length</td><td>实体主体的大小</td></tr><tr><td>Content-Location</td><td>替代对应资源的 URI</td></tr><tr><td>Content-MD5</td><td>实体主体的报文摘要</td></tr><tr><td>Content-Range</td><td>实体主体的位置范围</td></tr><tr><td>Content-Type</td><td>实体主体的媒体类型</td></tr><tr><td>Expires</td><td>实体主体过期的日期时间</td></tr><tr><td>Last-Modified</td><td>资源的最后修改日期时间</td></tr></tbody></table><h2 id=具体应用>具体应用</h2><h3 id=连接管理>连接管理</h3><h4 id=短连接-与-长连接>#短连接 与 #长连接</h4><p>当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问的 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。</p><p>长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。</p><ul><li>从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 <code>Connection : close</code>；</li><li>在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 <code>Connection : Keep-Alive</code>。</li></ul><h4 id=流水线>#流水线</h4><p>默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。</p><p>流水线是在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟。</p><h3 id=cookie>#Cookie</h3><p>HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。</p><p>Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。</p><p>Cookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。</p><h4 id=用途>用途</h4><ul><li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li>个性化设置（如用户自定义设置、主题等）</li><li>浏览器行为跟踪（如跟踪分析用户行为等）</li></ul><h4 id=创建过程>创建过程</h4><p>服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>HTTP/1.0 200 OK
</span></span><span style=display:flex><span>Content-type: text/html
</span></span><span style=display:flex><span>Set-Cookie: yummy_cookie=choco
</span></span><span style=display:flex><span>Set-Cookie: tasty_cookie=strawberry
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[page content]
</span></span></code></pre></div><p>客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>GET /sample_page.html HTTP/1.1
</span></span><span style=display:flex><span>Host: www.example.org
</span></span><span style=display:flex><span>Cookie: yummy_cookie=choco; tasty_cookie=strawberry
</span></span></code></pre></div><h4 id=分类>分类</h4><ul><li>会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。</li><li>持久性 Cookie：指定过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;
</span></span></code></pre></div><h4 id=作用域>作用域</h4><p>Domain 标识指定了哪些主机可以接受 Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了 Domain，则一般包含子域名。例如，如果设置 Domain=mozilla. org，则 Cookie 也包含在子域名中（如 developer. mozilla. org）。</p><p>Path 标识指定了主机下的哪些路径可以接受 Cookie（该 URL 路径必须存在于请求 URL 中）。以字符 %x2F ("/") 作为路径分隔符，子路径也会被匹配。例如，设置 Path=/docs，则以下地址都会匹配：</p><ul><li>/docs</li><li>/docs/Web/</li><li>/docs/Web/HTTP</li></ul><h4 id=javascript>JavaScript</h4><p>浏览器通过 <code>document.cookie</code> 属性可创建新的 Cookie，也可通过该属性访问非 HttpOnly 标记的 Cookie。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>document.cookie = &#34;yummy_cookie=choco&#34;;
</span></span><span style=display:flex><span>document.cookie = &#34;tasty_cookie=strawberry&#34;;
</span></span><span style=display:flex><span>console.log(document.cookie);
</span></span></code></pre></div><h4 id=httponly>HttpOnly</h4><p>标记为 HttpOnly 的 Cookie 不能被 JavaScript 脚本调用。跨站脚本攻击 (XSS) 常常使用 JavaScript 的 <code>document.cookie</code> API 窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度上避免 XSS 攻击。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly
</span></span></code></pre></div><h4 id=secure>Secure</h4><p>标记为 Secure 的 Cookie 只能通过被 HTTPS 协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障。</p><h4 id=session>#Session</h4><p>除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。</p><p>Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。</p><p>使用 Session 维护用户登录状态的过程如下：</p><ul><li>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；</li><li>服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；</li><li>服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；</li><li>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。</li></ul><p>应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。</p><h4 id=浏览器禁用-cookie>浏览器禁用 Cookie</h4><p>此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递。</p><h4 id=cookie-与-session-选择>Cookie 与 Session 选择</h4><ul><li>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；</li><li>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；</li><li>对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。</li></ul><h3 id=缓存>缓存</h3><h4 id=优点>优点</h4><ul><li>缓解服务器压力；</li><li>降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并且缓存服务器在地理位置上也有可能比源服务器来得近，例如浏览器缓存。</li></ul><h4 id=实现方法>实现方法</h4><ul><li>让代理服务器进行缓存；</li><li>让客户端浏览器进行缓存。</li></ul><h4 id=cache-control>Cache-Control</h4><p>HTTP/1.1 通过 Cache-Control 首部字段来控制缓存。</p><p><strong>禁止进行缓存</strong></p><p>no-store 指令规定不能对请求或响应的任何一部分进行缓存。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>Cache-Control: no-store
</span></span></code></pre></div><p><strong>强制确认缓存</strong></p><p>no-cache 指令规定缓存服务器需要先向源服务器验证缓存资源的有效性，只有当缓存资源有效时才能使用该缓存对客户端的请求进行响应。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>Cache-Control: no-cache
</span></span></code></pre></div><p><strong>私有缓存和公共缓存</strong></p><p>private 指令规定了将资源作为私有缓存，只能被单独用户使用，一般存储在用户浏览器中。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>Cache-Control: private
</span></span></code></pre></div><p>public 指令规定了将资源作为公共缓存，可以被多个用户使用，一般存储在代理服务器中。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>Cache-Control: public
</span></span></code></pre></div><p><strong>缓存过期机制</strong></p><p>max-age 指令出现在请求报文，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。</p><p>max-age 指令出现在响应报文，表示缓存资源在缓存服务器中保存的时间。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>Cache-Control: max-age=31536000
</span></span></code></pre></div><p>Expires 首部字段也可以用于告知缓存服务器该资源什么时候会过期。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>Expires: Wed, 04 Jul 2012 08:26:05 GMT
</span></span></code></pre></div><ul><li>在 HTTP/1.1 中，会优先处理 max-age 指令；</li><li>在 HTTP/1.0 中，max-age 指令会被忽略掉。</li></ul><h4 id=缓存验证>缓存验证</h4><p>需要先了解 ETag 首部字段的含义，它是资源的唯一标识。URL 不能唯一表示资源，例如 <code>http://www.google.com/</code> 有中文和英文两个资源，只有 ETag 才能对这两个资源进行唯一标识。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>ETag: &#34;82e22293907ce725faf67773957acd12&#34;
</span></span></code></pre></div><p>可以将缓存资源的 ETag 值放入 If-None-Match 首部，服务器收到该请求后，判断缓存资源的 ETag 值和资源的最新 ETag 值是否一致，如果一致则表示缓存资源有效，返回 304 Not Modified。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>If-None-Match: &#34;82e22293907ce725faf67773957acd12&#34;
</span></span></code></pre></div><p>Last-Modified 首部字段也可以用于缓存验证，它包含在源服务器发送的响应报文中，指示源服务器对资源的最后修改时间。但是它是一种弱校验器，因为只能精确到一秒，所以它通常作为 ETag 的备用方案。如果响应首部字段里含有这个信息，客户端可以在后续的请求中带上 If-Modified-Since 来验证缓存。服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200 OK。如果请求的资源从那时起未经修改，那么返回一个不带有实体主体的 304 Not Modified 响应报文。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT
</span></span></code></pre></div><h3 id=通信数据转发>通信数据转发</h3><h4 id=代理>代理</h4><p>代理服务器接受客户端的请求，并且转发给其它服务器。</p><p>使用代理的主要目的是：</p><ul><li>缓存</li><li>负载均衡</li><li>网络访问控制</li><li>访问日志记录</li></ul><p>代理服务器分为正向代理和反向代理两种：</p><ul><li>用户察觉得到正向代理的存在</li><li>而反向代理一般位于内部网络中，用户察觉不到</li><li>正向代理代理的是客户端，反向代理代理的是服务端</li></ul><h4 id=网关>网关</h4><p>与代理服务器不同的是，网关服务器会将 HTTP 转化为其它协议进行通信，从而请求其它非 HTTP 服务器的服务。</p><h4 id=隧道>隧道</h4><p>使用 SSL 等加密手段，在客户端和服务器之间建立一条安全的通信线路。</p><h2 id=https>#HTTPS</h2><h2 id=get--post-比较>GET / POST 比较</h2><h3 id=作用>作用</h3><p>GET 用于获取资源，而 POST 用于传输实体主体。</p><h3 id=参数>参数</h3><p>GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。</p><p>因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 <code>中文</code> 会转换为 <code>%E4%B8%AD%E6%96%87</code>，而空格会转换为 <code>%20</code>。POST 参数支持标准字符集。</p><pre tabindex=0><code>GET /test/demo_form.asp?name1=value1&amp;name2=value2 HTTP/1.1
</code></pre><pre tabindex=0><code>POST /test/demo_form.asp HTTP/1.1
Host: w3schools.com
name1=value1&amp;name2=value2
</code></pre><h3 id=安全>安全</h3><p>安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。</p><p>GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。</p><p>安全的方法除了 GET 之外还有：HEAD、OPTIONS。</p><p>不安全的方法除了 POST 之外还有 PUT、DELETE。</p><h3 id=幂等性>幂等性</h3><p>幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。</p><p>所有的安全方法也都是幂等的。</p><p>在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。</p><p>GET /pageX HTTP/1.1 是幂等的，连续调用多次，客户端接收到的结果都是一样的：</p><pre tabindex=0><code>GET /pageX HTTP/1.1
GET /pageX HTTP/1.1
GET /pageX HTTP/1.1
GET /pageX HTTP/1.1
</code></pre><p>POST /add_row HTTP/1.1 不是幂等的，如果调用多次，就会增加多行记录：</p><pre tabindex=0><code>POST /add_row HTTP/1.1   -&gt; Adds a 1nd row
POST /add_row HTTP/1.1   -&gt; Adds a 2nd row
POST /add_row HTTP/1.1   -&gt; Adds a 3rd row
</code></pre><p>DELETE /idX/delete HTTP/1.1 是幂等的，即使不同的请求接收到的状态码不一样：</p><pre tabindex=0><code>DELETE /idX/delete HTTP/1.1   -&gt; Returns 200 if idX exists
DELETE /idX/delete HTTP/1.1   -&gt; Returns 404 as it just got deleted
DELETE /idX/delete HTTP/1.1   -&gt; Returns 404
</code></pre><h3 id=可缓存>可缓存</h3><p>如果要对响应进行缓存，需要满足以下条件：</p><ul><li>请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。</li><li>响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。</li><li>响应报文的 Cache-Control 首部字段没有指定不进行缓存。</li></ul><h3 id=xmlhttprequest>XMLHttpRequest</h3><p>为了阐述 POST 和 GET 的另一个区别，需要先了解 XMLHttpRequest：</p><blockquote><p>XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。</p></blockquote><ul><li>在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。</li><li>而 GET 方法 Header 和 Data 会一起发送。</li></ul><h2 id=http-版本变化>HTTP 版本变化</h2><h1 id=tcpudp>TCP/UDP</h1><p>#网络 #tcp #udp</p><h2 id=tcp>TCP</h2><h1 id=网络io演进历程>网络IO演进历程</h1><p>#epoll #linux #网络 #网络模型</p><h2 id=网络-io-模型演进>网络 IO 模型演进</h2><ol><li>阻塞 IO #BIO (Blocking IO)</li><li>非阻塞 IO #NIO (Nonblocking IO)</li><li>IO 多路复用第一版 #select / #poll / #epoll</li><li>异步 IO #AIO (Async IO)</li></ol><p><img src=%E8%AE%A1%E7%AE%97%E6%9C%BA/img/io_comparison.png alt=io></p><h2 id=bio>BIO</h2><blockquote><p>阻塞 IO，顾名思义当用户发生了系统调用后，如果数据未从网卡到达内核态，内核态数据未准备好，此时会一直阻塞。直到数据就绪，然后从内核态拷贝到用户态再返回。</p></blockquote><p><img src=%E8%AE%A1%E7%AE%97%E6%9C%BA/img/bio.png alt=bio></p><ul><li>BIO 缺点，能支持的并发连接数比较少：<ul><li>一台服务器能分配的线程数是有限的</li><li>大量线程频繁切换上下文会影响性能</li></ul></li></ul><blockquote><p>核心矛盾：一个 client 分配一个线程是因为处理客户端读写是阻塞式的，为避免该阻塞影响接受后续新的 client 的连接，所以将阻塞逻辑交由单独的线程处理。</p></blockquote><h2 id=nio>NIO</h2><blockquote><p>非阻塞 IO：见名知意，就是在第一阶段 (网卡-内核态) 数据未到达时不等待，然后直接返回。因此非阻塞 IO 需要不断的用户发起请求，轮询内核。</p></blockquote><p><img src=%E8%AE%A1%E7%AE%97%E6%9C%BA/img/nio.png alt=nio></p><ul><li>优点：将 socket 设为非阻塞后，在读取时如果数据未就绪就直接返回。可以通过一个线程管理多个 client 连接。</li><li>缺点：需要不断轮询内核，数据是否已经就绪，会造成很多无效的，太频繁的系统调用 (system call) 而造成资源浪费。</li></ul><h2 id=selectpollepoll>select/poll/epoll</h2><p><img src=%E8%AE%A1%E7%AE%97%E6%9C%BA/img/poll.png alt=poll></p><ul><li><code>select</code> 和 <code>poll</code> 的区别<ul><li><code>select</code> 能处理的最大连接，默认是 <code>1024</code> 个，可以通过修改配置来改变，但终究是有限个；而 <code>poll</code> 理论上可以支持无限个</li><li><code>select</code> 和 <code>poll</code> 在管理海量的连接时，会频繁的从用户态拷贝到内核态，比较消耗资源</li></ul></li></ul><p><code>epoll</code> 对文件描述符的操作有两种模式：<code> LT（level trigger）</code>和 <code>ET（edge trigger）</code>。</p><ul><li><code>LT 模式</code>：当 <code>epoll_wait</code> 检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用 <code>epoll_wait</code> 时，会再次响应应用程序并通知此事件。</li><li><code>ET 模式</code>：当 <code>epoll_wait</code> 检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用 <code>epoll_wait</code> 时，不会再次响应应用程序并通知此事件。</li></ul><blockquote><p>简言之：边沿触发仅触发一次，水平触发会一直触发。</p></blockquote><p><code>epoll</code> 高效的本质在于：</p><ul><li>减少了用户态和内核态的文件句柄拷贝</li><li>减少了对可读可写文件句柄的遍历</li><li><code>mmap</code> 加速了内核与用户空间的信息传递，<code>epoll</code> 是通过内核与用户 <code>mmap</code> 同一块内存，避免了无谓的内存拷贝</li><li><code>IO</code>性能不会随着监听的文件描述的数量增长而下降</li><li>使用红黑树存储fd，以及对应的回调函数，其插入，查找，删除的性能不错，相比于hash，不必预先分配很多的空间</li></ul><table><thead><tr><th>-</th><th><code>select</code></th><th><code>poll</code></th><th><code>epoll</code></th></tr></thead><tbody><tr><td>操作方式</td><td>遍历</td><td>遍历</td><td>回调</td></tr><tr><td>底层实现</td><td>数组</td><td>链表</td><td>哈希表</td></tr><tr><td>IO 效率</td><td>每次调用都进行线性遍历，时间复杂度为 O (n)</td><td>每次调用都进行线性遍历，时间复杂度为 O (n)</td><td>事件通知方式，每当 <code>fd</code> 就绪，系统注册的回调函数就会被调用，将就绪 <code>fd</code> 放到 <code>rdllist</code> 里面。时间复杂度 O (1)</td></tr><tr><td>最大连接数</td><td>1024（x86）或 2048（x64）</td><td>无上限</td><td>无上限</td></tr><tr><td>fd 拷贝</td><td>每次调用 <code>select</code>，都需要把 fd 集合从用户态拷贝到内核态</td><td>每次调用 <code>poll</code>，都需要把 <code>fd</code> 集合从用户态拷贝到内核态</td><td>调用 <code>epoll_ctl</code> 时拷贝进内核并保存，之后每次 <code>epoll_wait</code> 不拷贝</td></tr></tbody></table><h2 id=aio>AIO</h2><p>异步 IO
<img src=%E8%AE%A1%E7%AE%97%E6%9C%BA/img/aio.png alt=aio></p><h1 id=c>C++</h1><p>#CPP #编程语言</p><h1 id=go-gmp-调度模型>Go GMP 调度模型</h1><p>#go #golang #gmp #scheduler #抢占式调度 #goroutine #协程 #gmp</p><blockquote><p>所谓 <code>GMP</code>，其中 <code>G</code> 是指 <code>goroutine</code>；<code>M</code> 是 <code>Machine</code> 的缩写，指的是工作线程；<code>P</code> 则是指处理器 <code>Processor</code>，代表了一组资源，<code>M</code> 要想执行 <code>G</code> 的代码，必须持有一个 <code>P</code> 才行。</p></blockquote><blockquote><p>简单来说，<code>GMP</code> 就是 <code>Task</code>、<code>Worker</code>、<code>Resource</code> 的关系，<code>G</code> 和 <code>P</code> 都是 <code>Go</code> 语言实现的抽象程度更高的组件，对于工作线程而言，<code>Machine</code> 一词表明了它与具体的操作系统和平台密切相关，对具体平台的适配和特殊处理等大多在这一层实现。</p></blockquote><h2 id=从-gm-到-gmp>从 GM 到 GMP</h2><h3 id=gm-模型调度的几个明显问题>GM 模型调度的几个明显问题</h3><ol><li>用一个全局的 <code>mutex</code> 保护一个全局的 <code>runq</code>（就绪队列），造成对锁的竞争异常严重</li><li><code>G</code> 每次执行都会被分发到随机的 <code>M</code> 上，造成在不同 <code>M</code> 之间频繁切换，破坏了程序的局部性</li><li>每个 <code>M</code> 都会关联一个内存分配缓存 <code>mcache</code>，造成大量内存开销，进一步使数据的局部性变差。实际上只有执行 <code>Go</code> 代码的 <code>M</code> 才真正需要 <code>mcache</code>，那些阻塞在系统调用中的 <code>M</code> 根本不需要，而实际执行 <code>Go</code> 代码的 <code>M</code> 可能仅占总数的 <code>1%</code></li><li>在存在系统调用的情况下，工作线程经常被阻塞和解除阻塞，从而增加了很多开销</li></ol><blockquote><p>通过 <code>runtime.GOMAXPROCS()</code> 函数可以精准的控制 <code>P</code> 的个数</p></blockquote><h2 id=gmp-的数据结构>GMP 的数据结构</h2><h3 id=g>G</h3><h4 id=源码>源码</h4><p><code>runtime.g</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>g</span> <span style=color:#66d9ef>struct</span> {  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// Stack parameters.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// stack describes the actual stack memory: [stack.lo, stack.hi).  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// stackguard0 is the stack pointer compared in the Go stack growth prologue.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// stackguard1 is the stack pointer compared in the C stack growth prologue.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// It is stack.lo+StackGuard on g0 and gsignal stacks.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// It is ~0 on other goroutine stacks, to trigger a call to morestackc (and crash).  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>stack</span>       <span style=color:#a6e22e>stack</span>   <span style=color:#75715e>// offset known to runtime/cgo  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>stackguard0</span> <span style=color:#66d9ef>uintptr</span> <span style=color:#75715e>// offset known to liblink  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>stackguard1</span> <span style=color:#66d9ef>uintptr</span> <span style=color:#75715e>// offset known to liblink  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>_panic</span>    <span style=color:#f92672>*</span><span style=color:#a6e22e>_panic</span> <span style=color:#75715e>// innermost panic - offset known to liblink  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>_defer</span>    <span style=color:#f92672>*</span><span style=color:#a6e22e>_defer</span> <span style=color:#75715e>// innermost defer  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>m</span>         <span style=color:#f92672>*</span><span style=color:#a6e22e>m</span>      <span style=color:#75715e>// current m; offset known to arm liblink  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>sched</span>     <span style=color:#a6e22e>gobuf</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>syscallsp</span> <span style=color:#66d9ef>uintptr</span> <span style=color:#75715e>// if status==Gsyscall, syscallsp = sched.sp to use during gc   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>syscallpc</span> <span style=color:#66d9ef>uintptr</span> <span style=color:#75715e>// if status==Gsyscall, syscallpc = sched.pc to use during gc   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>stktopsp</span>  <span style=color:#66d9ef>uintptr</span> <span style=color:#75715e>// expected sp at top of stack, to check in traceback  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// param is a generic pointer parameter field used to pass   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// values in particular contexts where other storage for the   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// parameter would be difficult to find. It is currently used   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// in three ways:   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// 1. When a channel operation wakes up a blocked goroutine, it sets param to   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>//    point to the sudog of the completed blocking operation.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// 2. By gcAssistAlloc1 to signal back to its caller that the goroutine completed   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>//    the GC cycle. It is unsafe to do so in any other way, because the goroutine&#39;s   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>//    stack may have moved in the meantime.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// 3. By debugCallWrap to pass parameters to a new goroutine because allocating a   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>//    closure in the runtime is forbidden.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>param</span>        <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>atomicstatus</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Uint32</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>stackLock</span>    <span style=color:#66d9ef>uint32</span> <span style=color:#75715e>// sigprof/scang lock; TODO: fold in to atomicstatus  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>goid</span>         <span style=color:#66d9ef>uint64</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>schedlink</span>    <span style=color:#a6e22e>guintptr</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>waitsince</span>    <span style=color:#66d9ef>int64</span>      <span style=color:#75715e>// approx time when the g become blocked   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>waitreason</span>   <span style=color:#a6e22e>waitReason</span> <span style=color:#75715e>// if status==Gwaiting  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>preempt</span>       <span style=color:#66d9ef>bool</span> <span style=color:#75715e>// preemption signal, duplicates stackguard0 = stackpreempt   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>preemptStop</span>   <span style=color:#66d9ef>bool</span> <span style=color:#75715e>// transition to _Gpreempted on preemption; otherwise, just 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>deschedule</span>   <span style=color:#a6e22e>preemptShrink</span> <span style=color:#66d9ef>bool</span> <span style=color:#75715e>// shrink stack at synchronous safe point  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// asyncSafePoint is set if g is stopped at an asynchronous   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// safe point. This means there are frames on the stack  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// without precise pointer information.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>asyncSafePoint</span> <span style=color:#66d9ef>bool</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>paniconfault</span> <span style=color:#66d9ef>bool</span> <span style=color:#75715e>// panic (instead of crash) on unexpected fault address  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>gcscandone</span>   <span style=color:#66d9ef>bool</span> <span style=color:#75715e>// g has scanned stack; protected by _Gscan bit in status   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>throwsplit</span>   <span style=color:#66d9ef>bool</span> <span style=color:#75715e>// must not split stack  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// activeStackChans indicates that there are unlocked channels   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// pointing into this goroutine&#39;s stack. If true, stack  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// copying needs to acquire channel locks to protect these  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// areas of the stack.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>activeStackChans</span> <span style=color:#66d9ef>bool</span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// parkingOnChan indicates that the goroutine is about to   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// park on a chansend or chanrecv. Used to signal an unsafe point  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// for stack shrinking.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>parkingOnChan</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Bool</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>raceignore</span>     <span style=color:#66d9ef>int8</span>     <span style=color:#75715e>// ignore race detection events  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>sysblocktraced</span> <span style=color:#66d9ef>bool</span>     <span style=color:#75715e>// StartTrace has emitted EvGoInSyscall about this goroutine   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>tracking</span>       <span style=color:#66d9ef>bool</span>     <span style=color:#75715e>// whether we&#39;re tracking this G for sched latency statistics   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>trackingSeq</span>    <span style=color:#66d9ef>uint8</span>    <span style=color:#75715e>// used to decide whether to track this G  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>trackingStamp</span>  <span style=color:#66d9ef>int64</span>    <span style=color:#75715e>// timestamp of when the G last started being tracked  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>runnableTime</span>   <span style=color:#66d9ef>int64</span>    <span style=color:#75715e>// the amount of time spent runnable, cleared when running, only used when tracking  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>sysexitticks</span>   <span style=color:#66d9ef>int64</span>    <span style=color:#75715e>// cputicks when syscall has returned (for tracing)   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>traceseq</span>       <span style=color:#66d9ef>uint64</span>   <span style=color:#75715e>// trace event sequencer   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>tracelastp</span>     <span style=color:#a6e22e>puintptr</span> <span style=color:#75715e>// last P emitted an event for this goroutine  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>lockedm</span>        <span style=color:#a6e22e>muintptr</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>sig</span>            <span style=color:#66d9ef>uint32</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>writebuf</span>       []<span style=color:#66d9ef>byte</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>sigcode0</span>       <span style=color:#66d9ef>uintptr</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>sigcode1</span>       <span style=color:#66d9ef>uintptr</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>sigpc</span>          <span style=color:#66d9ef>uintptr</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>gopc</span>           <span style=color:#66d9ef>uintptr</span>         <span style=color:#75715e>// pc of go statement that created this goroutine  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>ancestors</span>      <span style=color:#f92672>*</span>[]<span style=color:#a6e22e>ancestorInfo</span> <span style=color:#75715e>// ancestor information goroutine(s) that created this goroutine (only used if debug.tracebackancestors)  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>startpc</span>        <span style=color:#66d9ef>uintptr</span>         <span style=color:#75715e>// pc of goroutine function  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>racectx</span>        <span style=color:#66d9ef>uintptr</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>waiting</span>        <span style=color:#f92672>*</span><span style=color:#a6e22e>sudog</span>         <span style=color:#75715e>// sudog structures this g is waiting on (that have a valid elem ptr); in lock order   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>cgoCtxt</span>        []<span style=color:#66d9ef>uintptr</span>      <span style=color:#75715e>// cgo traceback context   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>labels</span>         <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> <span style=color:#75715e>// profiler labels  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>timer</span>          <span style=color:#f92672>*</span><span style=color:#a6e22e>timer</span>         <span style=color:#75715e>// cached timer for time.Sleep  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>selectDone</span>     <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Uint32</span>  <span style=color:#75715e>// are we participating in a select and did someone win the race?  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// goroutineProfiled indicates the status of this goroutine&#39;s stack for the   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// current in-progress goroutine profile   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>goroutineProfiled</span> <span style=color:#a6e22e>goroutineProfileStateHolder</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// Per-G GC state  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// gcAssistBytes is this G&#39;s GC assist credit in terms of   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// bytes allocated. If this is positive, then the G has credit   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// to allocate gcAssistBytes bytes without assisting. If this   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// is negative, then the G must correct this by performing   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// scan work. We track this in bytes to make it fast to update   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// and check for debt in the malloc hot path. The assist ratio   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// determines how this corresponds to scan work debt.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>gcAssistBytes</span> <span style=color:#66d9ef>int64</span>  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=部分字段用途>部分字段用途</h4><ul><li><code>stack</code>：描述了 <code>goroutine</code> 的栈空间</li><li><code>stackguard0</code>：</li><li><code>stackguard1</code>：原理同 <code>stackguard0</code> 差不多，只不过是被 <code>g0</code> 和 <code>gsignal</code> 中的 <code>C</code> 代码使用</li><li><code>m</code>：关联到正在执行当前 <code>G</code> 的工作线程 <code>M</code></li><li><code>sched</code>：被调度器用来保存 goroutine 的执行上下文</li><li><code>atomicstatus</code>：用来表示当前 <code>G</code> 的状态</li><li><code>goid</code>：当前 <code>goroutine</code> 的全局唯一 ID</li><li><code>schedlink</code>：被调度器用于实现内部链表、队列，对应的 <code>gunitptr</code> 类型从逻辑上等价于 <code>*g</code>，而底层类型却是个 <code>uintptr</code>，这样是为了避免写障碍</li><li><code>preempt</code>：为 <code>true</code> 时，调度器会在合适的时机触发一次抢占</li><li><code>lockedm</code>：关联到与当前 <code>G</code> 绑定的 <code>M</code>，可参考 <code>LockOSThread</code></li><li><code>waiting</code>：主要用于实现 <code>channel</code> 中的等待队列</li><li><code>timer</code>：<code>runtime</code> 内部实现的计时器类型，主要用来支持 <code>time.Sleep</code></li></ul><h4 id=atomicstatus-字段的取值及其含义>atomicstatus 字段的取值及其含义</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>const</span> (  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// G status  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>//   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// Beyond indicating the general state of a G, the G status   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// acts like a lock on the goroutine&#39;s stack (and hence its   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// ability to execute user code).   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>//   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// If you add to this list, add to the list   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// of &#34;okay during garbage collection&#34; status   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// in mgcmark.go too.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>//   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// TODO(austin): The _Gscan bit could be much lighter-weight.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// For example, we could choose not to run _Gscanrunnable   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// goroutines found in the run queue, rather than CAS-looping   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// until they become _Grunnable. And transitions like   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// _Gscanwaiting -&gt; _Gscanrunnable are actually okay because   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// they don&#39;t affect stack ownership.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// _Gidle means this goroutine was just allocated and has not   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// yet been initialized.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>_Gidle</span> = <span style=color:#66d9ef>iota</span> <span style=color:#75715e>// 0  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// _Grunnable means this goroutine is on a run queue. It is   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// not currently executing user code. The stack is not owned.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>_Grunnable</span> <span style=color:#75715e>// 1  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// _Grunning means this goroutine may execute user code. The   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// stack is owned by this goroutine. It is not on a run queue.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// It is assigned an M and a P (g.m and g.m.p are valid).   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>_Grunning</span> <span style=color:#75715e>// 2  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// _Gsyscall means this goroutine is executing a system call.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// It is not executing user code. The stack is owned by this   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// goroutine. It is not on a run queue. It is assigned an M.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>_Gsyscall</span> <span style=color:#75715e>// 3  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// _Gwaiting means this goroutine is blocked in the runtime.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// It is not executing user code. It is not on a run queue,   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// but should be recorded somewhere (e.g., a channel wait   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// queue) so it can be ready()d when necessary. The stack is   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// not owned *except* that a channel operation may read or   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// write parts of the stack under the appropriate channel   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// lock. Otherwise, it is not safe to access the stack after a   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// goroutine enters _Gwaiting (e.g., it may get moved).   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>_Gwaiting</span> <span style=color:#75715e>// 4  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// _Gmoribund_unused is currently unused, but hardcoded in gdb   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// scripts.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>_Gmoribund_unused</span> <span style=color:#75715e>// 5  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// _Gdead means this goroutine is currently unused. It may be   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// just exited, on a free list, or just being initialized. It   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// is not executing user code. It may or may not have a stack  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// allocated. The G and its stack (if any) are owned by the M   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// that is exiting the G or that obtained the G from the free   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// list.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>_Gdead</span> <span style=color:#75715e>// 6  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// _Genqueue_unused is currently unused.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>_Genqueue_unused</span> <span style=color:#75715e>// 7  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// _Gcopystack means this goroutine&#39;s stack is being moved. It   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// is not executing user code and is not on a run queue. The   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// stack is owned by the goroutine that put it in _Gcopystack.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>_Gcopystack</span> <span style=color:#75715e>// 8  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// _Gpreempted means this goroutine stopped itself for a   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// suspendG preemption. It is like _Gwaiting, but nothing is  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// yet responsible for ready()ing it. Some suspendG must CAS   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// the status to _Gwaiting to take responsibility for   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// ready()ing this G.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>_Gpreempted</span> <span style=color:#75715e>// 9  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// _Gscan combined with one of the above states other than   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// _Grunning indicates that GC is scanning the stack. The  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// goroutine is not executing user code and the stack is owned   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// by the goroutine that set the _Gscan bit.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>//   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// _Gscanrunning is different: it is used to briefly block  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// state transitions while GC signals the G to scan its own   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// stack. This is otherwise like _Grunning.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>//   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// atomicstatus&amp;~Gscan gives the state the goroutine will   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// return to when the scan completes.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>_Gscan</span>          = <span style=color:#ae81ff>0x1000</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>_Gscanrunnable</span>  = <span style=color:#a6e22e>_Gscan</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>_Grunnable</span>  <span style=color:#75715e>// 0x1001  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>_Gscanrunning</span>   = <span style=color:#a6e22e>_Gscan</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>_Grunning</span>   <span style=color:#75715e>// 0x1002  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>_Gscansyscall</span>   = <span style=color:#a6e22e>_Gscan</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>_Gsyscall</span>   <span style=color:#75715e>// 0x1003  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>_Gscanwaiting</span>   = <span style=color:#a6e22e>_Gscan</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>_Gwaiting</span>   <span style=color:#75715e>// 0x1004  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>_Gscanpreempted</span> = <span style=color:#a6e22e>_Gscan</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>_Gpreempted</span> <span style=color:#75715e>// 0x1009  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>)
</span></span></code></pre></div><ul><li></li></ul><p>G 几种暂停的方式：</p><ul><li><code>gosched</code>：将当前的 <code>G</code> 暂停，保存堆栈状态，以 <code>_Grunable</code> 状态放入 Global 队列中，让当前 <code>M</code> 继续执行其他任务。无需对 <code>G</code> 执行唤醒操作，因为总会有 <code>M</code> 从 Global 队列取得并执行 G，抢占调度即使用该方式。</li><li><code>gopark</code>：与 <code>gosched</code> 的最大区别在于 <code>gopark</code> 没有将 <code>G</code> 放回执行队列，而是位于某个等待队列中（如 <code>channel</code> 的 <code>waitq</code>，此时 <code>G</code> 状态为 <code>_Gwaitting</code>）, 因此 <code>G</code> 必须被手动唤醒（通过 <code>goready</code>），否则会丢失任务。应用层阻塞通常使用这种方式。</li><li><code>notesleep</code>：既不让出 <code>M</code>，也不让 <code>G</code> 和 <code>P</code> 重新调度，直接让线程休眠直到被唤醒（<code>notewakeup</code>），该方式更快，通常用于 <code>gcMark</code>，<code>stopm</code> 这类自旋场景。</li><li><code>notesleepg</code>：阻塞 <code>G</code> 和 <code>M</code>，放开 <code>P</code>，<code>P</code> 可以和其它 <code>M</code> 绑定继续执行，比如可能阻塞的系统调用会主动调用 <code>entersyscallblock</code>，则会触发 <code>notesleepg</code>。</li><li><code>goexit</code>：立即终止 <code>G</code> 任务，不管其处于调用堆栈的哪个层次，在终止前，确保所有 <code>defer</code> 正确执行。</li></ul><h3 id=m>M</h3><h4 id=源码-1>源码</h4><p><code>runtime.m</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>m</span> <span style=color:#66d9ef>struct</span> {  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>g0</span>      <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>     <span style=color:#75715e>// goroutine with scheduling stack  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>morebuf</span> <span style=color:#a6e22e>gobuf</span>  <span style=color:#75715e>// gobuf arg to morestack  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>divmod</span>  <span style=color:#66d9ef>uint32</span> <span style=color:#75715e>// div/mod denominator for arm - known to liblink  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>_</span>       <span style=color:#66d9ef>uint32</span> <span style=color:#75715e>// align next field to 8 bytes  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// Fields not known to debuggers.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>procid</span>        <span style=color:#66d9ef>uint64</span>            <span style=color:#75715e>// for debuggers, but offset not hard-coded  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>gsignal</span>       <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>                <span style=color:#75715e>// signal-handling g  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>goSigStack</span>    <span style=color:#a6e22e>gsignalStack</span>      <span style=color:#75715e>// Go-allocated signal handling stack  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>sigmask</span>       <span style=color:#a6e22e>sigset</span>            <span style=color:#75715e>// storage for saved signal mask  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>tls</span>           [<span style=color:#a6e22e>tlsSlots</span>]<span style=color:#66d9ef>uintptr</span> <span style=color:#75715e>// thread-local storage (for x86 extern register)  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>mstartfn</span>      <span style=color:#66d9ef>func</span>()  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>curg</span>          <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>       <span style=color:#75715e>// current running goroutine  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>caughtsig</span>     <span style=color:#a6e22e>guintptr</span> <span style=color:#75715e>// goroutine running during fatal signal   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>p</span>             <span style=color:#a6e22e>puintptr</span> <span style=color:#75715e>// attached p for executing go code (nil if not executing go code)   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>nextp</span>         <span style=color:#a6e22e>puintptr</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>oldp</span>          <span style=color:#a6e22e>puintptr</span> <span style=color:#75715e>// the p that was attached before executing a syscall  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>id</span>            <span style=color:#66d9ef>int64</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>mallocing</span>     <span style=color:#66d9ef>int32</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>throwing</span>      <span style=color:#a6e22e>throwType</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>preemptoff</span>    <span style=color:#66d9ef>string</span> <span style=color:#75715e>// if != &#34;&#34;, keep curg running on this m  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>locks</span>         <span style=color:#66d9ef>int32</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>dying</span>         <span style=color:#66d9ef>int32</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>profilehz</span>     <span style=color:#66d9ef>int32</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>spinning</span>      <span style=color:#66d9ef>bool</span> <span style=color:#75715e>// m is out of work and is actively looking for work  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>blocked</span>       <span style=color:#66d9ef>bool</span> <span style=color:#75715e>// m is blocked on a note  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>newSigstack</span>   <span style=color:#66d9ef>bool</span> <span style=color:#75715e>// minit on C thread called sigaltstack  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>printlock</span>     <span style=color:#66d9ef>int8</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>incgo</span>         <span style=color:#66d9ef>bool</span>          <span style=color:#75715e>// m is executing a cgo call   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>isextra</span>       <span style=color:#66d9ef>bool</span>          <span style=color:#75715e>// m is an extra m  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>freeWait</span>      <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Uint32</span> <span style=color:#75715e>// Whether it is safe to free g0 and delete m (one of freeMRef, freeMStack, freeMWait)  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>fastrand</span>      <span style=color:#66d9ef>uint64</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>needextram</span>    <span style=color:#66d9ef>bool</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>traceback</span>     <span style=color:#66d9ef>uint8</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>ncgocall</span>      <span style=color:#66d9ef>uint64</span>        <span style=color:#75715e>// number of cgo calls in total  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>ncgo</span>          <span style=color:#66d9ef>int32</span>         <span style=color:#75715e>// number of cgo calls currently in progress  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>cgoCallersUse</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Uint32</span> <span style=color:#75715e>// if non-zero, cgoCallers in use temporarily   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>cgoCallers</span>    <span style=color:#f92672>*</span><span style=color:#a6e22e>cgoCallers</span>   <span style=color:#75715e>// cgo traceback if crashing in cgo call   park          note  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>alllink</span>       <span style=color:#f92672>*</span><span style=color:#a6e22e>m</span> <span style=color:#75715e>// on allm  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>schedlink</span>     <span style=color:#a6e22e>muintptr</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>lockedg</span>       <span style=color:#a6e22e>guintptr</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>createstack</span>   [<span style=color:#ae81ff>32</span>]<span style=color:#66d9ef>uintptr</span> <span style=color:#75715e>// stack that created this thread.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>lockedExt</span>     <span style=color:#66d9ef>uint32</span>      <span style=color:#75715e>// tracking for external LockOSThread  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>lockedInt</span>     <span style=color:#66d9ef>uint32</span>      <span style=color:#75715e>// tracking for internal lockOSThread  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>nextwaitm</span>     <span style=color:#a6e22e>muintptr</span>    <span style=color:#75715e>// next m waiting for lock  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>waitunlockf</span>   <span style=color:#66d9ef>func</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>, <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>) <span style=color:#66d9ef>bool</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>waitlock</span>      <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>waittraceev</span>   <span style=color:#66d9ef>byte</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>waittraceskip</span> <span style=color:#66d9ef>int</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>startingtrace</span> <span style=color:#66d9ef>bool</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>syscalltick</span>   <span style=color:#66d9ef>uint32</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>freelink</span>      <span style=color:#f92672>*</span><span style=color:#a6e22e>m</span> <span style=color:#75715e>// on sched.freem  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// these are here because they are too large to be on the stack  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// of low-level NOSPLIT functions.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>libcall</span>   <span style=color:#a6e22e>libcall</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>libcallpc</span> <span style=color:#66d9ef>uintptr</span> <span style=color:#75715e>// for cpu profiler  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>libcallsp</span> <span style=color:#66d9ef>uintptr</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>libcallg</span>  <span style=color:#a6e22e>guintptr</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>syscall</span>   <span style=color:#a6e22e>libcall</span> <span style=color:#75715e>// stores syscall parameters on windows  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>vdsoSP</span> <span style=color:#66d9ef>uintptr</span> <span style=color:#75715e>// SP for traceback while in VDSO call (0 if not in call)   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>vdsoPC</span> <span style=color:#66d9ef>uintptr</span> <span style=color:#75715e>// PC for traceback while in VDSO call  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   
</span></span><span style=display:flex><span>   <span style=color:#75715e>// preemptGen counts the number of completed preemption   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// signals. This is used to detect when a preemption is   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// requested, but fails.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>preemptGen</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Uint32</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// Whether this is a pending preemption signal on this M.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>signalPending</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Uint32</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>dlogPerM</span>  
</span></span><span style=display:flex><span>   
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>mOS</span>  
</span></span><span style=display:flex><span>   
</span></span><span style=display:flex><span>   <span style=color:#75715e>// Up to 10 locks held by this m, maintained by the lock ranking code.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>locksHeldLen</span> <span style=color:#66d9ef>int</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>locksHeld</span>    [<span style=color:#ae81ff>10</span>]<span style=color:#a6e22e>heldLockInfo</span>  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=部分字段用途-1>部分字段用途</h4><ul><li><code>g0</code>：并不是一个真正的 <code>goroutine</code>，他的栈是由操作系统分配的，初始大小比普通 <code>goroutine</code> 的栈要大，被用作调度器执行的栈</li><li><code>gsignal</code>：本质上是用来处理信号的栈，因为一些 <code>UNIX</code> 系统支持位信号处理器配置独立的栈</li><li><code>curg </code>：指向 <code>M </code>当前正在执行的 <code>G</code></li><li><code>p</code>：<code>GMP</code> 中的 <code>P</code>，即关联当当前 <code>M</code> 上的处理器</li><li><code>nextp</code>：用来将 <code>P</code> 传递给 <code>M</code>，调度器一般是在 <code>M</code> 阻塞时为 <code>m.nextp</code> 赋值，等到 <code>M</code> 开始运行后会尝试从 <code>nextp</code> 处获取 <code>P</code> 进行关联</li><li><code>oldp</code>：用来暂存执行系统调用之前关联的 <code>P</code></li><li><code>id</code>：<code>M</code> 的唯一 <code>ID</code></li><li><code>preemptoff</code>：不为空时表示要关闭对 <code>curg</code> 的抢占，字符串内容给出了相关的原因</li><li><code>locks</code>：记录了当前 <code>M</code> 持有的锁数量，不为 0 时能够阻止抢占发生</li><li><code>spinning</code>：表示当前 <code>M</code> 正处于自旋状态</li><li><code>park</code>：用来支持 <code>M</code> 的挂起与唤醒，可以很方便的实现每个 <code>M</code> 的单独挂起与唤醒</li><li><code>alllink</code>：把所有的 <code>M</code> 连起来，构成 <code>allm</code> 链表</li><li><code>schedlink</code>：被调度器用来实现链表，如空闲的 <code>M</code> 链表</li><li><code>lockedg</code>：关联到与当前 <code>M</code> 绑定的 <code>G</code>，可参考 <code>LockOSThread</code></li><li><code>freelink</code>：用来把已经退出运行的 <code>M</code> 连起来，构成 <code>sched.freem</code> 链表，方便下次分配时复用</li></ul><h3 id=p>P</h3><h4 id=源码-2>源码</h4><p><code>runtime.p</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>p</span> <span style=color:#66d9ef>struct</span> {  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>id</span>          <span style=color:#66d9ef>int32</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>status</span>      <span style=color:#66d9ef>uint32</span> <span style=color:#75715e>// one of pidle/prunning/...  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>link</span>        <span style=color:#a6e22e>puintptr</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>schedtick</span>   <span style=color:#66d9ef>uint32</span>     <span style=color:#75715e>// incremented on every scheduler call  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>syscalltick</span> <span style=color:#66d9ef>uint32</span>     <span style=color:#75715e>// incremented on every system call  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>sysmontick</span>  <span style=color:#a6e22e>sysmontick</span> <span style=color:#75715e>// last tick observed by sysmon  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>m</span>           <span style=color:#a6e22e>muintptr</span>   <span style=color:#75715e>// back-link to associated m (nil if idle)   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>mcache</span>      <span style=color:#f92672>*</span><span style=color:#a6e22e>mcache</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>pcache</span>      <span style=color:#a6e22e>pageCache</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>raceprocctx</span> <span style=color:#66d9ef>uintptr</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>deferpool</span>    []<span style=color:#f92672>*</span><span style=color:#a6e22e>_defer</span> <span style=color:#75715e>// pool of available defer structs (see panic.go)  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>deferpoolbuf</span> [<span style=color:#ae81ff>32</span>]<span style=color:#f92672>*</span><span style=color:#a6e22e>_defer</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// Cache of goroutine ids, amortizes accesses to runtime·sched.goidgen.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>goidcache</span>    <span style=color:#66d9ef>uint64</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>goidcacheend</span> <span style=color:#66d9ef>uint64</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// Queue of runnable goroutines. Accessed without lock.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>runqhead</span> <span style=color:#66d9ef>uint32</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>runqtail</span> <span style=color:#66d9ef>uint32</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>runq</span>     [<span style=color:#ae81ff>256</span>]<span style=color:#a6e22e>guintptr</span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// runnext, if non-nil, is a runnable G that was ready&#39;d by  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// the current G and should be run next instead of what&#39;s in   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// runq if there&#39;s time remaining in the running G&#39;s time   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// slice. It will inherit the time left in the current time  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// slice. If a set of goroutines is locked in a  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// communicate-and-wait pattern, this schedules that set as a   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// unit and eliminates the (potentially large) scheduling   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// latency that otherwise arises from adding the ready&#39;d  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// goroutines to the end of the run queue.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>//   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// Note that while other P&#39;s may atomically CAS this to zero,   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// only the owner P can CAS it to a valid G.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>runnext</span> <span style=color:#a6e22e>guintptr</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// Available G&#39;s (status == Gdead)   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>gFree</span> <span style=color:#66d9ef>struct</span> {  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>gList</span>  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>n</span> <span style=color:#66d9ef>int32</span>  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>sudogcache</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>sudog</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>sudogbuf</span>   [<span style=color:#ae81ff>128</span>]<span style=color:#f92672>*</span><span style=color:#a6e22e>sudog</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// Cache of mspan objects from the heap.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>mspancache</span> <span style=color:#66d9ef>struct</span> {  
</span></span><span style=display:flex><span>      <span style=color:#75715e>// We need an explicit length here because this field is used  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>// in allocation codepaths where write barriers are not allowed,      
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>// and eliminating the write barrier/keeping it eliminated from      
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>// slice updates is tricky, moreso than just managing the length      
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>// ourselves.      
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#a6e22e>len</span> <span style=color:#66d9ef>int</span>  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>buf</span> [<span style=color:#ae81ff>128</span>]<span style=color:#f92672>*</span><span style=color:#a6e22e>mspan</span>  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>tracebuf</span> <span style=color:#a6e22e>traceBufPtr</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// traceSweep indicates the sweep events should be traced.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// This is used to defer the sweep start event until a span   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// has actually been swept.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>traceSweep</span> <span style=color:#66d9ef>bool</span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// traceSwept and traceReclaimed track the number of bytes  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// swept and reclaimed by sweeping in the current sweep loop.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>traceSwept</span>, <span style=color:#a6e22e>traceReclaimed</span> <span style=color:#66d9ef>uintptr</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>palloc</span> <span style=color:#a6e22e>persistentAlloc</span> <span style=color:#75715e>// per-P to avoid mutex  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// The when field of the first entry on the timer heap.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// This is 0 if the timer heap is empty.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>timer0When</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Int64</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// The earliest known nextwhen field of a timer with   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// timerModifiedEarlier status. Because the timer may have been   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// modified again, there need not be any timer with this value.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// This is 0 if there are no timerModifiedEarlier timers.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>timerModifiedEarliest</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Int64</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// Per-P GC state   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>gcAssistTime</span>         <span style=color:#66d9ef>int64</span> <span style=color:#75715e>// Nanoseconds in assistAlloc  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>gcFractionalMarkTime</span> <span style=color:#66d9ef>int64</span> <span style=color:#75715e>// Nanoseconds in fractional mark worker (atomic)  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// limiterEvent tracks events for the GC CPU limiter.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>limiterEvent</span> <span style=color:#a6e22e>limiterEvent</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// gcMarkWorkerMode is the mode for the next mark worker to run in.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// That is, this is used to communicate with the worker goroutine   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// selected for immediate execution by   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// gcController.findRunnableGCWorker. When scheduling other goroutines,   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// this field must be set to gcMarkWorkerNotWorker.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>gcMarkWorkerMode</span> <span style=color:#a6e22e>gcMarkWorkerMode</span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// gcMarkWorkerStartTime is the nanotime() at which the most recent  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// mark worker started.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>gcMarkWorkerStartTime</span> <span style=color:#66d9ef>int64</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// gcw is this P&#39;s GC work buffer cache. The work buffer is   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// filled by write barriers, drained by mutator assists, and   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// disposed on certain GC state transitions.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>gcw</span> <span style=color:#a6e22e>gcWork</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// wbBuf is this P&#39;s GC write barrier buffer.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>//   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// TODO: Consider caching this in the running G.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>wbBuf</span> <span style=color:#a6e22e>wbBuf</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>runSafePointFn</span> <span style=color:#66d9ef>uint32</span> <span style=color:#75715e>// if 1, run sched.safePointFn at next safe point  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// statsSeq is a counter indicating whether this P is currently   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// writing any stats. Its value is even when not, odd when it is.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>statsSeq</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Uint32</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// Lock for timers. We normally access the timers while running   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// on this P, but the scheduler can also do it from a different P.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>timersLock</span> <span style=color:#a6e22e>mutex</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// Actions to take at some time. This is used to implement the  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// standard library&#39;s time package.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// Must hold timersLock to access.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>timers</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>timer</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// Number of timers in P&#39;s heap.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>numTimers</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Uint32</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// Number of timerDeleted timers in P&#39;s heap.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>deletedTimers</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Uint32</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// Race context used while executing timer functions.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>timerRaceCtx</span> <span style=color:#66d9ef>uintptr</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// maxStackScanDelta accumulates the amount of stack space held by   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// live goroutines (i.e. those eligible for stack scanning).   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// Flushed to gcController.maxStackScan once maxStackScanSlack  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// or -maxStackScanSlack is reached.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>maxStackScanDelta</span> <span style=color:#66d9ef>int64</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// gc-time statistics about current goroutines  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// Note that this differs from maxStackScan in that this   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// accumulates the actual stack observed to be used at GC time (hi - sp),   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// not an instantaneous measure of the total stack size that might need   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// to be scanned (hi - lo).   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>scannedStackSize</span> <span style=color:#66d9ef>uint64</span> <span style=color:#75715e>// stack size of goroutines scanned by this P   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>scannedStacks</span>    <span style=color:#66d9ef>uint64</span> <span style=color:#75715e>// number of goroutines scanned by this P  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// preempt is set to indicate that this P should be enter the   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// scheduler ASAP (regardless of what G is running on it).   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>preempt</span> <span style=color:#66d9ef>bool</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// pageTraceBuf is a buffer for writing out page allocation/free/scavenge traces.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>//   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// Used only if GOEXPERIMENT=pagetrace.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>pageTraceBuf</span> <span style=color:#a6e22e>pageTraceBuf</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// Padding is no longer needed. False sharing is now not a worry because p is large enough  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// that its size class is an integer multiple of the cache line size (for any of our architectures).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   }
</span></span></code></pre></div><h4 id=部分字段用途-2>部分字段用途</h4><ul><li><code>id</code>：<code>P</code> 的唯一 <code>ID</code>，等于当前 <code>P</code> 在 <code>allp</code> 中的数组下标</li><li><code>staus</code>： 表示 <code>P</code> 的状态</li><li><code>link</code>：是一个没有写屏障的指针，别调度器用来构造链表</li><li><code>schedtick</code>：记录了调度发生的次数，实际上在每一次发生 <code>goroutine</code> 切换且不继承时间片的情况下，该字段会加一</li><li><code>syscalltick</code>：每发生一次系统调用就会加一</li><li><code>sysmontick</code>：被监控线程用来存储上一次检查时的调度器时钟滴答，用以实现时间片算法</li><li><code>m</code>：本质上是个指针，反向关联到当前 <code>P</code> 绑定的 <code>M</code></li><li><code>goidcache</code>，<code>goidcacheend</code>：用来从全局 <code>sched</code>，<code>goidgen</code> 处申请 goid<code>，</code>分配空间，批量申请以减少全局范围的锁竞争</li><li><code>runqhead</code>，<code>runqtail</code>，<code>runq</code>：当前 <code>P</code> 的就绪队列，用一个数组和一头一尾两个下标实现了一个环形队列</li><li><code>runnext</code>：如果不为 <code>nil</code>，则指向一个被当前 <code>G</code> 准备好（就绪）的 <code>G</code>，接下来将会继承当前 <code>G</code> 的时间片开始运行。该字段的存在意义在于，假如有一组 <code>goroutine</code> 中有生产者和消费者，他们在一个 <code>channel</code> 上频繁地等待和唤醒，那么调度器就会把他们作为一个单元来调度。每次使用 <code>runnext</code> 比添加到本地 <code>runq</code> 尾部能大幅减少延迟</li><li><code>gFree</code>：用来缓存已经退出运行的 <code>G</code>，方便再次分配时进行复用</li><li><code>preempt</code>：在 <code>Go1.14</code> 版本引入，以支持新的异步抢占机制</li></ul><h4 id=status-字段的取值及其含义>status 字段的取值及其含义</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>const</span> (  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// P status  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// _Pidle means a P is not being used to run user code or the   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// scheduler. Typically, it&#39;s on the idle P list and available   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// to the scheduler, but it may just be transitioning between   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// other states.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>//   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// The P is owned by the idle list or by whatever is   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// transitioning its state. Its run queue is empty.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>_Pidle</span> = <span style=color:#66d9ef>iota</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// _Prunning means a P is owned by an M and is being used to   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// run user code or the scheduler. Only the M that owns this P   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// is allowed to change the P&#39;s status from _Prunning. The M  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// may transition the P to _Pidle (if it has no more work to   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// do), _Psyscall (when entering a syscall), or _Pgcstop (to   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// halt for the GC). The M may also hand ownership of the P  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// off directly to another M (e.g., to schedule a locked G).   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>_Prunning</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// _Psyscall means a P is not running user code. It has   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// affinity to an M in a syscall but is not owned by it and   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// may be stolen by another M. This is similar to _Pidle but   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// uses lightweight transitions and maintains M affinity.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>//   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// Leaving _Psyscall must be done with a CAS, either to steal   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// or retake the P. Note that there&#39;s an ABA hazard: even if   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// an M successfully CASes its original P back to _Prunning  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// after a syscall, it must understand the P may have been  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// used by another M in the interim.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>_Psyscall</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// _Pgcstop means a P is halted for STW and owned by the M   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// that stopped the world. The M that stopped the world   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// continues to use its P, even in _Pgcstop. Transitioning  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// from _Prunning to _Pgcstop causes an M to release its P and   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// park.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>//   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// The P retains its run queue and startTheWorld will restart   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// the scheduler on Ps with non-empty run queues.   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>_Pgcstop</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// _Pdead means a P is no longer used (GOMAXPROCS shrank). We   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// reuse Ps if GOMAXPROCS increases. A dead P is mostly   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// stripped of its resources, though a few things remain   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// (e.g., trace buffers).   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>_Pdead</span>  
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><h1 id=go-netpoll-原生网络模型>Go netpoll 原生网络模型</h1><p>#go #golang #tcp #网络 #网络模型 #netpoll #epoll</p><h2 id=一个简单的-tcp-服务器>一个简单的 <code>TCP</code> 服务器</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>l</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>net</span>.<span style=color:#a6e22e>Listen</span>(<span style=color:#e6db74>&#34;tcp4&#34;</span>, <span style=color:#e6db74>&#34;:8000&#34;</span>)  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#a6e22e>err</span>)  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>func</span>() {  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>_</span> = <span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>Close</span>()  
</span></span><span style=display:flex><span>   }()  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;server listen port: 8000&#34;</span>)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>id</span> <span style=color:#66d9ef>int</span>  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>for</span> {  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>conn</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>Accept</span>()  
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {  
</span></span><span style=display:flex><span>         <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#a6e22e>err</span>)  
</span></span><span style=display:flex><span>      }  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>id</span><span style=color:#f92672>++</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>id</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>conn</span> <span style=color:#a6e22e>net</span>.<span style=color:#a6e22e>Conn</span>) {  
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>func</span>() {  
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>_</span> = <span style=color:#a6e22e>conn</span>.<span style=color:#a6e22e>Close</span>()  
</span></span><span style=display:flex><span>         }()  
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>packet</span> [<span style=color:#ae81ff>0xFFF</span>]<span style=color:#66d9ef>byte</span>  
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>for</span> {  
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>n</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>conn</span>.<span style=color:#a6e22e>Read</span>(<span style=color:#a6e22e>packet</span>[:])  
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {  
</span></span><span style=display:flex><span>               <span style=color:#66d9ef>return</span>  
</span></span><span style=display:flex><span>            }  
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>_</span> = <span style=color:#a6e22e>conn</span>.<span style=color:#a6e22e>Write</span>(<span style=color:#a6e22e>packet</span>[:<span style=color:#a6e22e>n</span>])  
</span></span><span style=display:flex><span>         }  
</span></span><span style=display:flex><span>      }(<span style=color:#a6e22e>id</span>, <span style=color:#a6e22e>conn</span>)  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=go-原子操作>Go 原子操作</h1><p>#go #golang #atomic #原子操作</p><h2 id=互斥锁跟原子操作的区别>互斥锁跟原子操作的区别</h2><p>在并发编程里，<code>Go</code> 语言 <code>sync</code> 包里的同步原语 <code>Mutex</code> 是我们经常用来保证并发安全的，但是他跟 <code>atomic</code> 包在使用目的和底层实现上都不一样：</p><table><thead><tr><th>&mdash;&ndash;</th><th>互斥锁</th><th>原子操作</th></tr></thead><tbody><tr><td>使用目的</td><td>保护一段逻辑</td><td>保护一个变量</td></tr><tr><td>底层实现</td><td>由操作系统的调度器实现</td><td>由底层硬件指令直接提供支持</td></tr><tr><td>相对性能</td><td>低</td><td>高</td></tr></tbody></table><p><code>Mutex</code> 由操作系统的调度器实现，而 <code>atomic</code> 包中的原子操作则由底层硬件指令直接提供支持，这些指令在执行的过程中是不允许中断的，因此原子操作可以在 <code>lock-free</code> 的情况下保证并发安全，并且它的性能也能做到随 <code>CPU</code> 个数的增多而线性扩展。</p><blockquote><p><strong>对于一个变量更新的保护，原子操作通常会更有效率，并且更能利用计算机多核的优势。</strong></p></blockquote><h2 id=性能对比测试>性能对比测试</h2><h3 id=互斥锁性能测试>互斥锁性能测试</h3><blockquote><p>使用 <code>sync</code> 包下面互斥锁的多线程加法操作</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>syncAdd</span>(<span style=color:#a6e22e>param</span> <span style=color:#66d9ef>int64</span>) <span style=color:#66d9ef>int64</span> {  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>wg</span> <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>WaitGroup</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>lock</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>Mutex</span>{}  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>10</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#ae81ff>1</span>)  
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {  
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>1000000</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {  
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>lock</span>.<span style=color:#a6e22e>Lock</span>()  
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>param</span><span style=color:#f92672>++</span>  
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>lock</span>.<span style=color:#a6e22e>Unlock</span>()  
</span></span><span style=display:flex><span>         }  
</span></span><span style=display:flex><span>         <span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Done</span>()  
</span></span><span style=display:flex><span>      }()  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Wait</span>()  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>param</span>  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>Benchmark</code> 测试方法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>BenchmarkSync</span>(<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>B</span>) {  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>N</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>flag</span> <span style=color:#f92672>:=</span> int64(<span style=color:#ae81ff>0</span>)  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>res</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>syncAdd</span>(<span style=color:#a6e22e>flag</span>)  
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>res</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>10000000</span> {  
</span></span><span style=display:flex><span>         <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;calculate result err: %d\n&#34;</span>, <span style=color:#a6e22e>res</span>)  
</span></span><span style=display:flex><span>      }  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>测试结果：</p><blockquote><p>根据运行环境和硬件性能会有所不同，这里是在相同环境下的对比</p></blockquote><ul><li>第一次</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>goos: darwin
</span></span><span style=display:flex><span>goarch: arm64
</span></span><span style=display:flex><span>pkg: wire/atomic_test
</span></span><span style=display:flex><span>BenchmarkSync
</span></span><span style=display:flex><span>BenchmarkSync-8 <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>862741542</span> ns/op
</span></span><span style=display:flex><span>PASS
</span></span></code></pre></div><ul><li>第二次</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>goos: darwin
</span></span><span style=display:flex><span>goarch: arm64
</span></span><span style=display:flex><span>pkg: wire/atomic_test
</span></span><span style=display:flex><span>BenchmarkSync
</span></span><span style=display:flex><span>BenchmarkSync-8 <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>875432729</span> ns/op
</span></span><span style=display:flex><span>PASS
</span></span></code></pre></div><ul><li>第三次</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>goos: darwin
</span></span><span style=display:flex><span>goarch: arm64
</span></span><span style=display:flex><span>pkg: wire/atomic_test
</span></span><span style=display:flex><span>BenchmarkSync
</span></span><span style=display:flex><span>BenchmarkSync-8 <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>836373292</span> ns/op
</span></span><span style=display:flex><span>PASS
</span></span></code></pre></div><p>三次取平均：<code>(862741542 + 875432729 + 836373292) / 3 = 858182521 ns/op</code></p><h3 id=原子操作性能测试>原子操作性能测试</h3><blockquote><p>使用 <code>atomic</code> 包下面原子操作的多线程加法操作</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>atomicAdd</span>(<span style=color:#a6e22e>param</span> <span style=color:#66d9ef>int64</span>) <span style=color:#66d9ef>int64</span> {  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>wg</span> <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>WaitGroup</span>  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>10</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#ae81ff>1</span>)  
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {  
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>1000000</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {  
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>AddInt64</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>param</span>, <span style=color:#ae81ff>1</span>)  
</span></span><span style=display:flex><span>         }  
</span></span><span style=display:flex><span>         <span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Done</span>()  
</span></span><span style=display:flex><span>      }()  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Wait</span>()  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>param</span>  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Benchmark 测试方法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>BenchmarkAtomic</span>(<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>B</span>) {  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>N</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>flag</span> <span style=color:#f92672>:=</span> int64(<span style=color:#ae81ff>0</span>)  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>res</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>atomicAdd</span>(<span style=color:#a6e22e>flag</span>)  
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>res</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>10000000</span> {  
</span></span><span style=display:flex><span>         <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;calculate result err: %d\n&#34;</span>, <span style=color:#a6e22e>res</span>)  
</span></span><span style=display:flex><span>      }  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>测试结果：</p><blockquote><p>根据运行环境和硬件性能会有所不同，这里是在相同环境下的对比</p></blockquote><ul><li>第一次</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>goos: darwin
</span></span><span style=display:flex><span>goarch: arm64
</span></span><span style=display:flex><span>pkg: wire/atomic_test
</span></span><span style=display:flex><span>BenchmarkAtomic
</span></span><span style=display:flex><span>BenchmarkAtomic-8 <span style=color:#ae81ff>4</span> <span style=color:#ae81ff>359013958</span> ns/op
</span></span><span style=display:flex><span>PASS
</span></span></code></pre></div><ul><li>第二次</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>goos: darwin
</span></span><span style=display:flex><span>goarch: arm64
</span></span><span style=display:flex><span>pkg: wire/atomic_test
</span></span><span style=display:flex><span>BenchmarkAtomic
</span></span><span style=display:flex><span>BenchmarkAtomic-8 <span style=color:#ae81ff>3</span> <span style=color:#ae81ff>359734514</span> ns/op
</span></span><span style=display:flex><span>PASS
</span></span></code></pre></div><ul><li>第三次</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>goos: darwin
</span></span><span style=display:flex><span>goarch: arm64
</span></span><span style=display:flex><span>pkg: wire/atomic_test
</span></span><span style=display:flex><span>BenchmarkAtomic
</span></span><span style=display:flex><span>BenchmarkAtomic-8 <span style=color:#ae81ff>4</span> <span style=color:#ae81ff>359007542</span> ns/op
</span></span><span style=display:flex><span>PASS
</span></span></code></pre></div><p>三次取平均：<code>(359013958 + 359734514 + 359007542) / 3 = 359252004 ns/op</code></p><h3 id=测试结果对比>测试结果对比</h3><p>根据测试结果数据使用互斥锁做累加每次循环耗时 <code>858182521 ns</code>，而使用原子操作做累加每次耗时 <code>359252004 ns</code>。</p><p>这也印证了之前说过的：<strong>互斥锁适用于来保护一段逻辑，原子操作适用于于对一个变量的更新保护。</strong></p><h2 id=原理浅析>原理浅析</h2><p>参考： <a href=https://ormissia.github.io/posts/knowledge/2001-go/006-atomic/#%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0 target=_blank rel=noopener>互斥锁跟原子操作的区别-底层实现</a></p><h2 id=参考链接>参考链接</h2><ul><li><a href=https://zhuanlan.zhihu.com/p/412666957 target=_blank rel=noopener>Golang五种原子性操作的用法详解</a></li></ul></div><div class=paginator><ul class="pagination pagination-default"><li class=page-item><a href=/notes/ aria-label=First class=page-link role=button><span aria-hidden=true>&#171;&#171;</span></a></li><li class=page-item><a href=/notes/page/4/ aria-label=Previous class=page-link role=button><span aria-hidden=true>&#171;</span></a></li><li class=page-item><a href=/notes/page/3/ aria-label="Page 3" class=page-link role=button>3</a></li><li class=page-item><a href=/notes/page/4/ aria-label="Page 4" class=page-link role=button>4</a></li><li class="page-item active"><a aria-current=page aria-label="Page 5" class=page-link role=button>5</a></li><li class=page-item><a href=/notes/page/6/ aria-label="Page 6" class=page-link role=button>6</a></li><li class=page-item><a href=/notes/page/7/ aria-label="Page 7" class=page-link role=button>7</a></li><li class=page-item><a href=/notes/page/6/ aria-label=Next class=page-link role=button><span aria-hidden=true>&#187;</span></a></li><li class=page-item><a href=/notes/page/8/ aria-label=Last class=page-link role=button><span aria-hidden=true>&#187;&#187;</span></a></li></ul></div></div></section></div><footer id=footer class="container-fluid text-center align-content-center footer pb-2"><div class="container pt-5"><div class="row text-left"><div class="col-md-4 col-sm-12"><h5>联系方式:</h5><ul><li><span>QQ: </span><span>1432050813</span></li><li><a href=mailto:ormissia@outlook.com target=_blank rel=noopener><span><i class="fas fa-envelope"></i></span> <span>ormissia@outlook.com</span></a></li></ul></div></div></div><hr><div class=container><p id=disclaimer><strong>免责声明:</strong> 老铁看到底了，要负责的哦</p></div><hr><div class=container><div class="row text-left"><div class=col-md-4><a id=theme href=https://github.com/hugo-toha/toha target=_blank rel=noopener><img src=/images/theme-logo_hu8376fd15465fef26ffe66b6bcf0ca686_13669_32x0_resize_box_3.png alt="Toha Theme Logo">
Toha</a></div><div class="col-md-4 text-center">© 2021 Copyright.</div><div class="col-md-4 text-right"><a id=hugo href=https://gohugo.io/ target=_blank rel=noopener>Powered by
<img src=/images/hugo-logo.svg alt="Hugo Logo" height=18></a></div></div></div></footer><script src=/application.dd14ce5884a636a7014ae8dc2953b8089e2c54e6449da331e2726c712c81c910.js integrity="sha256-3RTOWISmNqcBSujcKVO4CJ4sVOZEnaMx4nJscSyByRA=" defer></script></body></html>