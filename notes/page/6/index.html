<!doctype html><html lang=zh-cn><head><title>Notes</title>
<meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="ie=edge"><link rel=stylesheet href=/application.87ecd420aa4299c8e4b21123c5360ef38ce9d1370c88559d014914f4a65e6b89.css integrity="sha256-h+zUIKpCmcjkshEjxTYO84zp0TcMiFWdAUkU9KZea4k="><link rel=icon type=image/png href=/images/favicon_hu8376fd15465fef26ffe66b6bcf0ca686_13669_42x0_resize_box_3.png><meta property="og:title" content="Notes"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://ormissia.github.io/notes/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Notes"><meta name=twitter:description content><script>theme=localStorage.getItem("darkmode:color-scheme")||"system",theme=="system"&&(window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?theme="dark":theme="light"),document.documentElement.setAttribute("data-theme",theme)</script></head><body class="type-notes kind-section" data-spy=scroll data-target=#TableOfContents data-offset=80><div class="container-fluid bg-secondary wrapper"><nav class="navbar navbar-expand-xl top-navbar shadow" id=top-navbar><div class=container><button class="navbar-toggler navbar-light" id=sidebar-toggler type=button>
<i data-feather=sidebar></i>
</button>
<a class=navbar-brand href=/><img src=/images/ormissia_hu763a76473558eea2a316ef50b45aaecf_966068_42x0_resize_box_3.png id=logo alt=Logo>
Ormissia's Blog</a>
<button class="navbar-toggler navbar-light" id=navbar-toggler type=button data-toggle=collapse data-target=#top-nav-items aria-label=menu>
<i data-feather=menu></i></button><div class="collapse navbar-collapse dynamic-navbar" id=top-nav-items><ul class="nav navbar-nav ml-auto"><li class=nav-item><a class=nav-link href=/#home>主页</a></li><li class=nav-item><a class=nav-link href=/#about>技能</a></li><li class=nav-item><a class=nav-link href=/#recent-posts>最近</a></li><li class=nav-item><a class=nav-link href=/#education>历程</a></li><li class=nav-item><a class=nav-link href=/#projects>项目</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>更多的</a><div class=dropdown-menu aria-labelledby=navbarDropdown><a class=dropdown-item href=/#achievements>成就</a></div></li><div id=top-navbar-divider></div><li class=nav-item><a class=nav-link id=blog-link href=/posts>博文</a></li><li class=nav-item><a class=nav-link id=note-link href=/notes>笔记</a></li><li class=nav-item><a class=nav-link href=https://github.com/ormissia>GitHub</a></li></ul></div></div><img src=/images/ormissia_hu763a76473558eea2a316ef50b45aaecf_966068_42x0_resize_box_3.png class=d-none id=main-logo alt=Logo>
<img src=/images/ormissia_hu763a76473558eea2a316ef50b45aaecf_966068_42x0_resize_box_3.png class=d-none id=inverted-logo alt="Inverted Logo"></nav><section class=sidebar-section id=sidebar-section><div class=sidebar-holder><div class=sidebar id=sidebar><form class=mx-auto method=get action=/search><input type=text name=keyword placeholder=搜索 data-search id=search-box></form><div class=sidebar-tree><ul class=tree id=tree><li id=list-heading><a href=/notes data-filter=all>笔记</a></li><div class=subtree><li><i data-feather=plus-circle></i><a class=list-link href=/notes/go/> Go</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/go/basic/> Basics</a><ul><li><a class=list-link href=/notes/go/basic/basic/ title=Basic>Basic</a></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/go/advance/> Advance</a><ul><li><a class=list-link href=/notes/go/advance/time/ title=time>time</a></li><li><a class=list-link href=/notes/go/advance/gomod/ title="go mod">go mod</a></li><li><a class=list-link href=/notes/go/advance/chan/ title="go chan">go chan</a></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/go/algorithm/> Algorithm</a><ul><li><a class=list-link href=/notes/go/algorithm/basic/ title=Basic>Basic</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/java/> Java</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/java/basic/> Basics</a><ul><li><a class=list-link href=/notes/java/basic/basic_type/ title="Basic Types">Basic Types</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/scala/> Scala</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/scala/basic/> Basic</a><ul><li><a class=list-link href=/notes/scala/basic/basic_type/ title="Basic Types">Basic Types</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/python/> Python</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/python/basic/> Basic</a><ul><li><a class=list-link href=/notes/python/basic/basic/ title=Basic>Basic</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/js/> JavaScript</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/js/basic/> Basic</a><ul><li><a class=list-link href=/notes/js/basic/basic/ title=Basic>Basic</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/sql/> SQL</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/sql/dml/> DML</a><ul><li><a class=list-link href=/notes/sql/dml/dml/ title="SQL DML">SQL DML</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/linux/> Linux</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/linux/shell/> Shell</a><ul><li><a class=list-link href=/notes/linux/shell/basic/ title=Basic>Basic</a></li><li><a class=list-link href=/notes/linux/shell/advance/ title=Advance>Advance</a></li><li><a class=list-link href=/notes/linux/shell/vi/ title=vi>vi</a></li><li><a class=list-link href=/notes/linux/shell/script/ title=Script>Script</a></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/linux/system/> System</a><ul><li><a class=list-link href=/notes/linux/system/system/ title=Memory>Memory</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/hbase/> Hbase</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/hbase/shell/> Shell</a><ul><li><a class=list-link href=/notes/hbase/shell/basic/ title=Basic>Basic</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/notes/kafka/> Kafka</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/notes/kafka/shell/> Shell</a><ul><li><a class=list-link href=/notes/kafka/shell/basic/ title=Basic>Basic</a></li></ul></li></ul></li></div></ul></div></div></div></section><section class=content-section id=content-section><div class="content container-fluid" id=content><div class="container-fluid note-card-holder" id=note-card-holder><h1 id=go-同步原语与锁>Go 同步原语与锁</h1><p>#go #golang #锁 #互斥锁 #读写锁</p><h2 id=基本原语>基本原语</h2><h3 id=mutex>#Mutex</h3><h3 id=rwmutex>#RWMutex</h3><h2 id=扩展原语>扩展原语</h2><h1 id=go-开源项目>Go 开源项目</h1><p>#go #golang #开源</p><ol><li>Go</li><li>Kubernetes</li><li>Gin</li><li>Gorm</li><li>gnet</li><li>ants</li></ol><h1 id=go-汇编>Go 汇编</h1><p>#go #golang #汇编</p><h2 id=官方文档>官方文档</h2><p><a href=https://golang.google.cn/doc/asm target=_blank rel=noopener>链接</a></p><h1 id=go-语法>Go 语法</h1><p>#go #golang #语法 #编程语言</p><h2 id=设置代理>设置代理</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>go env -w GOPROXY<span style=color:#f92672>=</span>https://goproxy.cn,direct
</span></span></code></pre></div><h2 id=init--函数>init () 函数</h2><p><code>init()</code> 函数的执行顺序：</p><ul><li>对同一个 <code>go</code> 文件的 <code>init()</code> 调用顺序是从上到下的。</li><li>对同一个 <code>package</code> 中不同文件是按文件名字符串比较"从小到大"顺序调用各文件中的 <code>init()</code> 函数。</li><li>对于不同的 <code>package</code>，如果不相互依赖的话，按照 <code>main</code> 包中”先 <code>import</code> 的后调用”的顺序调用其包中的 <code>init()</code>，如果 <code>package</code> 存在依赖，则先调用最早被依赖的 <code>package</code> 中的 <code>init()</code>，最后调用 <code>main</code> 函数。</li><li><em>如果 <code>init</code> 函数中使用了 <code>println()</code> 或者 <code>print()</code> 你会发现在执行过程中这两个不会按照你想象中的顺序执行。这两个函数官方只推荐在测试环境中使用，对于正式环境不要使用。</em></li></ul><h2 id=基本类型>基本类型</h2><table><thead><tr><th>类型</th><th>长度</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>bool</td><td>1</td><td>false</td><td></td></tr><tr><td>byte</td><td>1</td><td>0</td><td>uint8</td></tr><tr><td>rune</td><td>4</td><td>0</td><td>Unicode Code Point, int32</td></tr><tr><td>int/uint</td><td>4/8</td><td>0</td><td>32 或 64 位</td></tr><tr><td>int8/uint8</td><td>1</td><td>0</td><td>-128 ~ 127, 0 ~ 255，byte是uint8 的别名</td></tr><tr><td>int16/uint16</td><td>2</td><td>0</td><td>-32768 ~ 32767, 0 ~ 65535</td></tr><tr><td>int32/uint32</td><td>4</td><td>0</td><td>-21亿~ 21亿, 0 ~ 42亿，rune是int32 的别名</td></tr><tr><td>int64/uint64</td><td>8</td><td>0</td><td></td></tr><tr><td>float32</td><td>4</td><td>0.0</td><td></td></tr><tr><td>float64</td><td>8</td><td>0.0</td><td></td></tr><tr><td>complex64</td><td>8</td><td></td><td></td></tr><tr><td>complex128</td><td>16</td><td></td><td></td></tr><tr><td>uintptr</td><td>4/8</td><td></td><td></td></tr><tr><td>array</td><td></td><td></td><td></td></tr><tr><td>struct</td><td></td><td></td><td></td></tr><tr><td>string</td><td></td><td>""</td><td></td></tr><tr><td>slice</td><td></td><td>nil</td><td></td></tr><tr><td>map</td><td></td><td>nil</td><td></td></tr><tr><td>channel</td><td></td><td>nil</td><td></td></tr><tr><td>interface</td><td></td><td>nil</td><td>接口</td></tr><tr><td>function</td><td></td><td>nil</td><td>函数</td></tr></tbody></table><h3 id=字符串转义符>字符串转义符</h3><table><thead><tr><th>转义符</th><th>含义</th></tr></thead><tbody><tr><td>\r</td><td>(回车符) 返回当前行行首</td></tr><tr><td>\n</td><td>（换行符）向下移动一个字符</td></tr><tr><td>\t</td><td>制表符</td></tr><tr><td>'</td><td>单引号</td></tr><tr><td>"</td><td>双引号</td></tr><tr><td>/</td><td>斜杠</td></tr></tbody></table><h2 id=切片>#切片</h2><h3 id=切片定义>切片定义</h3><ul><li>使用 <code>make</code> 声明</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// make中后两个参数为len和cap，后者可以省略
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>100</span>)
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// len允许运行时期动态指定
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>f</span>() {  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>_</span> = make([]<span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>l</span>())  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>l</span>() <span style=color:#66d9ef>int</span> {  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>使用字面值声明</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 中括号中不应有数字，加上数字则声明的是数组
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>}
</span></span></code></pre></div><ul><li>从现有的数组中声明</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> [<span style=color:#ae81ff>6</span>]<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>} 
</span></span><span style=display:flex><span><span style=color:#a6e22e>ns1</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>[<span style=color:#ae81ff>1</span>:<span style=color:#ae81ff>3</span>:<span style=color:#ae81ff>4</span>]  
</span></span><span style=display:flex><span><span style=color:#a6e22e>ns2</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>[<span style=color:#ae81ff>1</span>:<span style=color:#ae81ff>3</span>]  
</span></span><span style=display:flex><span><span style=color:#a6e22e>ns3</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>[:<span style=color:#ae81ff>3</span>]  
</span></span><span style=display:flex><span><span style=color:#a6e22e>ns4</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>[<span style=color:#ae81ff>1</span>:]  
</span></span><span style=display:flex><span><span style=color:#a6e22e>ns5</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>[:]
</span></span></code></pre></div><h3 id=切片的遍历>切片的遍历</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>}  
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>a</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>s</span> {  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;addr_i: %p\taddr_a: %p\n&#34;</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>s</span>[<span style=color:#a6e22e>i</span>], <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>a</span>)  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// 此处注意：如果需要修改slice中的值，修改a的值是不起作用的，需要使用索引修改原切片值  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>a</span><span style=color:#f92672>++</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>s</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>+=</span> <span style=color:#ae81ff>10</span>  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>s</span>)
</span></span></code></pre></div><p>控制台打印：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>addr_i: 0x140000a8030   addr_a: 0x140000a4008
</span></span><span style=display:flex><span>addr_i: 0x140000a8038   addr_a: 0x140000a4008
</span></span><span style=display:flex><span>addr_i: 0x140000a8040   addr_a: 0x140000a4008
</span></span><span style=display:flex><span>addr_i: 0x140000a8048   addr_a: 0x140000a4008
</span></span><span style=display:flex><span>addr_i: 0x140000a8050   addr_a: 0x140000a4008
</span></span><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#ae81ff>10</span> <span style=color:#ae81ff>11</span> <span style=color:#ae81ff>12</span> <span style=color:#ae81ff>13</span> 14<span style=color:#f92672>]</span>
</span></span></code></pre></div><blockquote><p>根据打印可以看出：上述代码中变量 <code>a</code> 的地址始终是相同的</p></blockquote><h3 id=切片的传递>切片的传递</h3><blockquote><p><code>go</code> 中函数参数传递方式都为值传递。而对于切片来说，切片的结构中传递的是一个具体数组的地址。<strong>如果函数中的切片发生扩容，那么扩容之后的操作对于函数外部是不可见的</strong>。</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go></code></pre></div><blockquote><p>如果需要将改动传递到函数外部，要么将修改后的切片作为值返回，要么参数定义时使用切片指针。</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go></code></pre></div><h3 id=源码>源码</h3><blockquote><p>源码参考 <a href=https://github.com/golang/go/tree/release-branch.go1.19 target=_blank rel=noopener>go version go1.19.2 darwin/arm64</a></p></blockquote><ul><li><a href=https://github.com/golang/go/blob/release-branch.go1.19/src/runtime/slice.go target=_blank rel=noopener>src/runtime/slice.go</a></li></ul><h4 id=切片数据结构>切片数据结构</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>slice</span> <span style=color:#66d9ef>struct</span> {  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>array</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>len</span>   <span style=color:#66d9ef>int</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>cap</span>   <span style=color:#66d9ef>int</span>  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=创建切片>创建切片</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>makeslice</span>(<span style=color:#a6e22e>et</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>_type</span>, <span style=color:#a6e22e>len</span>, <span style=color:#a6e22e>cap</span> <span style=color:#66d9ef>int</span>) <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> {  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>mem</span>, <span style=color:#a6e22e>overflow</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>math</span>.<span style=color:#a6e22e>MulUintptr</span>(<span style=color:#a6e22e>et</span>.<span style=color:#a6e22e>size</span>, uintptr(<span style=color:#a6e22e>cap</span>))  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>overflow</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>mem</span> &gt; <span style=color:#a6e22e>maxAlloc</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>len</span> &lt; <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>len</span> &gt; <span style=color:#a6e22e>cap</span> {  
</span></span><span style=display:flex><span>      <span style=color:#75715e>// NOTE: Produce a &#39;len out of range&#39; error instead of a  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>// &#39;cap out of range&#39; error when someone does make([]T, bignumber).      // &#39;cap out of range&#39; is true too, but since the cap is only being      // supplied implicitly, saying len is clearer.      // See golang.org/issue/4085.      mem, overflow := math.MulUintptr(et.size, uintptr(len))  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>overflow</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>mem</span> &gt; <span style=color:#a6e22e>maxAlloc</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>len</span> &lt; <span style=color:#ae81ff>0</span> {  
</span></span><span style=display:flex><span>         <span style=color:#a6e22e>panicmakeslicelen</span>()  
</span></span><span style=display:flex><span>      }  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>panicmakeslicecap</span>()  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>mallocgc</span>(<span style=color:#a6e22e>mem</span>, <span style=color:#a6e22e>et</span>, <span style=color:#66d9ef>true</span>)  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 64位
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>makeslice64</span>(<span style=color:#a6e22e>et</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>_type</span>, <span style=color:#a6e22e>len64</span>, <span style=color:#a6e22e>cap64</span> <span style=color:#66d9ef>int64</span>) <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> {  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>len</span> <span style=color:#f92672>:=</span> int(<span style=color:#a6e22e>len64</span>)  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> int64(<span style=color:#a6e22e>len</span>) <span style=color:#f92672>!=</span> <span style=color:#a6e22e>len64</span> {  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>panicmakeslicelen</span>()  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>cap</span> <span style=color:#f92672>:=</span> int(<span style=color:#a6e22e>cap64</span>)  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> int64(<span style=color:#a6e22e>cap</span>) <span style=color:#f92672>!=</span> <span style=color:#a6e22e>cap64</span> {  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>panicmakeslicecap</span>()  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>makeslice</span>(<span style=color:#a6e22e>et</span>, <span style=color:#a6e22e>len</span>, <span style=color:#a6e22e>cap</span>)  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=切片扩容>切片扩容</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// growslice handles slice growth during append.// It is passed the slice element type, the old slice, and the desired new minimum capacity,  
</span></span></span><span style=display:flex><span><span style=color:#75715e>// and it returns a new slice with at least that capacity, with the old data// copied into it.  
</span></span></span><span style=display:flex><span><span style=color:#75715e>// The new slice&#39;s length is set to the old slice&#39;s length,  
</span></span></span><span style=display:flex><span><span style=color:#75715e>// NOT to the new requested capacity.  
</span></span></span><span style=display:flex><span><span style=color:#75715e>// This is for codegen convenience. The old slice&#39;s length is used immediately  
</span></span></span><span style=display:flex><span><span style=color:#75715e>// to calculate where to write new values during an append.// TODO: When the old backend is gone, reconsider this decision.  
</span></span></span><span style=display:flex><span><span style=color:#75715e>// The SSA backend might prefer the new length or to return only ptr/cap and save stack space.func growslice(et *_type, old slice, cap int) slice {  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>raceenabled</span> {  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>callerpc</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getcallerpc</span>()  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>racereadrangepc</span>(<span style=color:#a6e22e>old</span>.<span style=color:#a6e22e>array</span>, uintptr(<span style=color:#a6e22e>old</span>.<span style=color:#a6e22e>len</span><span style=color:#f92672>*</span>int(<span style=color:#a6e22e>et</span>.<span style=color:#a6e22e>size</span>)), <span style=color:#a6e22e>callerpc</span>, <span style=color:#a6e22e>abi</span>.<span style=color:#a6e22e>FuncPCABIInternal</span>(<span style=color:#a6e22e>growslice</span>))  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>msanenabled</span> {  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>msanread</span>(<span style=color:#a6e22e>old</span>.<span style=color:#a6e22e>array</span>, uintptr(<span style=color:#a6e22e>old</span>.<span style=color:#a6e22e>len</span><span style=color:#f92672>*</span>int(<span style=color:#a6e22e>et</span>.<span style=color:#a6e22e>size</span>)))  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>asanenabled</span> {  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>asanread</span>(<span style=color:#a6e22e>old</span>.<span style=color:#a6e22e>array</span>, uintptr(<span style=color:#a6e22e>old</span>.<span style=color:#a6e22e>len</span><span style=color:#f92672>*</span>int(<span style=color:#a6e22e>et</span>.<span style=color:#a6e22e>size</span>)))  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>cap</span> &lt; <span style=color:#a6e22e>old</span>.<span style=color:#a6e22e>cap</span> {  
</span></span><span style=display:flex><span>      panic(<span style=color:#a6e22e>errorString</span>(<span style=color:#e6db74>&#34;growslice: cap out of range&#34;</span>))  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>et</span>.<span style=color:#a6e22e>size</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {  
</span></span><span style=display:flex><span>      <span style=color:#75715e>// append should not create a slice with nil pointer but non-zero len.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>// We assume that append doesn&#39;t need to preserve old.array in this case.      return slice{unsafe.Pointer(&amp;zerobase), old.len, cap}  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>newcap</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>old</span>.<span style=color:#a6e22e>cap</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>doublecap</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>newcap</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>newcap</span>  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>cap</span> &gt; <span style=color:#a6e22e>doublecap</span> {  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>newcap</span> = <span style=color:#a6e22e>cap</span>  
</span></span><span style=display:flex><span>   } <span style=color:#66d9ef>else</span> {  
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>threshold</span> = <span style=color:#ae81ff>256</span>  
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>old</span>.<span style=color:#a6e22e>cap</span> &lt; <span style=color:#a6e22e>threshold</span> {  
</span></span><span style=display:flex><span>         <span style=color:#a6e22e>newcap</span> = <span style=color:#a6e22e>doublecap</span>  
</span></span><span style=display:flex><span>      } <span style=color:#66d9ef>else</span> {  
</span></span><span style=display:flex><span>         <span style=color:#75715e>// Check 0 &lt; newcap to detect overflow  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>         <span style=color:#75715e>// and prevent an infinite loop.         for 0 &lt; newcap &amp;&amp; newcap &lt; cap {  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// Transition from growing 2x for small slices  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// to growing 1.25x for large slices. This formula            // gives a smooth-ish transition between the two.            newcap += (newcap + 3*threshold) / 4  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>         }  
</span></span><span style=display:flex><span>         <span style=color:#75715e>// Set newcap to the requested cap when  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>         <span style=color:#75715e>// the newcap calculation overflowed.         if newcap &lt;= 0 {  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>newcap</span> = <span style=color:#a6e22e>cap</span>  
</span></span><span style=display:flex><span>         }  
</span></span><span style=display:flex><span>      }  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>overflow</span> <span style=color:#66d9ef>bool</span>  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>lenmem</span>, <span style=color:#a6e22e>newlenmem</span>, <span style=color:#a6e22e>capmem</span> <span style=color:#66d9ef>uintptr</span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// Specialize for common values of et.size.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// For 1 we don&#39;t need any division/multiplication.   // For goarch.PtrSize, compiler will optimize division/multiplication into a shift by a constant.   // For powers of 2, use a variable shift.   switch {  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>et</span>.<span style=color:#a6e22e>size</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>:  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>lenmem</span> = uintptr(<span style=color:#a6e22e>old</span>.<span style=color:#a6e22e>len</span>)  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>newlenmem</span> = uintptr(<span style=color:#a6e22e>cap</span>)  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>capmem</span> = <span style=color:#a6e22e>roundupsize</span>(uintptr(<span style=color:#a6e22e>newcap</span>))  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>overflow</span> = uintptr(<span style=color:#a6e22e>newcap</span>) &gt; <span style=color:#a6e22e>maxAlloc</span>  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>newcap</span> = int(<span style=color:#a6e22e>capmem</span>)  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>et</span>.<span style=color:#a6e22e>size</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>goarch</span>.<span style=color:#a6e22e>PtrSize</span>:  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>lenmem</span> = uintptr(<span style=color:#a6e22e>old</span>.<span style=color:#a6e22e>len</span>) <span style=color:#f92672>*</span> <span style=color:#a6e22e>goarch</span>.<span style=color:#a6e22e>PtrSize</span>  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>newlenmem</span> = uintptr(<span style=color:#a6e22e>cap</span>) <span style=color:#f92672>*</span> <span style=color:#a6e22e>goarch</span>.<span style=color:#a6e22e>PtrSize</span>  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>capmem</span> = <span style=color:#a6e22e>roundupsize</span>(uintptr(<span style=color:#a6e22e>newcap</span>) <span style=color:#f92672>*</span> <span style=color:#a6e22e>goarch</span>.<span style=color:#a6e22e>PtrSize</span>)  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>overflow</span> = uintptr(<span style=color:#a6e22e>newcap</span>) &gt; <span style=color:#a6e22e>maxAlloc</span><span style=color:#f92672>/</span><span style=color:#a6e22e>goarch</span>.<span style=color:#a6e22e>PtrSize</span>  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>newcap</span> = int(<span style=color:#a6e22e>capmem</span> <span style=color:#f92672>/</span> <span style=color:#a6e22e>goarch</span>.<span style=color:#a6e22e>PtrSize</span>)  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>isPowerOfTwo</span>(<span style=color:#a6e22e>et</span>.<span style=color:#a6e22e>size</span>):  
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>shift</span> <span style=color:#66d9ef>uintptr</span>  
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>goarch</span>.<span style=color:#a6e22e>PtrSize</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>8</span> {  
</span></span><span style=display:flex><span>         <span style=color:#75715e>// Mask shift for better code generation.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>         <span style=color:#a6e22e>shift</span> = uintptr(<span style=color:#a6e22e>sys</span>.<span style=color:#a6e22e>Ctz64</span>(uint64(<span style=color:#a6e22e>et</span>.<span style=color:#a6e22e>size</span>))) <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>63</span>  
</span></span><span style=display:flex><span>      } <span style=color:#66d9ef>else</span> {  
</span></span><span style=display:flex><span>         <span style=color:#a6e22e>shift</span> = uintptr(<span style=color:#a6e22e>sys</span>.<span style=color:#a6e22e>Ctz32</span>(uint32(<span style=color:#a6e22e>et</span>.<span style=color:#a6e22e>size</span>))) <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>31</span>  
</span></span><span style=display:flex><span>      }  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>lenmem</span> = uintptr(<span style=color:#a6e22e>old</span>.<span style=color:#a6e22e>len</span>) <span style=color:#f92672>&lt;&lt;</span> <span style=color:#a6e22e>shift</span>  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>newlenmem</span> = uintptr(<span style=color:#a6e22e>cap</span>) <span style=color:#f92672>&lt;&lt;</span> <span style=color:#a6e22e>shift</span>  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>capmem</span> = <span style=color:#a6e22e>roundupsize</span>(uintptr(<span style=color:#a6e22e>newcap</span>) <span style=color:#f92672>&lt;&lt;</span> <span style=color:#a6e22e>shift</span>)  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>overflow</span> = uintptr(<span style=color:#a6e22e>newcap</span>) &gt; (<span style=color:#a6e22e>maxAlloc</span> <span style=color:#f92672>&gt;&gt;</span> <span style=color:#a6e22e>shift</span>)  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>newcap</span> = int(<span style=color:#a6e22e>capmem</span> <span style=color:#f92672>&gt;&gt;</span> <span style=color:#a6e22e>shift</span>)  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>default</span>:  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>lenmem</span> = uintptr(<span style=color:#a6e22e>old</span>.<span style=color:#a6e22e>len</span>) <span style=color:#f92672>*</span> <span style=color:#a6e22e>et</span>.<span style=color:#a6e22e>size</span>  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>newlenmem</span> = uintptr(<span style=color:#a6e22e>cap</span>) <span style=color:#f92672>*</span> <span style=color:#a6e22e>et</span>.<span style=color:#a6e22e>size</span>  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>capmem</span>, <span style=color:#a6e22e>overflow</span> = <span style=color:#a6e22e>math</span>.<span style=color:#a6e22e>MulUintptr</span>(<span style=color:#a6e22e>et</span>.<span style=color:#a6e22e>size</span>, uintptr(<span style=color:#a6e22e>newcap</span>))  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>capmem</span> = <span style=color:#a6e22e>roundupsize</span>(<span style=color:#a6e22e>capmem</span>)  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>newcap</span> = int(<span style=color:#a6e22e>capmem</span> <span style=color:#f92672>/</span> <span style=color:#a6e22e>et</span>.<span style=color:#a6e22e>size</span>)  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// The check of overflow in addition to capmem &gt; maxAlloc is needed  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// to prevent an overflow which can be used to trigger a segfault   // on 32bit architectures with this example program:   //   // type T [1&lt;&lt;27 + 1]int64   //   // var d T   // var s []T   //   // func main() {   //   s = append(s, d, d, d, d)   //   print(len(s), &#34;\n&#34;)   // }   if overflow || capmem &gt; maxAlloc {  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      panic(<span style=color:#a6e22e>errorString</span>(<span style=color:#e6db74>&#34;growslice: cap out of range&#34;</span>))  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>p</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>et</span>.<span style=color:#a6e22e>ptrdata</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>p</span> = <span style=color:#a6e22e>mallocgc</span>(<span style=color:#a6e22e>capmem</span>, <span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>false</span>)  
</span></span><span style=display:flex><span>      <span style=color:#75715e>// The append() that calls growslice is going to overwrite from old.len to cap (which will be the new length).  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>// Only clear the part that will not be overwritten.      memclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem)  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   } <span style=color:#66d9ef>else</span> {  
</span></span><span style=display:flex><span>      <span style=color:#75715e>// Note: can&#39;t use rawmem (which avoids zeroing of memory), because then GC can scan uninitialized memory.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#a6e22e>p</span> = <span style=color:#a6e22e>mallocgc</span>(<span style=color:#a6e22e>capmem</span>, <span style=color:#a6e22e>et</span>, <span style=color:#66d9ef>true</span>)  
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>lenmem</span> &gt; <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>writeBarrier</span>.<span style=color:#a6e22e>enabled</span> {  
</span></span><span style=display:flex><span>         <span style=color:#75715e>// Only shade the pointers in old.array since we know the destination slice p  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>         <span style=color:#75715e>// only contains nil pointers because it has been cleared during alloc.         bulkBarrierPreWriteSrcOnly(uintptr(p), uintptr(old.array), lenmem-et.size+et.ptrdata)  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      }  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>memmove</span>(<span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>old</span>.<span style=color:#a6e22e>array</span>, <span style=color:#a6e22e>lenmem</span>)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>slice</span>{<span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>old</span>.<span style=color:#a6e22e>len</span>, <span style=color:#a6e22e>newcap</span>}  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=map><code>map</code></h2><h3 id=map-定义>map 定义</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>m1</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>100</span>)   
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>m2</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>int</span>{  
</span></span><span style=display:flex><span>   <span style=color:#e6db74>&#34;a&#34;</span>: <span style=color:#ae81ff>1</span>,  
</span></span><span style=display:flex><span>   <span style=color:#e6db74>&#34;b&#34;</span>: <span style=color:#ae81ff>2</span>,  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=map-的基本使用>map 的基本使用</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>aValue</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>m</span>[<span style=color:#e6db74>&#34;a&#34;</span>]  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 第二个变量ok可用于判断当前key是否存在
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>bValue</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>m</span>[<span style=color:#e6db74>&#34;b&#34;</span>]
</span></span></code></pre></div><h2 id=map-的遍历>map 的遍历</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>k</span>, <span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>m</span> {  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>k</span>,<span style=color:#a6e22e>v</span>)  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=删除元素>删除元素</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>delete(<span style=color:#a6e22e>m</span>, <span style=color:#e6db74>&#34;a&#34;</span>)
</span></span></code></pre></div><h3 id=源码-1>源码</h3><blockquote><p>源码参考 <a href=https://github.com/golang/go/tree/release-branch.go1.19 target=_blank rel=noopener>go version go1.19.2 darwin/arm64</a></p></blockquote><ul><li><a href=https://github.com/golang/go/blob/release-branch.go1.19/src/runtime/map.go target=_blank rel=noopener>src/runtime/map.go</a></li></ul><h4 id=hash冲突>#hash冲突</h4><ul><li>#开放定址法 ：当要存储一对 <code>kv</code> ，发现 <code>hash(key)</code> 的下表已经被别的 <code>key</code> 占用时，就在这个数组中重新找空白没有被占用的位置存储这个 <code>key</code>。常见的有：<code>线性探测法</code>，<code>线性补偿探测法</code>， <code>随机探测法</code>。</li><li>#拉链法 ：可以简单理解成数组中元素指向链表的头结点的一种结构。当 <code>key</code> 发生 <code>hash</code> 冲突时，在冲突位置的元素上形成一个链表。当查找时，发现 <code>key</code> 冲突，顺着链表一直往下找，直到链表的尾节点，找不到则返回空。</li></ul><p>开放定址法和拉链法的优缺点：</p><ul><li>拉链法通常比线性探测法处理简单</li><li>线性探测查找是会被拉链法会更消耗时间</li><li>线性探测会更加容易导致扩容，而拉链不会</li><li>拉链存储了指针，所以空间上会比线性探测占用多一点</li><li>拉链是动态申请存储空间的，所以更适合链长不确定的</li></ul><h4 id=map-的结构>map 的结构</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// A header for a Go map.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>hmap</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Note: the format of the hmap is also encoded in cmd/compile/internal/reflectdata/reflect.go.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// Make sure this stays in sync with the compiler&#39;s definition.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>count</span>     <span style=color:#66d9ef>int</span> <span style=color:#75715e>// # live cells == size of map.  Must be first (used by len() builtin)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>flags</span>     <span style=color:#66d9ef>uint8</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>B</span>         <span style=color:#66d9ef>uint8</span>  <span style=color:#75715e>// log_2 of # of buckets (can hold up to loadFactor * 2^B items)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>noverflow</span> <span style=color:#66d9ef>uint16</span> <span style=color:#75715e>// approximate number of overflow buckets; see incrnoverflow for details
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>hash0</span>     <span style=color:#66d9ef>uint32</span> <span style=color:#75715e>// hash seed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>buckets</span>    <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> <span style=color:#75715e>// array of 2^B Buckets. may be nil if count==0.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>oldbuckets</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> <span style=color:#75715e>// previous bucket array of half the size, non-nil only when growing
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>nevacuate</span>  <span style=color:#66d9ef>uintptr</span>        <span style=color:#75715e>// progress counter for evacuation (buckets less than this have been evacuated)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>extra</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>mapextra</span> <span style=color:#75715e>// optional fields
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// mapextra holds fields that are not present on all maps.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>mapextra</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// If both key and elem do not contain pointers and are inline, then we mark bucket
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// type as containing no pointers. This avoids scanning such maps.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// However, bmap.overflow is a pointer. In order to keep overflow buckets
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// alive, we store pointers to all overflow buckets in hmap.extra.overflow and hmap.extra.oldoverflow.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// overflow and oldoverflow are only used if key and elem do not contain pointers.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// overflow contains overflow buckets for hmap.buckets.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// oldoverflow contains overflow buckets for hmap.oldbuckets.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// The indirection allows to store a pointer to the slice in hiter.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>overflow</span>    <span style=color:#f92672>*</span>[]<span style=color:#f92672>*</span><span style=color:#a6e22e>bmap</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>oldoverflow</span> <span style=color:#f92672>*</span>[]<span style=color:#f92672>*</span><span style=color:#a6e22e>bmap</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// nextOverflow holds a pointer to a free overflow bucket.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>nextOverflow</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>bmap</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// A bucket for a Go map.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>bmap</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// tophash generally contains the top byte of the hash value
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// for each key in this bucket. If tophash[0] &lt; minTopHash,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// tophash[0] is a bucket evacuation state instead.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>tophash</span> [<span style=color:#a6e22e>bucketCnt</span>]<span style=color:#66d9ef>uint8</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Followed by bucketCnt keys and then bucketCnt elems.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// NOTE: packing all the keys together and then all the elems together makes the
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// code a bit more complicated than alternating key/elem/key/elem/... but it allows
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// us to eliminate padding which would be needed for, e.g., map[int64]int8.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// Followed by an overflow pointer.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h4 id=map-set-以及扩容>map set 以及扩容</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Like mapaccess, but allocates a slot for the key if it is not present in the map.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>mapassign</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>maptype</span>, <span style=color:#a6e22e>h</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hmap</span>, <span style=color:#a6e22e>key</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>) <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> {  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {  
</span></span><span style=display:flex><span>      panic(<span style=color:#a6e22e>plainError</span>(<span style=color:#e6db74>&#34;assignment to entry in nil map&#34;</span>))  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>raceenabled</span> {  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>callerpc</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getcallerpc</span>()  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>pc</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>abi</span>.<span style=color:#a6e22e>FuncPCABIInternal</span>(<span style=color:#a6e22e>mapassign</span>)  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>racewritepc</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>h</span>), <span style=color:#a6e22e>callerpc</span>, <span style=color:#a6e22e>pc</span>)  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>raceReadObjectPC</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>callerpc</span>, <span style=color:#a6e22e>pc</span>)  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>msanenabled</span> {  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>msanread</span>(<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>key</span>.<span style=color:#a6e22e>size</span>)  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>asanenabled</span> {  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>asanread</span>(<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>key</span>.<span style=color:#a6e22e>size</span>)  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>flags</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>hashWriting</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>fatal</span>(<span style=color:#e6db74>&#34;concurrent map writes&#34;</span>)  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>hash</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>hasher</span>(<span style=color:#a6e22e>key</span>, uintptr(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>hash0</span>))  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// Set hashWriting after calling t.hasher, since t.hasher may panic,  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// in which case we have not actually done a write.   h.flags ^= hashWriting  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>buckets</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>buckets</span> = <span style=color:#a6e22e>newobject</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>bucket</span>) <span style=color:#75715e>// newarray(t.bucket, 1)  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>again</span>:  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>bucket</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>hash</span> <span style=color:#f92672>&amp;</span> <span style=color:#a6e22e>bucketMask</span>(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span>)  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>growing</span>() {  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>growWork</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>h</span>, <span style=color:#a6e22e>bucket</span>)  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>bmap</span>)(<span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>buckets</span>, <span style=color:#a6e22e>bucket</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>bucketsize</span>)))  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>top</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>tophash</span>(<span style=color:#a6e22e>hash</span>)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>inserti</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>uint8</span>  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>insertk</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>elem</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>bucketloop</span>:  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>for</span> {  
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> uintptr(<span style=color:#ae81ff>0</span>); <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>bucketCnt</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {  
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>tophash</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>!=</span> <span style=color:#a6e22e>top</span> {  
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>isEmpty</span>(<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>tophash</span>[<span style=color:#a6e22e>i</span>]) <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>inserti</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {  
</span></span><span style=display:flex><span>               <span style=color:#a6e22e>inserti</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>tophash</span>[<span style=color:#a6e22e>i</span>]  
</span></span><span style=display:flex><span>               <span style=color:#a6e22e>insertk</span> = <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>b</span>), <span style=color:#a6e22e>dataOffset</span><span style=color:#f92672>+</span><span style=color:#a6e22e>i</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>keysize</span>))  
</span></span><span style=display:flex><span>               <span style=color:#a6e22e>elem</span> = <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>b</span>), <span style=color:#a6e22e>dataOffset</span><span style=color:#f92672>+</span><span style=color:#a6e22e>bucketCnt</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>keysize</span>)<span style=color:#f92672>+</span><span style=color:#a6e22e>i</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>elemsize</span>))  
</span></span><span style=display:flex><span>            }  
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>tophash</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>==</span> <span style=color:#a6e22e>emptyRest</span> {  
</span></span><span style=display:flex><span>               <span style=color:#66d9ef>break</span> <span style=color:#a6e22e>bucketloop</span>  
</span></span><span style=display:flex><span>            }  
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>  
</span></span><span style=display:flex><span>         }  
</span></span><span style=display:flex><span>         <span style=color:#a6e22e>k</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>b</span>), <span style=color:#a6e22e>dataOffset</span><span style=color:#f92672>+</span><span style=color:#a6e22e>i</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>keysize</span>))  
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>indirectkey</span>() {  
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>k</span> = <span style=color:#f92672>*</span>((<span style=color:#f92672>*</span><span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>)(<span style=color:#a6e22e>k</span>))  
</span></span><span style=display:flex><span>         }  
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>key</span>.<span style=color:#a6e22e>equal</span>(<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>k</span>) {  
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>  
</span></span><span style=display:flex><span>         }  
</span></span><span style=display:flex><span>         <span style=color:#75715e>// already have a mapping for key. Update it.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>         <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>needkeyupdate</span>() {  
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>typedmemmove</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>k</span>, <span style=color:#a6e22e>key</span>)  
</span></span><span style=display:flex><span>         }  
</span></span><span style=display:flex><span>         <span style=color:#a6e22e>elem</span> = <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>b</span>), <span style=color:#a6e22e>dataOffset</span><span style=color:#f92672>+</span><span style=color:#a6e22e>bucketCnt</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>keysize</span>)<span style=color:#f92672>+</span><span style=color:#a6e22e>i</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>elemsize</span>))  
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>goto</span> <span style=color:#a6e22e>done</span>  
</span></span><span style=display:flex><span>      }  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>ovf</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>overflow</span>(<span style=color:#a6e22e>t</span>)  
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ovf</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {  
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>break</span>  
</span></span><span style=display:flex><span>      }  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>b</span> = <span style=color:#a6e22e>ovf</span>  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// Did not find mapping for key. Allocate new cell &amp; add entry.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// If we hit the max load factor or we have too many overflow buckets,   // and we&#39;re not already in the middle of growing, start growing.   if !h.growing() &amp;&amp; (overLoadFactor(h.count+1, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) {  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#a6e22e>hashGrow</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>h</span>)  
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>goto</span> <span style=color:#a6e22e>again</span> <span style=color:#75715e>// Growing the table invalidates everything, so try again  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>inserti</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {  
</span></span><span style=display:flex><span>      <span style=color:#75715e>// The current bucket and all the overflow buckets connected to it are full, allocate a new one.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#a6e22e>newb</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>newoverflow</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>b</span>)  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>inserti</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>newb</span>.<span style=color:#a6e22e>tophash</span>[<span style=color:#ae81ff>0</span>]  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>insertk</span> = <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>newb</span>), <span style=color:#a6e22e>dataOffset</span>)  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>elem</span> = <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>insertk</span>, <span style=color:#a6e22e>bucketCnt</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>keysize</span>))  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>// store new key/elem at insert position  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>indirectkey</span>() {  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>kmem</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>newobject</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>key</span>)  
</span></span><span style=display:flex><span>      <span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>)(<span style=color:#a6e22e>insertk</span>) = <span style=color:#a6e22e>kmem</span>  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>insertk</span> = <span style=color:#a6e22e>kmem</span>  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>indirectelem</span>() {  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>vmem</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>newobject</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>elem</span>)  
</span></span><span style=display:flex><span>      <span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>)(<span style=color:#a6e22e>elem</span>) = <span style=color:#a6e22e>vmem</span>  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>typedmemmove</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>insertk</span>, <span style=color:#a6e22e>key</span>)  
</span></span><span style=display:flex><span>   <span style=color:#f92672>*</span><span style=color:#a6e22e>inserti</span> = <span style=color:#a6e22e>top</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>count</span><span style=color:#f92672>++</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>done</span>:  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>flags</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>hashWriting</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>fatal</span>(<span style=color:#e6db74>&#34;concurrent map writes&#34;</span>)  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>flags</span> <span style=color:#f92672>&amp;^=</span> <span style=color:#a6e22e>hashWriting</span>  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>indirectelem</span>() {  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>elem</span> = <span style=color:#f92672>*</span>((<span style=color:#f92672>*</span><span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>)(<span style=color:#a6e22e>elem</span>))  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>elem</span>  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=range><code>range</code></h2><h2 id=泛型>#泛型</h2><h3 id=泛型示例>泛型示例</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Sum 使用泛型
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Sum</span>[<span style=color:#a6e22e>T</span> <span style=color:#66d9ef>int64</span> | <span style=color:#66d9ef>float64</span>](<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span> <span style=color:#a6e22e>T</span>) <span style=color:#a6e22e>T</span> {  
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>a</span><span style=color:#f92672>+</span><span style=color:#a6e22e>b</span>  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=自定义泛型类型>自定义泛型类型</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// CustomInt 泛型与接口声明类似  type CustomInt interface {  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#66d9ef>int</span> | <span style=color:#66d9ef>int8</span> | <span style=color:#66d9ef>int16</span> | <span style=color:#66d9ef>int32</span> | <span style=color:#66d9ef>int64</span>  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// Sum T的类型为声明的CustomInt  func Sum[T CustomInt](a, b T) T {  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>a</span><span style=color:#f92672>+</span><span style=color:#a6e22e>b</span>  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>成员类型支持 <code>go</code> 中所有基本类型</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>CustomT</span> <span style=color:#66d9ef>interface</span> {  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>int</span> | <span style=color:#66d9ef>float32</span> | <span style=color:#66d9ef>bool</span> | <span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span> | <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>int</span>]<span style=color:#66d9ef>int</span> | [<span style=color:#ae81ff>10</span>]<span style=color:#66d9ef>int</span> | []<span style=color:#66d9ef>int</span> | <span style=color:#66d9ef>struct</span>{} | <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Client</span>  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>泛型中的 <code>~</code> 符号都是与类型一起出现的，用来表示支持该类型的衍生类型</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// int8的衍生类型  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>int8A</span> <span style=color:#66d9ef>int8</span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>int8B</span> = <span style=color:#66d9ef>int8</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// CustomInt 不仅支持int8, 还支持int8的衍生类型int8A和int8B  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>CustomInt</span> <span style=color:#66d9ef>interface</span> {  
</span></span><span style=display:flex><span>   <span style=color:#960050;background-color:#1e0010>~</span><span style=color:#66d9ef>int8</span>  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=使用带泛型的函数>使用带泛型的函数</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>a</span> <span style=color:#66d9ef>int</span> = <span style=color:#ae81ff>10</span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>int</span> = <span style=color:#ae81ff>20</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 方法1，正常调用，编译器会自动推断出传入类型是int
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>Sum</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 方法2，显式告诉函数传入的类型是int
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>Sum</span>[<span style=color:#66d9ef>int</span>](<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>)
</span></span></code></pre></div><h3 id=内置的泛型类型-any-和-comparable>内置的泛型类型 <code>any</code> 和 <code>comparable</code></h3><blockquote><p><code>any</code>: 表示 <code>go</code> 里面所有的内置基本类型，等价于 <code>interface{}</code></p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// any is an alias for interface{} and is equivalent to interface{} in all ways.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>any</span> = <span style=color:#66d9ef>interface</span>{}
</span></span></code></pre></div><blockquote><p><code>comparable</code>: 表示 <code>go</code> 里面所有内置的可比较类型：<code>int</code>、<code>uint</code>、<code>float</code>、<code>bool</code>、<code>struct</code>、指针等一切可以比较的类型</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// comparable is an interface that is implemented by all comparable types  
</span></span></span><span style=display:flex><span><span style=color:#75715e>// (booleans, numbers, strings, pointers, channels, arrays of comparable types,  
</span></span></span><span style=display:flex><span><span style=color:#75715e>// structs whose fields are all comparable types).  
</span></span></span><span style=display:flex><span><span style=color:#75715e>// The comparable interface may only be used as a type parameter constraint,  
</span></span></span><span style=display:flex><span><span style=color:#75715e>// not as the type of a variable.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>comparable</span> <span style=color:#66d9ef>interface</span>{ <span style=color:#a6e22e>comparable</span> }
</span></span></code></pre></div><h3 id=泛型与结构体>泛型与结构体</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>AgeT</span> <span style=color:#66d9ef>interface</span> {  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>int8</span> | <span style=color:#66d9ef>int16</span>  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>NameE</span> <span style=color:#66d9ef>interface</span> {  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>string</span>  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>User</span>[<span style=color:#a6e22e>T</span> <span style=color:#a6e22e>AgeT</span>, <span style=color:#a6e22e>E</span> <span style=color:#a6e22e>NameE</span>] <span style=color:#66d9ef>struct</span> {  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>age</span>  <span style=color:#a6e22e>T</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>name</span> <span style=color:#a6e22e>E</span>  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// GetAge 获取年龄  func (u *User[T, E]) GetAge() T {  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>u</span>.<span style=color:#a6e22e>age</span>  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// GetName 获取名字  func (u *User[T, E]) GetName() E {  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>u</span>.<span style=color:#a6e22e>name</span>  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 声明要使用的泛型的类型  var u User[int8, string]  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 赋值  u.age = 10  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>u</span>.<span style=color:#a6e22e>name</span> = <span style=color:#e6db74>&#34;ormissia&#34;</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 调用方法  age := u.GetAge()  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>name</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>u</span>.<span style=color:#a6e22e>GetName</span>()  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>age</span>, <span style=color:#a6e22e>name</span>)
</span></span><span style=display:flex><span><span style=color:#75715e>// 10 ormissia
</span></span></span></code></pre></div><h3 id=泛型与-switch>泛型与 <code>switch</code></h3><blockquote><p>泛型和 <code>switch</code> 配合使用时无法通过编译，只能先将泛型赋值给 <code>interface</code> 才可以和 <code>switch</code> 配合使用</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// GetX 编译不通过  func GetX[T any]() T {  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>t</span> <span style=color:#a6e22e>T</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>T</span> {  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>case</span> <span style=color:#66d9ef>int</span>:  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>t</span> = <span style=color:#ae81ff>18</span>  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>t</span>  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// Get 编译通过  func Get[T any]() T {  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>t</span> <span style=color:#a6e22e>T</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ti</span> <span style=color:#66d9ef>interface</span>{} = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>t</span>  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ti</span>.(<span style=color:#66d9ef>type</span>) {  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>case</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>int</span>:  
</span></span><span style=display:flex><span>      <span style=color:#f92672>*</span><span style=color:#a6e22e>v</span> = <span style=color:#ae81ff>18</span>  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>t</span>  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=泛型的实际使用>泛型的实际使用</h3><ul><li><a href=https://github.com/ormissia/cache_shim/blob/b295ded156d37f6a20d8811e740736a8c228cdbf/cache_strategy.go#L24 target=_blank rel=noopener>缓存适配器中泛型的使用</a> [[计算机/项目/Go缓存垫片]]</li></ul><h2 id=panic-与-recovery>panic 与 recovery</h2><ul><li>调用 <code>panic</code> 后会立刻停止执行当前函数的剩余代码，并在当前 Goroutine 中递归执行调用方的 <code>defer</code></li><li><code>recover</code> 可以中止 <code>panic</code> 造成的程序崩溃。它是一个只能在 <code>defer</code> 中发挥作用的函数，在其他作用域中调用不会发挥作用</li></ul><h2 id=channel>channel</h2><h2 id=switchcase>switch/case</h2><ul><li>单个 <code>case</code> 语句中，可以出现多个结果选项</li><li>只有在 <code>case</code> 中明确添加 <code>fallthrough</code> 关键字，才会明确执行紧跟的下一个<code>case</code></li></ul><h1 id=lua-语法>Lua 语法</h1><p>#lua #编程语言</p><h2 id=注释>注释</h2><ul><li>单行注释</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=color:#75715e>-- 单行注释</span>
</span></span></code></pre></div><ul><li>多行注释</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=color:#75715e>--[[  
</span></span></span><span style=display:flex><span><span style=color:#75715e>多行注释  
</span></span></span><span style=display:flex><span><span style=color:#75715e>多行注释  
</span></span></span><span style=display:flex><span><span style=color:#75715e>]]</span>
</span></span></code></pre></div><h2 id=数据类型>数据类型</h2><blockquote><p>Lua 是动态类型语言，变量不要类型定义，只需要为变量赋值</p></blockquote><p>Lua 中有 8 个基本类型分别为：<code>nil</code>、<code>boolean</code>、<code>number</code>、<code>string</code>、<code>userdata</code>、<code>function</code>、<code>thread</code> 和 <code>table</code>。</p><table><thead><tr><th>数据类型</th><th>描述</th></tr></thead><tbody><tr><td>nil</td><td>值nil属于该类，表示一个无效值（在条件表达式中相当于false）</td></tr><tr><td>boolean</td><td>包含两个值：false 和 true</td></tr><tr><td>number</td><td>表示双精度类型的实浮点数</td></tr><tr><td>string</td><td>字符串由一对双引号或单引号来表示</td></tr><tr><td>function</td><td>由 C 或 Lua 编写的函数</td></tr><tr><td>userdata</td><td>表示任意存储在变量中的C数据结构</td></tr><tr><td>thread</td><td>表示执行的独立线路，用于执行协同程序</td></tr><tr><td>table</td><td>Lua 中的表（table）其实是一个"关联数组"（associative arrays），数组的索引可以是数字、字符串或表类型。在 Lua 里，table 的创建是通过"构造表达式"来完成，最简单构造表达式是{}，用来创建一个空表。</td></tr></tbody></table><p>可以使用 type 函数测试给定变量或者值的类型：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span>print(type(<span style=color:#e6db74>&#34;Hello world&#34;</span>))  
</span></span><span style=display:flex><span>print(type(<span style=color:#ae81ff>10.4</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>3</span>))  
</span></span><span style=display:flex><span>print(type(print))  
</span></span><span style=display:flex><span>print(type(type))  
</span></span><span style=display:flex><span>print(type(<span style=color:#66d9ef>true</span>))  
</span></span><span style=display:flex><span>print(type(<span style=color:#66d9ef>nil</span>))  
</span></span><span style=display:flex><span>print(type(type(X)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>--[[
</span></span></span><span style=display:flex><span><span style=color:#75715e>输出
</span></span></span><span style=display:flex><span><span style=color:#75715e>string  
</span></span></span><span style=display:flex><span><span style=color:#75715e>number  
</span></span></span><span style=display:flex><span><span style=color:#75715e>function  
</span></span></span><span style=display:flex><span><span style=color:#75715e>function  
</span></span></span><span style=display:flex><span><span style=color:#75715e>boolean  
</span></span></span><span style=display:flex><span><span style=color:#75715e>nil  
</span></span></span><span style=display:flex><span><span style=color:#75715e>string  
</span></span></span><span style=display:flex><span><span style=color:#75715e>]]</span>
</span></span></code></pre></div><h2 id=变量>变量</h2><blockquote><p>在默认情况下，变量总是认为是全局的，哪怕是语句块或是函数里，除非用 local 显式声明为局部变量</p></blockquote><p>Lua 变量有三种类型：全局变量、局部变量、表中的域
变量的默认值均为 nil</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span>a <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>               <span style=color:#75715e>-- 全局变量  </span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>local</span> b <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>         <span style=color:#75715e>-- 局部变量</span>
</span></span></code></pre></div><h2 id=循环>循环</h2><h3 id=while>while</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span>a<span style=color:#f92672>=</span><span style=color:#ae81ff>10</span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span>( a <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>20</span> )  
</span></span><span style=display:flex><span><span style=color:#66d9ef>do</span>  
</span></span><span style=display:flex><span>   print(<span style=color:#e6db74>&#34;a 的值为:&#34;</span>, a)  
</span></span><span style=display:flex><span>   a <span style=color:#f92672>=</span> a<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><h3 id=for>for</h3><h4 id=数值-for-循环>数值 for 循环</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=color:#66d9ef>for</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>10</span>,<span style=color:#ae81ff>1</span>,<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> <span style=color:#66d9ef>do</span>  
</span></span><span style=display:flex><span>    print(i)  
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><blockquote><p>for 的三个表达式在循环开始前一次性求值，以后不再进行求值。比如上面的 f (x) 只会在循环开始前执行一次，其结果用在后面的循环中</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>f</span>(x)  
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;function&#34;</span>)  
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> x<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>,f(<span style=color:#ae81ff>5</span>) <span style=color:#66d9ef>do</span> print(i)  
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><h4 id=泛型-for-循环>泛型 for 循环</h4><blockquote><p>i 是数组索引值，v 是对应索引的数组元素值。ipairs 是 Lua 提供的一个迭代器函数，用来迭代数组，相当于 Go 里面的 range</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=color:#75715e>--打印数组a的所有值  </span>
</span></span><span style=display:flex><span>a <span style=color:#f92672>=</span> {<span style=color:#e6db74>&#34;one&#34;</span>, <span style=color:#e6db74>&#34;two&#34;</span>, <span style=color:#e6db74>&#34;three&#34;</span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i, v <span style=color:#66d9ef>in</span> ipairs(a) <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>    print(i, v)
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><h3 id=repeat-until>repeat&mldr; until</h3><blockquote><p>相当于某些语言里的 <code>do...while</code></p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=color:#75715e>--[ 变量定义 --]  </span>
</span></span><span style=display:flex><span>a <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>  
</span></span><span style=display:flex><span><span style=color:#75715e>--[ 执行循环 --]  </span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>repeat</span>  
</span></span><span style=display:flex><span>   print(<span style=color:#e6db74>&#34;a的值为:&#34;</span>, a)  
</span></span><span style=display:flex><span>   a <span style=color:#f92672>=</span> a <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>until</span>( a <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>15</span> )
</span></span></code></pre></div><h3 id=嵌套循环>嵌套循环</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span>j <span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>10</span> <span style=color:#66d9ef>do</span>  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>for</span> j<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>,(i<span style=color:#f92672>/</span>j) , <span style=color:#ae81ff>2</span> <span style=color:#66d9ef>do</span>  
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span>(<span style=color:#f92672>not</span>(i<span style=color:#f92672>%</span>j))  
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>then</span>  
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>break</span>  
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>end</span>  
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span>(j <span style=color:#f92672>&gt;</span> (i<span style=color:#f92672>/</span>j))<span style=color:#66d9ef>then</span>  
</span></span><span style=display:flex><span>         print(<span style=color:#e6db74>&#34;i 的值为：&#34;</span>,i)  
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>end</span>  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>end</span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><h3 id=循环控制语句>循环控制语句</h3><ul><li><p>break：退出当前循环或语句，并开始脚本执行紧接着的语句</p></li><li><p>goto</p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=color:#66d9ef>local</span> a <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>  
</span></span><span style=display:flex><span>::label:: print(<span style=color:#e6db74>&#34;--- goto label ---&#34;</span>)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>a <span style=color:#f92672>=</span> a<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> a <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>3</span> <span style=color:#66d9ef>then</span>  
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>goto</span> label   <span style=color:#75715e>-- a 小于 3 的时候跳转到标签 label  </span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><h3 id=无限循环>无限循环</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=color:#66d9ef>while</span>( <span style=color:#66d9ef>true</span> )  
</span></span><span style=display:flex><span><span style=color:#66d9ef>do</span>  
</span></span><span style=display:flex><span>   print(<span style=color:#e6db74>&#34;循环将永远执行下去&#34;</span>)  
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><h2 id=流程控制>流程控制</h2><h3 id=if>if</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=color:#75715e>--[ 定义变量 --]</span>
</span></span><span style=display:flex><span>a <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>--[ 使用 if 语句 --]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span>( a <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>20</span> )
</span></span><span style=display:flex><span><span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>   <span style=color:#75715e>--[ if 条件为 true 时打印以下信息 --]</span>
</span></span><span style=display:flex><span>   print(<span style=color:#e6db74>&#34;a 小于 20&#34;</span> );
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>&#34;a 的值为:&#34;</span>, a);
</span></span></code></pre></div><h3 id=if-else>if&mldr; else</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=color:#75715e>--[ 定义变量 --]  </span>
</span></span><span style=display:flex><span>a <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>;  
</span></span><span style=display:flex><span><span style=color:#75715e>--[ 检查条件 --]  </span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span>( a <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>20</span> )  
</span></span><span style=display:flex><span><span style=color:#66d9ef>then</span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>--[ if 条件为 true 时执行该语句块 --]  </span>
</span></span><span style=display:flex><span>   print(<span style=color:#e6db74>&#34;a 小于 20&#34;</span> )  
</span></span><span style=display:flex><span><span style=color:#66d9ef>else</span>  
</span></span><span style=display:flex><span>   <span style=color:#75715e>--[ if 条件为 false 时执行该语句块 --]  </span>
</span></span><span style=display:flex><span>   print(<span style=color:#e6db74>&#34;a 大于 20&#34;</span> )  
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>  
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>&#34;a 的值为 :&#34;</span>, a)
</span></span></code></pre></div><h2 id=函数>函数</h2><p>函数定义格式：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span>optional_function_scope <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>function_name</span>( argument1, argument2, argument3..., argumentn)
</span></span><span style=display:flex><span>    function_body
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> result_params_comma_separated
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><ul><li><code>optional_function_scope</code>：该参数是可选的指定函数是全局函数还是局部函数，未设置该参数默认为全局函数，如果你需要设置函数为局部函数需要使用关键字 <code>local</code></li><li><code>function_name</code>：指定函数名称</li><li><code>argument1, argument2, argument3..., argumentn</code>：函数参数，多个参数以逗号隔开，函数也可以不带参数</li><li><code>function_body</code>：函数体，函数中需要执行的代码语句块</li><li><code>result_params_comma_separated</code>：函数返回值，Lua 语言函数可以返回多个值，每个值以逗号隔开</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=color:#75715e>--[[ 函数返回两个值的最大值 --]]</span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>max</span>(num1, num2)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> (num1 <span style=color:#f92672>&gt;</span> num2) <span style=color:#66d9ef>then</span>  
</span></span><span style=display:flex><span>      result <span style=color:#f92672>=</span> num1;  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>else</span>  
</span></span><span style=display:flex><span>      result <span style=color:#f92672>=</span> num2;  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>end</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>return</span> result;  
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>  
</span></span><span style=display:flex><span><span style=color:#75715e>-- 调用函数  </span>
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>&#34;两值比较最大值为 &#34;</span>,max(<span style=color:#ae81ff>10</span>,<span style=color:#ae81ff>4</span>))  
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>&#34;两值比较最大值为 &#34;</span>,max(<span style=color:#ae81ff>5</span>,<span style=color:#ae81ff>6</span>))
</span></span></code></pre></div><h3 id=多返回值>多返回值</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>maximum</span> (a)  
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>local</span> mi <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>             <span style=color:#75715e>-- 最大值索引  </span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>local</span> m <span style=color:#f92672>=</span> a[mi]          <span style=color:#75715e>-- 最大值  </span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i,val <span style=color:#66d9ef>in</span> ipairs(a) <span style=color:#66d9ef>do</span>  
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>if</span> val <span style=color:#f92672>&gt;</span> m <span style=color:#66d9ef>then</span>  
</span></span><span style=display:flex><span>           mi <span style=color:#f92672>=</span> i  
</span></span><span style=display:flex><span>           m <span style=color:#f92672>=</span> val  
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>end</span>  
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>  
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> m, mi  
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>print(maximum({<span style=color:#ae81ff>8</span>,<span style=color:#ae81ff>10</span>,<span style=color:#ae81ff>23</span>,<span style=color:#ae81ff>12</span>,<span style=color:#ae81ff>5</span>}))
</span></span></code></pre></div><h3 id=可变参数>可变参数</h3><p>Lua 函数可以接受可变数目的参数，在函数参数列表中使用三点 &mldr; 表示函数有可变的参数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>average</span>(...)  
</span></span><span style=display:flex><span>   result <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>local</span> arg<span style=color:#f92672>=</span>{...}    <span style=color:#75715e>--&gt; arg 为一个表，局部变量  </span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>for</span> i,v <span style=color:#66d9ef>in</span> ipairs(arg) <span style=color:#66d9ef>do</span>  
</span></span><span style=display:flex><span>      result <span style=color:#f92672>=</span> result <span style=color:#f92672>+</span> v  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>end</span>  
</span></span><span style=display:flex><span>   print(<span style=color:#e6db74>&#34;总共传入 &#34;</span> <span style=color:#f92672>..</span> <span style=color:#f92672>#</span>arg <span style=color:#f92672>..</span> <span style=color:#e6db74>&#34; 个数&#34;</span>)  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>return</span> result<span style=color:#f92672>/#</span>arg  
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>&#34;平均值为&#34;</span>,average(<span style=color:#ae81ff>10</span>,<span style=color:#ae81ff>5</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>5</span>,<span style=color:#ae81ff>6</span>))
</span></span></code></pre></div><h2 id=运算符>运算符</h2><h3 id=算术运算符>算术运算符</h3><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>+</td><td>加</td></tr><tr><td>-</td><td>减</td></tr><tr><td>*</td><td>乘</td></tr><tr><td>/</td><td>除</td></tr><tr><td>%</td><td>取余</td></tr><tr><td>^</td><td>乘幂</td></tr><tr><td>-</td><td>负号</td></tr><tr><td>//</td><td>整除运算符(>=lua5.3)</td></tr></tbody></table><h3 id=关系运算符>关系运算符</h3><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>==</td><td>等于</td></tr><tr><td><strong>~=</strong></td><td><strong>不等于</strong></td></tr><tr><td>></td><td>大于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>>=</td><td>大于等于</td></tr><tr><td>&lt;=</td><td>小于等于</td></tr></tbody></table><h3 id=逻辑运算符>逻辑运算符</h3><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>and</td><td>逻辑与</td></tr><tr><td>or</td><td>逻辑或</td></tr><tr><td>not</td><td>逻辑非</td></tr></tbody></table><blockquote><p>这里可以实现三目运算符的操作：<code>print(a > 10 and "yes" or "no")</code></p></blockquote><h3 id=其他运算符>其他运算符</h3><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>..</td><td>连接两个字符串</td></tr><tr><td>#</td><td>返回字符串或表的长度（#&ldquo;Hello&rdquo; 返回 5）</td></tr></tbody></table><h3 id=运算符优先级>运算符优先级</h3><p>由高到低的顺序：</p><pre tabindex=0><code>^
not    - (unary)
*      /       %
+      -
..
&lt;      &gt;      &lt;=     &gt;=     ~=     ==
and
or
</code></pre><h2 id=字符串>字符串</h2><p>Lua 语言中字符串可以使用以下三种方式来表示：</p><ul><li>单引号间的一串字符</li><li>双引号间的一串字符</li><li><code>[[</code> 与 <code>]]</code> 间的一串字符</li></ul><h2 id=数组>数组</h2><p><strong>在 lua 中数组下标是从 1 开始的，有别于其他语言中从 0 开始</strong></p><h3 id=一维数组>一维数组</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span>array <span style=color:#f92672>=</span> {<span style=color:#e6db74>&#34;Lua&#34;</span>, <span style=color:#e6db74>&#34;Tutorial&#34;</span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i<span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>2</span> <span style=color:#66d9ef>do</span>  
</span></span><span style=display:flex><span>   print(array[i])  
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><h3 id=多维数组>多维数组</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=color:#75715e>-- 初始化数组  </span>
</span></span><span style=display:flex><span>array <span style=color:#f92672>=</span> {}  
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>3</span> <span style=color:#66d9ef>do</span>  
</span></span><span style=display:flex><span>   array[i] <span style=color:#f92672>=</span> {}  
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>for</span> j<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>3</span> <span style=color:#66d9ef>do</span>  
</span></span><span style=display:flex><span>         array[i][j] <span style=color:#f92672>=</span> i<span style=color:#f92672>*</span>j  
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>end</span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>-- 访问数组  </span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>3</span> <span style=color:#66d9ef>do</span>  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>for</span> j<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>3</span> <span style=color:#66d9ef>do</span>  
</span></span><span style=display:flex><span>      print(array[i][j])  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>end</span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><h1 id=rust>RUST</h1><p>#rust #编程语言</p><h1 id=go-缓存垫片>Go 缓存垫片</h1><p>#go #缓存 #框架 #延时双删</p><blockquote><p>一个数据库与内存之间的缓存适配器，运用了控制反转的思想。引入之后无需重复为每种实体实现相同的缓存策略</p></blockquote><h2 id=项目背景>项目背景</h2><p>大多数情况下我们在代码中添加 #Redis 作为缓存中间件之后都会多出很多代码来。每给一个实体添加缓存，都需要加一大堆代码。久而久之，代码库变得非常冗杂而且难看。</p><p>举个栗子，一个带缓存的实体的查询逻辑的伪代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>e</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TestS</span>) <span style=color:#a6e22e>Select</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>e</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>SelectFromRedis</span>()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>ok</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>et</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>SelectFromDB</span>()
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>ok</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>e</span> = <span style=color:#a6e22e>et</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>SaveToCache</span>(<span style=color:#a6e22e>e</span>)
</span></span><span style=display:flex><span>		}()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>假如一个服务中有多个需要维护到缓存中的实体，再加上删除，修改等其他逻辑，就会出现非常多的相似代码，导致维护十分麻烦，而且复用性极低。即使写成工具类，当有新服务加入时，也需要将代码拷来拷去，显得十分不专业。</p><p>因此，写了这个缓存适配器框架，使用 #控制反转 的思想，代码中的实体只需实现指定接口，删除、修改、查询时只需要调用该库的对应方法即可，无需关心具体实现，框架会自动完成缓存相关逻辑。</p><h2 id=使用示例>使用示例</h2><ol><li>缓存客户端实现<code>CacheClintImpl</code>接口</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>CacheClintImpl</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Del</span>(<span style=color:#a6e22e>key</span> <span style=color:#66d9ef>string</span>) (<span style=color:#66d9ef>int64</span>, <span style=color:#66d9ef>error</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>SetString</span>(<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>value</span> <span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>error</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>GetString</span>(<span style=color:#a6e22e>k</span> <span style=color:#66d9ef>string</span>) (<span style=color:#66d9ef>string</span>, <span style=color:#66d9ef>error</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>实现参考<a href=https://github.com/ormissia/cache_shim/blob/master/example/redis_ex/redis_storage.go target=_blank rel=noopener>redis_storage.go</a></p><ol start=2><li>初始化缓存客户端并将缓存客户端示例初始化到框架中</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>redis_ex</span>.<span style=color:#a6e22e>Init</span>()
</span></span><span style=display:flex><span><span style=color:#a6e22e>cache_shim</span>.<span style=color:#a6e22e>InitCacheClient</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>redis_ex</span>.<span style=color:#a6e22e>RDB</span>)
</span></span></code></pre></div><ol start=3><li>需要做缓存的实体实现<code>CacheTypeImpl</code>接口</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// CacheType 需要缓存的实体接口定义  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>CacheType</span> <span style=color:#66d9ef>interface</span> {  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>CacheKey</span>() <span style=color:#66d9ef>string</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>Expiration</span>() <span style=color:#66d9ef>int</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>Delete</span>() <span style=color:#66d9ef>error</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>Select</span>() <span style=color:#66d9ef>error</span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>Update</span>() <span style=color:#66d9ef>error</span>  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=4><li>需要做缓存的实体实现 <code>CacheTypeImpl</code> 接口
因为控制反转，这个时候不需要直接调用实体的 <code>Select()</code> 方法，直接调用 <code>cache_shim</code> 包中的 <code>Select()</code> 函数即可，框架将自动维护缓存中的数据。</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>_</span> = <span style=color:#a6e22e>t1</span>.<span style=color:#a6e22e>Insert</span>()
</span></span><span style=display:flex><span><span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>cache_shim</span>.<span style=color:#a6e22e>Select</span>[<span style=color:#f92672>*</span><span style=color:#a6e22e>db_ex</span>.<span style=color:#a6e22e>UserEx</span>](<span style=color:#a6e22e>t1</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;t.type: %T\tt: %v\terr: %v&#34;</span>,<span style=color:#a6e22e>t</span>,<span style=color:#a6e22e>t</span>,<span style=color:#a6e22e>err</span>)
</span></span></code></pre></div><ol start=5><li>向数据库中插入数据之后，使用框架提供的查询方法查询
代码参考<a href=https://github.com/ormissia/cache_shim/blob/master/example/main.go target=_blank rel=noopener>main.go</a></li></ol><blockquote><p>修改、删除同理</p></blockquote><h2 id=链接>链接</h2><ul><li><a href=https://github.com/ormissia/cache_shim target=_blank rel=noopener>项目源码</a></li></ul><h1 id=色彩搭配样例>色彩搭配样例</h1><p>#设计 #色彩搭配 #高级感</p><h2 id=高级感撞色样例>高级感撞色样例</h2><blockquote><p>使用时颜色代码前加 <code>#</code></p></blockquote><p>BE98AA 珊瑚粉红 3E3F4C 蓝莓</p><p>E1DAD9 灰白 4D3A59 烈淡紫</p><h1 id=ddia>DDIA</h1><p>#系统设计</p><h1 id=一滴水到海洋>一滴水到海洋</h1><p>#读书笔记 #散文</p><ul><li>这个世界上所有的事情似乎都可以有很多完全不同的观点，然而，实践了什么才重要，观点反而是次要的 （P 4）</li><li>生命力任何事都没有特别的意义，在平凡中找到真实的人，就会发现每一段每一刻都有尊贵的意义。（P 30）</li><li>亦不观恶而生嫌，亦不观善而勤措，亦不舍智而近愚，亦不抛迷而求悟（P 43）</li><li>一个人如果心中有明月，就知道月亮虽有阴晴圆缺，其实月的本身是没有变化的（P 46）</li><li>我们今天在忧心台湾社会的时候，很少思考到社会是一个整体，许多事情不会单独或偶然发生，就像一个番薯的腐败，是整个番薯的事情（P 166）</li></ul></div><div class=paginator><ul class="pagination pagination-default"><li class=page-item><a href=/notes/ aria-label=First class=page-link role=button><span aria-hidden=true>&#171;&#171;</span></a></li><li class=page-item><a href=/notes/page/5/ aria-label=Previous class=page-link role=button><span aria-hidden=true>&#171;</span></a></li><li class=page-item><a href=/notes/page/4/ aria-label="Page 4" class=page-link role=button>4</a></li><li class=page-item><a href=/notes/page/5/ aria-label="Page 5" class=page-link role=button>5</a></li><li class="page-item active"><a aria-current=page aria-label="Page 6" class=page-link role=button>6</a></li><li class=page-item><a href=/notes/page/7/ aria-label="Page 7" class=page-link role=button>7</a></li><li class=page-item><a href=/notes/page/8/ aria-label="Page 8" class=page-link role=button>8</a></li><li class=page-item><a href=/notes/page/7/ aria-label=Next class=page-link role=button><span aria-hidden=true>&#187;</span></a></li><li class=page-item><a href=/notes/page/8/ aria-label=Last class=page-link role=button><span aria-hidden=true>&#187;&#187;</span></a></li></ul></div></div></section></div><footer id=footer class="container-fluid text-center align-content-center footer pb-2"><div class="container pt-5"><div class="row text-left"><div class="col-md-4 col-sm-12"><h5>联系方式:</h5><ul><li><span>QQ: </span><span>1432050813</span></li><li><a href=mailto:ormissia@outlook.com target=_blank rel=noopener><span><i class="fas fa-envelope"></i></span> <span>ormissia@outlook.com</span></a></li></ul></div></div></div><hr><div class=container><p id=disclaimer><strong>免责声明:</strong> 老铁看到底了，要负责的哦</p></div><hr><div class=container><div class="row text-left"><div class=col-md-4><a id=theme href=https://github.com/hugo-toha/toha target=_blank rel=noopener><img src=/images/theme-logo_hu8376fd15465fef26ffe66b6bcf0ca686_13669_32x0_resize_box_3.png alt="Toha Theme Logo">
Toha</a></div><div class="col-md-4 text-center">© 2021 Copyright.</div><div class="col-md-4 text-right"><a id=hugo href=https://gohugo.io/ target=_blank rel=noopener>Powered by
<img src=/images/hugo-logo.svg alt="Hugo Logo" height=18></a></div></div></div></footer><script src=/application.dd14ce5884a636a7014ae8dc2953b8089e2c54e6449da331e2726c712c81c910.js integrity="sha256-3RTOWISmNqcBSujcKVO4CJ4sVOZEnaMx4nJscSyByRA=" defer></script></body></html>