# Redis

#redis #中间件 #缓存 #db #内存缓存

## 基础数据类型

- string
- list
- hash
- set
- zset
- bitmap

## 高级特性

### #慢查询

### #pipeline

多个命令一次请求减少网络开销

### #事务

### #Lua

原子操作

### #Stream

## 底层原理

### 持久化

#### RDB

- save: 阻塞主线程
- bgsave: 不阻塞主线程

#### AOF

### 分布式锁

- `setnx`
- `set lock_name 1 ex 10 nx`

#### 普通流程

1. 加锁：`set lock_name uuid ex 10 nx`
2. 业务操作
3. 释放锁：`lua` 脚本，先 `get` 判断是否属于自己，再 `del` 释放锁

#### 红锁流程

1. 客户端获取当前时间戳T1
2. 客户端依次向这 5 台 `redis` 实例（非集群）发起加锁请求
3. 如果>=3个（大多数）成功，当前时间戳T2 - T1 < 锁的过期时间则加锁成功
4. 加锁成功，操作业务
5. 加锁失败/释放锁，向5台`redis`发起释放锁请求

## 集群

### 一主多从

#### 主从

#### 哨兵

![哨兵](计算机/img/redis_sentry.png)
### 多主多从

> 虚拟一致性哈希 -> 虚拟槽分区


## 常见问题及解决办法

### 缓存相关

- #缓存一致性 
	- 成因：由于网络延迟等因素导致缓存中数据与DB中数据不一致
	- 解决办法：#延时双删
- #缓存穿透 
	- 成因：DB中不存在的数据被频繁请求
	- 解决办法：1. 数据进行插入操作同时添加到 #布隆过滤器 ，2. 缓存空对象
- #缓存击穿 
	- 成因：同一个缓存中不存在的 `key` ，在一段时间（一般是极短时间）内第一个请求查询完 DB 后还未写入缓存，导致这段时间内后续请求又直接打到 DB
	- 解决办法：查询前加锁
- #缓存雪崩 
	- 成因：大量缓存数据同时过期导致请求直接打到DB
	- 解决办法：在一定范围内随机过期时间，比如一小时随机加减十以内分钟数


### key相关

- #热点key 
	- 解决办法：
		1. 使用 `redis` 命令：容易造成 `redis` 宕机
		2. #TCP抓包 ：
			- 无入侵性，成本高
			- `elk-packetbeat`
			- 容易造成机器网络波动，如丢包
			- 维护成本高
		3. 二级缓存
		4. 主从架构时，在从节点中扫描大 key
		5. 子 key #hash算法
- #大key 
	- 大概标准：
		- `string` 大于 `10kb`
		- 
- #数据倾斜

## 链接

- [[计算机/项目/Go缓存垫片]]