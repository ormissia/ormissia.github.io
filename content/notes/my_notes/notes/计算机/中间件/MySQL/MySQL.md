# MySQL

#mysql #数据库 #db #b加树 

## 基础

### #事务

> 只有 `InnoDB` 引擎才支持事务

> `MySQL` 默认的事务隔离级别是可重复读（`REPEATABLE READ`）

#### #ACID 特性

1. 原子性 (Atomicity)：
2. 一致性 (Consistency)：
3. 隔离性 (Isolation)：
4. 持久性 (Durability)：

#### 并发问题

1. **脏读**：当一个事务读取到另外一个事务修改但未提交的数据时，就可能发生脏读
2. **不可重复读**：“不可重复读”现象发生在当执行 SELECT 操作时没有获得读锁或者 SELECT 操作执行完后马上释放了读锁；另外一个事务对数据进行了更新， 读到了不同的结果
3. **幻读**：是''不可重复读''的一种特殊场景：当事务1两次执行''SELECT ... WHERE''检索一定范围内数据的操作中间，事务2在这个表中创建了 (如 INSERT 或 DELETE)了一行新数据，这条新数据正好满足事务1的“WHERE”子句。事务1执行了两遍同样的查询语句，第二遍比第一遍多出了一条数据，就是幻读

三者区别：
脏读：指读到了其他事务未提交的数据
不可重复读：读到了其他事务已提交的数据 (update)

不可重复读与幻读都是读到其他事务已提交的数据, 但是它们针对点不同
不可重复读：update
幻读：delete, insert

#### 乐观锁与悲观锁

- #悲观锁 ：在整个数据处理过程中，将数据处于锁定状态。读取数据时给加锁，其它事务无法修改这些数据。修改删除数据时也要加锁，其它事务无法读取这些数据
- #乐观锁 ：相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。乐观锁，大多是基于数据版本（ Version ）记录机制实现。在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据

#### #隔离级别

| 事务隔离级别 | 脏读 | 不可重复读 | 幻读 |
| ------------ |:----:|:----------:|:----:|
| 读未提交     |  ✅  |     ✅     |  ✅  |
| 读已提交     |  ❎  |     ✅     |  ✅  |
| 可重复读     |  ❎  |     ❎     |  ✅  |
| 串行化       |  ❎  |     ❎     |  ❎  |

1. **读未提交**：该隔离级别因为可以读取到其他事务中未提交的数据，而未提交的数据可能会发生回滚，因此我们把该级别读取到的数据称之为脏数据，把这个问题称之为脏读。
2. **读已提交**：该隔离级别的事务能读取到已经提交事务的数据，因此它不会有脏读问题。但由于在事务的执行中可以读取到其他事务提交的结果，所以在不同时间的相同 SQL 查询中，可能会得到不同的结果，这种现象叫做不可重复读。
3. **可重复读**：可重复读，是 *MySQL 的默认事务隔离级别*，它能确保同一事务多次查询的结果一致。但也会有新的问题，比如此级别的事务正在执行时，另一个事务成功的插入了某条数据，但因为它每次查询的结果都是一样的，所以会导致查询不到这条数据，自己重复插入时又失败（因为唯一约束的原因）。明明在事务中查询不到这条信息，但自己就是插入不进去，这就叫幻读 （Phantom Read）。
4. **序列化**：序列化，事务最高隔离级别，它会强制事务排序，使之不会发生冲突，从而解决了脏读、不可重复读和幻读问题，但执行效率低。

### #MVCC (多版本并发控制)

在 MySQL 中可重复读隔离级别就是通过 MVCC 来实现的乐观锁解决不可重复读问题。

## 调优

### 建表优化

- 字段长度越小越好
- 时间选择时间类型
- 时间戳
	- `datetime`
	- `timestamp`
	- `date`
- IP 选择整型
	- `select inet_aton('192.168.13.1');`
	- `select inet_ntoa(3232238849);`
- 尽量避免使用 `null`：会使索引等变复杂
- 主键选择
	- 代理主键（推荐）
	- 自然主键

### 字符集选择

**一定要选择 `utf8mb4`**

### 查询优化

```sql
show profile
```

```sql
performance_chema
```

### 数据库引擎

- `MyISAM`
- `InnoDB`

### 适当的数据冗余

### 拆分

- 垂直拆分
- 水平拆分

### 执行计划

### 索引优化

#### 索引分类

- 主键索引
- 唯一索引
- 普通索引
- 全文索引
- 组合索引

#### 名词

- 回表
- 覆盖索引：要查的字段在索引中存在，不需要回表的情况下为覆盖索引
- 最左匹配
- 索引下推：在最左匹配失效时使用索引下推

#### 哈希索引

### 聚簇索引和非聚簇索引

`InnoDB` 聚集索引的叶子节点存储行记录，因此， `InnoDB` 必须要有，且只有一个聚集索引：
1. 如果表定义了主键，则 `PK` 就是聚集索引  
2. 如果表没有定义主键，则第一个非空唯一索引（not NULL unique）列是聚集索引；  
3. 否则，`InnoDB` 会创建一个隐藏的 `row-id` 作为聚集索引；

  
  
作者：技术灭霸  
链接：https://www.jianshu.com/p/d0d3de6832b9  
来源：简书  
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

- 聚簇索引：不是单独的索引类型，而是一种数据存储方式，指的是数据行跟相邻的键值紧凑的存储在一起
- 非聚簇索引：数据文件跟索引文件分开存储

### 其它细节

1. 当使用索引列进行查询的时候尽量不要使用表达式，把计算放到业务层而不是数据库层
	select id from tab where id = 4
	select id from tab where id + 1 = 5
2. 尽量使用主键查询，而不是其他索引，因为主键查询不会触发回表
3. 使用前缀索引
	前缀索引：很长的字符串使用开始的部分字符串创建索引
4. 使用索引扫描来排序
5. 如果明确知道只有一条返回结果，limit 1 能提高效率
	加了查到数据就直接返回了
6. 单表索引不宜超过 5 个
7. 但索引字段数不宜超过 5 个

### 索引监控


