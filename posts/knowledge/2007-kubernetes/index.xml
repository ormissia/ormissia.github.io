<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Kubernetes on Ormissia's Blog</title><link>https://ormissia.github.io/posts/knowledge/2007-kubernetes/</link><description>Recent content in Kubernetes on Ormissia's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 04 Nov 2021 13:44:25 +0800</lastBuildDate><atom:link href="https://ormissia.github.io/posts/knowledge/2007-kubernetes/index.xml" rel="self" type="application/rss+xml"/><item><title>Kubernetes文档索引</title><link>https://ormissia.github.io/posts/knowledge/2007-kubernetes/001-link-index/</link><pubDate>Thu, 04 Nov 2021 13:44:25 +0800</pubDate><guid>https://ormissia.github.io/posts/knowledge/2007-kubernetes/001-link-index/</guid><description> #kubernetes #k8s
为系统守护进程预留计算资源 开启服务拓扑 Master节点的高可用 Service 的 DNS</description></item><item><title>k8s中通过Headless连接StatefulSet</title><link>https://ormissia.github.io/posts/knowledge/2007-kubernetes/002-handless-statefullset/</link><pubDate>Mon, 01 Nov 2021 16:59:32 +0800</pubDate><guid>https://ormissia.github.io/posts/knowledge/2007-kubernetes/002-handless-statefullset/</guid><description>#kubernetes #k8s
连接一些多实例的服务（比如Kafka、ES）时，通常是在client端做负载均衡。
假如这种集群又恰好跑在k8s中，如果是普通业务类型的服务，通常是创建一个Service来做为一个代理去访问不同实例，从而达到负载均衡的目的。
但是诸如如：Kafka、ES类型的服务，还用Service来做负载均衡，显然就不那么合理了（诚然，Kafka、ES这种东西多半是不会跑在k8s上的，这里只是作为一个引子，不在本文讨论的范畴）。
实验环境 多实例服务whoami在kube-test-1的命名空间下 多实例服务whoami以StatefulSet方式部署，设置为3个实例，会自动创建whoami-0、whoami-1以及whoami-2三个Pod 给StatefulSet创建Headless类型的Service 模拟客户端使用Nginx镜像，部署在kube-test-2的命名空间下（使用curl命令模拟） 本实验创建资源使用的k8s dashboard，创建的资源默认放在选中的明明空间下，因此yml文件中未指定namespace。
Server cluster 服务端模拟相关资源在kube-test-1下创建
StatefulSet 使用traefik/whoami镜像来模拟服务端
这里使用StatefulSet的方式创建服务端。spec.replicas设为3，此时会自动创建whoami-0、whoami-1以及whoami-2三个Pod。
apiVersion: apps/v1 kind: StatefulSet metadata: name: whoami labels: app: whoami spec: replicas: 3 selector: matchLabels: app: whoami serviceName: whoami template: metadata: name: whoami labels: app: whoami spec: containers: - name: whoami image: traefik/whoami ports: - containerPort: 80 注意这里的spec.serviceName必须与下面的Service名字相同，否则调用时候pod的subdomain只能使用IP
$ k get pod -n kube-test-1 -o wide | grep whoami whoami-0 1/1 Running 0 29m 10.</description></item></channel></rss>