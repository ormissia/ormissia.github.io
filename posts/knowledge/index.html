<!doctype html><html>
<head>
<title>知识积累</title>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta http-equiv=x-ua-compatible content="ie=edge">
<link rel=stylesheet href=/css/bootstrap.min.css>
<link rel=stylesheet href=/css/layouts/main.css>
<link rel=stylesheet href=/css/navigators/navbar.css>
<link rel=stylesheet href=/css/plyr.css>
<link rel=stylesheet href=/css/flag-icon.min.css>
<link href="https://fonts.googleapis.com/css2?family=Muli:wght@300;400;500;600" rel=stylesheet>
<link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css>
<link rel=icon type=image/png href=/images/favicon_hu8376fd15465fef26ffe66b6bcf0ca686_13669_42x0_resize_box_3.png>
<meta property="og:title" content="知识积累">
<meta property="og:description" content>
<meta property="og:type" content="website">
<meta property="og:url" content="https://ormissia.github.io/posts/knowledge/">
<link rel=stylesheet href=/css/layouts/list.css>
<link rel=stylesheet href=/css/navigators/sidebar.css>
<link rel=stylesheet href=/css/style.css>
</head>
<body data-spy=scroll data-target=#TableOfContents data-offset=80>
<div class="container-fluid bg-dimmed wrapper">
<nav class="navbar navbar-expand-xl top-navbar final-navbar shadow">
<div class=container>
<button class="navbar-toggler navbar-light" id=sidebar-toggler type=button onclick=toggleSidebar()>
<span class=navbar-toggler-icon></span>
</button>
<a class=navbar-brand href=/>
<img src=/images/ormissia_hu763a76473558eea2a316ef50b45aaecf_966068_42x0_resize_box_3.png alt=Logo>
Ormissia's Blog</a>
<button class="navbar-toggler navbar-light" id=toc-toggler type=button onclick=toggleTOC()>
<span class=navbar-toggler-icon></span>
</button>
<div class="collapse navbar-collapse lang-selector" id=top-nav-items>
<ul class="navbar-nav ml-auto">
</ul>
</div>
</div>
<img src=/images/ormissia_hu763a76473558eea2a316ef50b45aaecf_966068_42x0_resize_box_3.png class=d-none id=main-logo alt=Logo>
<img src=/images/ormissia_hu763a76473558eea2a316ef50b45aaecf_966068_42x0_resize_box_3.png class=d-none id=inverted-logo alt="Inverted Logo">
</nav>
<section class=sidebar-section id=sidebar-section>
<div class=sidebar-holder>
<div class=sidebar id=sidebar>
<form class=mx-auto method=get action=/search>
<input type=text name=keyword placeholder=Search data-search id=search-box>
</form>
<div class=sidebar-tree>
<ul class=tree id=tree>
<li id=list-heading><a href=/posts data-filter=all>博文</a></li>
<div class=subtree>
<li>
<i class="fas fa-minus-circle"></i><a class=active href=/posts/knowledge/>知识积累</a>
<ul class=active>
<li><a href=/posts/knowledge/2001-go-partten-1/ title=函数选项模式>函数选项模式</a></li>
<li><a href=/posts/knowledge/2002-go-param-verify/ title=实体参数校验>实体参数校验</a></li>
<li><a href=/posts/knowledge/2003-go-reflect/ title=Golang反射>Golang反射</a></li>
<li><a href=/posts/knowledge/2004-go-pprof/ title=pprof>pprof</a></li>
<li><a href=/posts/knowledge/2005-go-tag/ title="Golang struct tag">Golang struct tag</a></li>
<li><a href=/posts/knowledge/2006-hadoop-env/ title=Hadoop生态组件>Hadoop生态组件</a></li>
<li><a href=/posts/knowledge/2007-hadoop-hdfs/ title=HDFS基础知识>HDFS基础知识</a></li>
<li><a href=/posts/knowledge/2008-elasticstack-es/ title=Elasticsearch>Elasticsearch</a></li>
<li><a href=/posts/knowledge/2009-kubernetes-handless-statefullset/ title=k8s中通过Headless连接StatefulSet>k8s中通过Headless连接StatefulSet</a></li>
<li><a href=/posts/knowledge/2010-kubernetes-index/ title=Kubernetes文档索引>Kubernetes文档索引</a></li>
</ul>
</li>
<li>
<i class="fas fa-plus-circle"></i><a href=/posts/deployment/>环境部署</a>
<ul>
<li><a href=/posts/deployment/3001-blog-cicd/ title=我的博客后端Docker镜像打包自动部署流程>我的博客后端Docker镜像打包自动部署流程</a></li>
<li><a href=/posts/deployment/3002-linux-nginx/ title=Linux部署Nginx流程>Linux部署Nginx流程</a></li>
<li><a href=/posts/deployment/3003-linux-traefik/ title=Traefik部署流程>Traefik部署流程</a></li>
<li><a href=/posts/deployment/3004-linux-grafana/ title=Grafana部署流程>Grafana部署流程</a></li>
<li><a href=/posts/deployment/3005-linux-prometheus/ title=Prometheus部署流程>Prometheus部署流程</a></li>
<li><a href=/posts/deployment/3006-linux-elk/ title=ELK部署流程>ELK部署流程</a></li>
<li><a href=/posts/deployment/3007-linux-kubernetes/ title=Linux部署Kubernetes流程>Linux部署Kubernetes流程</a></li>
</ul>
</li>
<li>
<i class="fas fa-plus-circle"></i><a href=/posts/algorithm/>算法</a>
<ul>
<li><a href=/posts/algorithm/4001-algorithm-sort/ title=排序算法>排序算法</a></li>
<li><a href=/posts/algorithm/4002-algorithm-trie/ title=前缀树>前缀树</a></li>
</ul>
</li>
<li>
<i class="fas fa-plus-circle"></i><a href=/posts/problems/>疑难杂症</a>
<ul>
<li><a href=/posts/problems/5001-go-online-service-oom/ title=记一次线上的内存持续增长问题>记一次线上的内存持续增长问题</a></li>
<li><a href=/posts/problems/5002-k8s-memory/ title=Grafana上监控不准问题排查>Grafana上监控不准问题排查</a></li>
<li><a href=/posts/problems/5003-elasticsearch-start-failed/ title=CentOS安装完ES无法启动>CentOS安装完ES无法启动</a></li>
<li><a href=/posts/problems/5004-kubernetes-dashboard-token/ title="k8s dashboard token过期时间太短">k8s dashboard token过期时间太短</a></li>
<li><a href=/posts/problems/5005-docker-image-source/ title=修改Docker镜像源>修改Docker镜像源</a></li>
</ul>
</li>
<li>
<i class="fas fa-plus-circle"></i><a href=/posts/unclassified/>未分类</a>
<ul>
<li><a href=/posts/unclassified/6001-markdown/ title="Markdown Sample">Markdown Sample</a></li>
</ul>
</li>
</div>
</ul>
</div>
</div>
</div>
</section>
<section class=content-section id=content-section>
<div class="content container-fluid" id=content>
<div class="container-fluid post-card-holder" id=post-card-holder>
<div class=post-card>
<a href=/posts/knowledge/2010-kubernetes-index/ class=post-card-link>
<div class=card>
<div class=card-head>
<img class=card-img-top src=/posts/knowledge/2010-kubernetes-index/head.svg alt="Hero Image">
</div>
<div class=card-body>
<h5 class=card-title>Kubernetes文档索引</h5>
<p class="card-text post-summary"> 为系统守护进程预留计算资源 开启服务拓扑 Master节点的高可用 Service 的 DNS </p>
</div>
<div class=card-footer>
<span class=float-left>November 4, 2021</span>
<a href=/posts/knowledge/2010-kubernetes-index/ class="float-right btn btn-outline-info btn-sm">阅读</a>
</div>
</div>
</a>
</div>
<div class=post-card>
<a href=/posts/knowledge/2009-kubernetes-handless-statefullset/ class=post-card-link>
<div class=card>
<div class=card-head>
<img class=card-img-top src=/posts/knowledge/2009-kubernetes-handless-statefullset/head.svg alt="Hero Image">
</div>
<div class=card-body>
<h5 class=card-title>k8s中通过Headless连接StatefulSet</h5>
<p class="card-text post-summary">连接一些多实例的服务（比如Kafka、ES）时，通常是在client端做负载均衡。
假如这种集群又恰好跑在k8s中，如果是普通业务类型的服务，通常是创建一个Service来做为一个代理去访问不同实例，从而达到负载均衡的目的。
但是诸如如：Kafka、ES类型的服务，还用Service来做负载均衡，显然就不那么合理了（诚然，Kafka、ES这种东西多半是不会跑在k8s上的，这里只是作为一个引子，不在本文讨论的范畴）。
实验环境 多实例服务whoami在kube-test-1的命名空间下 多实例服务whoami以StatefulSet方式部署，设置为3个实例，会自动创建whoami-0、whoami-1以及whoami-2三个Pod 给StatefulSet创建Headless类型的Service 模拟客户端使用Nginx镜像，部署在kube-test-2的命名空间下（使用curl命令模拟） 本实验创建资源使用的k8s dashboard，创建的资源默认放在选中的明明空间下，因此yml文件中未指定namespace。
Server cluster 服务端模拟相关资源在kube-test-1下创建
StatefulSet 使用traefik/whoami镜像来模拟服务端
这里使用StatefulSet的方式创建服务端。spec.replicas设为3，此时会自动创建whoami-0、whoami-1以及whoami-2三个Pod。
apiVersion: apps/v1 kind: StatefulSet metadata: name: whoami labels: app: whoami spec: replicas: 3 selector: matchLabels: app: whoami serviceName: whoami template: metadata: name: whoami labels: app: whoami spec: containers: - name: whoami image: traefik/whoami ports: - containerPort: 80 注意这里的spec.serviceName必须与下面的Service名字相同，否则调用时候pod的subdomain只能使用IP
$ k get pod -n kube-test-1 -o wide | grep whoami whoami-0 1/1 Running 0 29m 10.</p>
</div>
<div class=card-footer>
<span class=float-left>November 1, 2021</span>
<a href=/posts/knowledge/2009-kubernetes-handless-statefullset/ class="float-right btn btn-outline-info btn-sm">阅读</a>
</div>
</div>
</a>
</div>
<div class=post-card>
<a href=/posts/knowledge/2008-elasticstack-es/ class=post-card-link>
<div class=card>
<div class=card-head>
<img class=card-img-top src=/posts/knowledge/2008-elasticstack-es/head.svg alt="Hero Image">
</div>
<div class=card-body>
<h5 class=card-title>Elasticsearch</h5>
<p class="card-text post-summary">搜索类型 搜索引擎：百度、搜狗、谷歌、必应 垂直领域：各大电商平台、OA系统、站内搜索 商业智能：数据分析、数据挖掘、用户画像 GitHub：千亿+行代码秒查 日志系统：ELK ES特点 搜索、聚合分析、大数据存储 分布式、高性能、高可用、可伸缩、易维护 支持文本搜索、结构化数据、非结构化数据、地理位置搜索等 ES单机部署 同一节点启动不同服务 ./bin/elasticsearch -E path.data=data1 -E path.logs=log1 -E node.name=node1 -E cluster.name=ormissia_test ./bin/elasticsearch -E path.data=data2 -E path.logs=log2 -E node.name=node2 -E cluster.name=ormissia_test http://localhost:9200/ http://localhost:9201/ 不同节点启动同一服务 open ./elasticsearch_node1/bin/elasticsearch open ./elasticsearch_node2/bin/elasticsearch open ./elasticsearch_node3/bin/elasticsearch open ./elasticsearch_node4/bin/elasticsearch open ./elasticsearch_node5/bin/elasticsearch open ./kibana-7.15.1-darwin-x86_64/bin/kibana elasticsearch-head插件 GitHub Repository
git clone git://github.com/mobz/elasticsearch-head.git cd elasticsearch-head npm install npm run start 默认端口：9100
如果集群无法连接，需要修改ES配置文件
http.cors.enabled: true http.cors.allow-origin: "*" elasticsearch-head也可以以Chrome插件的方式安装</p>
</div>
<div class=card-footer>
<span class=float-left>October 19, 2021</span>
<a href=/posts/knowledge/2008-elasticstack-es/ class="float-right btn btn-outline-info btn-sm">阅读</a>
</div>
</div>
</a>
</div>
<div class=post-card>
<a href=/posts/knowledge/2007-hadoop-hdfs/ class=post-card-link>
<div class=card>
<div class=card-head>
<img class=card-img-top src=/posts/knowledge/2007-hadoop-hdfs/head.svg alt="Hero Image">
</div>
<div class=card-body>
<h5 class=card-title>HDFS基础知识</h5>
<p class="card-text post-summary">HDFS架构 HDFS是一个主从（Master/Slaves）架构 由一个NameNode和一些DataNode组成 面向文件包含：文件元数据（metadata）和文件数据（data） NameNode负责存储和管理文件元数据，并维护了一个层次型的文件目录树 DataNode负责存储文件数据（block块），并提供block的读写 DataNode与NameNode维持心跳，并汇报自己持有的block信息 Client和NameNode交互文件元数据和DataNode交互文件block数据 目录树结构 角色即进程
Hadoop集群中HDFS节点角色 Master Standy </p>
</div>
<div class=card-footer>
<span class=float-left>September 24, 2021</span>
<a href=/posts/knowledge/2007-hadoop-hdfs/ class="float-right btn btn-outline-info btn-sm">阅读</a>
</div>
</div>
</a>
</div>
<div class=post-card>
<a href=/posts/knowledge/2006-hadoop-env/ class=post-card-link>
<div class=card>
<div class=card-head>
<img class=card-img-top src=/posts/knowledge/2006-hadoop-env/head.svg alt="Hero Image">
</div>
<div class=card-body>
<h5 class=card-title>Hadoop生态组件</h5>
<p class="card-text post-summary">最近在学习大数据相关的东西，看了HDFS，Hive，HBas，Spark相关的东西，总结一下Hadoop生态中常见的组件。
HDFS（hadoop分布式文件系统） HDFS是hadoop体系中数据存储管理的基础。他是一个高度容错的系统，能检测和应对硬件故障。
有以下几个角色：
client：切分文件，访问HDFS，与那么弄得交互，获取文件位置信息，与DataNode交互，读取和写入数据。
namenode：master节点，在hadoop1.x中只有一个，管理HDFS的名称空间和数据块映射信息，配置副本策略，处理客户 端请求。
DataNode：slave节点，存储实际的数据，汇报存储信息给namenode。
secondary namenode：辅助namenode，分担其工作量：定期合并fsimage和fsedits，推送给namenode；紧急情况下和辅助恢复namenode，但其并非namenode的热备。
mapreduce（分布式计算框架） mapreduce是一种计算模型，用于处理大数据量的计算。其中map对应数据集上的独立元素进行指定的操作，生成键-值对形式中间，reduce则对中间结果中相同的键的所有值进行规约，以得到最终结果。
jobtracker：master节点，只有一个，管理所有作业，任务/作业的监控，错误处理等，将任务分解成一系列任务，并分派给tasktracker。
tacktracker：slave节点，运行 map task和reducetask；并与jobtracker交互，汇报任务状态。
map task：解析每条数据记录，传递给用户编写的map（）并执行，将输出结果写入到本地磁盘（如果为map—only作业，则直接写入HDFS）。
reduce task：从map 它深刻地执行结果中，远程读取输入数据，对数据进行排序，将数据分组传递给用户编写的reduce函数执行。
hive（基于hadoop的数据仓库） 由Facebook开源，最初用于解决海量结构化的日志数据统计问题。
hive定于了一种类似sql的查询语言（hql）将sql转化为mapreduce任务在hadoop上执行。
hbase（分布式列存数据库） hbase是一个针对结构化数据的可伸缩，高可靠，高性能，分布式和面向列的动态模式数据库。和传统关系型数据库不同，hbase采用了bigtable的数据模型： 增强了稀疏排序映射表（key/value）。其中，键由行关键字，列关键字和时间戳构成，hbase提供了对大规模数据的随机，实时读写访问，同时，hbase中保 存的数据可以使用mapreduce来处理，它将数据存储和并行计算完美结合在一起。
zookeeper（分布式协作服务） 解决分布式环境下的数据管理问题：统一命名，状态同步，集群管理，配置同步等。
sqoop（数据同步工具） sqoop是sql-to-hadoop的缩写，主要用于传统数据库和hadoop之间传输数据。数据的导入和导出本质上是mapreduce程序，充分利用了MR的并行化和容错性。
pig（基于hadoop的数据流系统） 定义了一种数据流语言-pig latin，将脚本转换为mapreduce任务在hadoop上执行。通常用于离线分析。
mahout（数据挖掘算法库） mahout的主要目标是创建一些可扩展的机器学习领域经典算法的实现，旨在帮助开发人员更加方便快捷地创建只能应用程序。mahout现在已经包含了聚类，分类， 推荐引擎（协同过滤）和频繁集挖掘等广泛使用的数据挖掘方法。除了算法是，mahout还包含了数据的输入/输出工具，与其他存储系统（如数据库，mongoDB或 Cassandra）集成等数据挖掘支持架构。
flume（日志收集工具） cloudera开源的日志收集系统，具有分布式，高可靠，高容错，易于定制和扩展的特点。他将数据从产生，传输，处理并写入目标的路径的过程抽象为数据流，在 具体的数据流中，数据源支持在flume中定制数据发送方，从而支持收集各种不同协议数据。
资源管理器的简单介绍（YARN和mesos） 随着互联网的高速发展，基于数据 密集型应用 的计算框架不断出现，从支持离线处理的mapreduce，到支持在线处理的storm，从迭代式计算框架到 流式处理框 架s4，&mldr;，在大部分互联网公司中，这几种框架可能都会采用，比如对于搜索引擎公司，可能的技术方法如下：网页建索引采用mapreduce框架，自然语言处理/ 数据挖掘采用spark，对性能要求到的数据挖掘算法用mpi等。公司一般将所有的这些框架部署到一个公共的集群中，让它们共享集群的资源，并对资源进行统一使 用，这样便诞生了资源统一管理与调度平台，典型的代表是mesos和yarn。</p>
</div>
<div class=card-footer>
<span class=float-left>September 17, 2021</span>
<a href=/posts/knowledge/2006-hadoop-env/ class="float-right btn btn-outline-info btn-sm">阅读</a>
</div>
</div>
</a>
</div>
<div class=post-card>
<a href=/posts/knowledge/2005-go-tag/ class=post-card-link>
<div class=card>
<div class=card-head>
<img class=card-img-top src=/posts/knowledge/2005-go-tag/head.svg alt="Hero Image">
</div>
<div class=card-body>
<h5 class=card-title>Golang struct tag浅析与自定义tag实践</h5>
<p class="card-text post-summary">StructTag是写在结构体字段类型后面反引号中的内容，用来标记结构体中各字段的属性。
源码中对struct tag的解释：
By convention, tag strings are a concatenation of optionally space-separated key:&ldquo;value&rdquo; pairs. Each key is a non-empty string consisting of non-control characters other than space (U+0020 ' &lsquo;), quote (U+0022 &lsquo;"'), and colon (U+003A &lsquo;:'). Each value is quoted using U+0022 &lsquo;"&rsquo; characters and Go string literal syntax.
简单应用 最常见的，比如json的tag应用：
json序列化和反序列化时候使用的key都是在struct字段上定义的
package main import ( "encoding/json" "fmt" ) type User struct { ID int `json:"id"` Username string `json:"username"` Age int `json:"age"` Email string `json:"email"` } func main() { u := User{ ID: 1, Username: "ormissia", Age: 90, Email: "email@example.</p>
</div>
<div class=card-footer>
<span class=float-left>August 13, 2021</span>
<a href=/posts/knowledge/2005-go-tag/ class="float-right btn btn-outline-info btn-sm">阅读</a>
</div>
</div>
</a>
</div>
<div class=post-card>
<a href=/posts/knowledge/2004-go-pprof/ class=post-card-link>
<div class=card>
<div class=card-head>
<img class=card-img-top src=/posts/knowledge/2004-go-pprof/head.svg alt="Hero Image">
</div>
<div class=card-body>
<h5 class=card-title>Golang性能分析工具-pprof</h5>
<p class="card-text post-summary">pprof is a tool for visualization and analysis of profiling data.
pprof reads a collection of profiling samples in profile.proto format and generates reports to visualize and help analyze the data. It can generate both text and graphical reports (through the use of the dot visualization package).
PProf是用于可视化和分析性能分析数据的工具，PProf以profile.proto读取分析样本的集合，并生成报告以可视化并帮助分析数据（支持文本和图形报告）。
简介 采集方式 runtime/pprof：采集程序（非Server）的指定区块的运行数据进行分析。 net/http/pprof：基于HTTPServer运行，并且可以采集运行时数据进行分析。 gotest：通过运行测试用例，并指定所需标识来进行采集。 功能 CPUProfiling：CPU分析，按照一定的频率采集所监听的应用程序CPU（含寄存器）的使用情况，可确定应用程序在主动消耗CPU周期时花费时间的位置。 MemoryProfiling：内存分析，在应用程序进行堆分配时记录堆栈跟踪，用于监视当前和历史内存使用情况，以及检查内存泄漏。 BlockProfiling：阻塞分析，记录Goroutine阻塞等待同步（包括定时器通道）的位置，默认不开启，需要调用runtime.SetBlockProfileRate进行设置。 MutexProfiling：互斥锁分析，报告互斥锁的竞争情况，默认不开启，需要调用runtime.SetMutexProfileFraction进行设置。 GoroutineProfiling：Goroutine分析，可以对当前应用程序正在运行的Goroutine进行堆栈跟踪和分析。这项功能在实际排查中会经常用到， 因为很多问题出现时的表象就是Goroutine暴增，而这时候我们要做的事情之一就是查看应用程序中的Goroutine正在做什么事情，因为什么阻塞了， 然后再进行下一步。 简单的例子 注意要在import中引入 _ "net/http/pprof"</p>
</div>
<div class=card-footer>
<span class=float-left>August 5, 2021</span>
<a href=/posts/knowledge/2004-go-pprof/ class="float-right btn btn-outline-info btn-sm">阅读</a>
</div>
</div>
</a>
</div>
<div class=post-card>
<a href=/posts/knowledge/2003-go-reflect/ class=post-card-link>
<div class=card>
<div class=card-head>
<img class=card-img-top src=/posts/knowledge/2003-go-reflect/head.svg alt="Hero Image">
</div>
<div class=card-body>
<h5 class=card-title>Golang反射</h5>
<p class="card-text post-summary">反射简介 Golang提供了一种机制，在编译时不知道类型的情况下，可更新变量、运行时查看值、调用方法以及直接对他们的布局进行操作的机制，称为反射。
reflect 包中的官方注释：Package reflect implements run-time reflection, allowing a program to manipulate objects with arbitrary types.
reflect 实现了运行时的反射能力，能够让程序操作不同类型的对象。反射包中有两对非常重要的函数和类型， 两个函数分别是：
reflect.TypeOf 能获取类型信息 reflect.ValueOf 能获取数据的运行时表示 三大法则 运行时反射是程序在运行期间检查其自身结构的一种方式。反射带来的灵活性是一把双刃剑，反射作为一种元编程方式可以减少重复代码， 但是过量的使用反射会使我们的程序逻辑变得难以理解并且运行缓慢。我们在这一节中会介绍Go语言反射的三大法则，其中包括：
从interface{}变量可以反射出反射对象； 从反射对象可以获取interface{}变量； 要修改反射对象，其值必须可设置； 第一法则 反射的第一法则是我们能将Go语言的interface{}变量转换成反射对象。很多读者可能会对这以法则产生困惑—为什么是从interface{}变量到反射对象？ 当我们执行reflect.ValueOf(1)时，虽然看起来是获取了基本类型int对应的反射类型，但是由于 reflect.TypeOf 、 reflect.ValueOf 两个方法的入参都是interface{}类型，所以在方法执行的过程中发生了类型转换。
因为Go语言的函数调用都是值传递的，所以变量会在函数调用时进行类型转换。基本类型int会转换成interface{}类型， 这也就是为什么第一条法则是从接口到反射对象。
上面提到的reflect.TypeOf 和reflect.ValueOf 函数就能完成这里的转换，如果我们认为Go语言的类型和反射类型处于两个不同的世界，那么这两个函数就是连接这两个世界的桥梁。
我们可以通过以下例子简单介绍它们的作用， reflect.TypeOf 获取了变量author的类型， reflect.ValueOf 获取了变量的值ormissia。如果我们知道了一个变量的类型和值，那么就意味着我们知道了这个变量的全部信息。
package main import ( "fmt" "reflect" ) func main() { author := "ormissia" fmt.</p>
</div>
<div class=card-footer>
<span class=float-left>August 3, 2021</span>
<a href=/posts/knowledge/2003-go-reflect/ class="float-right btn btn-outline-info btn-sm">阅读</a>
</div>
</div>
</a>
</div>
<div class=post-card>
<a href=/posts/knowledge/2002-go-param-verify/ class=post-card-link>
<div class=card>
<div class=card-head>
<img class=card-img-top src=/posts/knowledge/2002-go-param-verify/head.svg alt="Hero Image">
</div>
<div class=card-body>
<h5 class=card-title>Golang 实体参数校验</h5>
<p class="card-text post-summary">A：&ldquo;请用一句话让别人知道你写过Golang。&rdquo;
B：&ldquo;if err!= nil &mldr;&rdquo;
起因 只要是接触过Golang的人，无不为其if err != nil的语法感到惊奇，或是大加赞赏，或是狠狠痛批。作为使用者，不管喜欢也好，反对也罢， 目前还是要接受这种错误处理模式。
而最令人头痛的就是请求参数中各种值的校验。比如Get请求中接收分页参数时，需要将string格式的参数转换成int类型，再如时间类型的参数 转换， 诸如此类，等等等等。好家伙，一个接口写完if err != nil的判断占了一多半的行数，看着实在不爽。
下面就是一个典型的例子，而且这个接口参数还不是特别多
func Export(c *gin.Context) { //删除开头 //... var param map[string]string err := c.ShouldBindJSON(&param) if err != nil { ErrRsponse(c,errCode) return } var vId, userId, userName, format string if v, ok := param["vId"]; ok { vId = v } else { ErrRsponse(c,errCode) return } if len(vId) == 0 { ErrRsponse(c,errCode) return } if v, ok := param["userId"]; ok { userId = v } else { ErrRsponse(c,errCode) return } if v, ok := param["userName"]; ok { userName = v } else { ErrRsponse(c,errCode) return } if v, ok := param["format"]; ok { format = v } else { ErrRsponse(c,errCode) return } if !</p>
</div>
<div class=card-footer>
<span class=float-left>July 27, 2021</span>
<a href=/posts/knowledge/2002-go-param-verify/ class="float-right btn btn-outline-info btn-sm">阅读</a>
</div>
</div>
</a>
</div>
<div class=post-card>
<a href=/posts/knowledge/2001-go-partten-1/ class=post-card-link>
<div class=card>
<div class=card-head>
<img class=card-img-top src=/posts/knowledge/2001-go-partten-1/head.svg alt="Hero Image">
</div>
<div class=card-body>
<h5 class=card-title>Go 惯用模式：函数选项模式</h5>
<p class="card-text post-summary">作为 Golang 开发者，遇到的许多问题之一就是尝试将函数的参数设置成可选项。这是一个十分常见的场景，您可以使用一些已经设置默认配置和开箱即用的对象，同时您也可以使用一些更为详细的配置。
问题出发点 对于许多编程语言来说，这很容易。在 C 语言家族中，您可以提供具有同一个函数但是不同参数的多个版本；在 PHP 之类的语言中，您可以为参数提供默认值，并在调用该方法时将其忽略。但是在 Golang 中，上述的做法都不可以使用。那么您如何创建具有一些其他配置的函数，用户可以根据他的需求（但是仅在需要时）指定一些额外的配置。
有很多的方法可以做到这一点，但是大多数方法都不是尽如人意，要么需要在服务端的代码中进行大量额外的检查和验证，要么通过传入他们不关心的其他参数来为客户端进行额外的工作。
下面我将会介绍一些不同的选项，然后为其说明为什么每个选项都不理想，接着我们会逐步构建自己的方式来作为最终的干净解决方案：函数选项模式。
让我们来看一个例子。比方说，这里有一个叫做StuffClient的服务，它能够胜任一些工作，同时还具有两个配置选项（超时和重试）。
type StuffClient interface { DoStuff() error } type stuffClient struct { conn Connection timeout int retries int } 这是个私有的结构体，因此我们应该为它提供某种构造函数：
func NewStuffClient(conn Connection, timeout, retries int) StuffClient { return &stuffClient{ conn: conn, timeout: timeout, retries: retries, } } 嗯，但是现在我们每次调用NewStuffClient函数时都要提供timeout和retries。因为在大多数情况下，我们只想使用默认值，我们无法使用不同参数数量带定义多个版本的NewStuffClient，否则我们会得到一个类似NewStuffClient redeclared in this block编译错误。
一个可选方案是创建另一个具有不同名称的构造函数，例如：
func NewStuffClient(conn Connection) StuffClient { return &stuffClient{ conn: conn, timeout: DEFAULT_TIMEOUT, retries: DEFAULT_RETRIES, } } func NewStuffClientWithOptions(conn Connection, timeout, retries int) StuffClient { return &stuffClient{ conn: conn, timeout: timeout, retries: retries, } } 但是这么做的话有点蹩脚。我们可以做得更好，如果我们传入了一个配置对象呢:</p>
</div>
<div class=card-footer>
<span class=float-left>July 22, 2021</span>
<a href=/posts/knowledge/2001-go-partten-1/ class="float-right btn btn-outline-info btn-sm">阅读</a>
</div>
</div>
</a>
</div>
</div>
<div class=paginator>
</div>
</div>
</section>
</div>
<footer class="container-fluid text-center align-content-center footer pb-2">
<div class="container pt-5">
<div class="row text-left">
<div class="col-md-4 col-sm-12">
<h5>联系方式:</h5>
<ul>
<li><span>QQ: </span> <span>1432050813</span></li>
<li><a href=mailto:ormissia@outlook.com target=_blank rel=noopener>
<span><i class="fas fa-envelope"></i></span> <span>ormissia@outlook.com</span>
</a></li>
</ul>
</div>
</div>
</div>
<hr>
<div class=container>
<p id=disclaimer><strong>免责声明:</strong> 老铁看到底了，要负责的哦</p>
</div>
<hr>
<div class=container>
<div class="row text-left">
<div class=col-md-4>
<a id=theme href=https://github.com/hossainemruz/toha target=_blank rel=noopener>
<img src=/images/theme-logo_hu8376fd15465fef26ffe66b6bcf0ca686_13669_32x0_resize_box_3.png alt="Toha Theme Logo">
Toha
</a>
</div>
<div class="col-md-4 text-center">© 2021 Copyright.</div>
<div class="col-md-4 text-right">
<a id=hugo href=https://gohugo.io/ target=_blank rel=noopener>Powered by
<img src=/images/hugo-logo.svg alt="Hugo Logo" height=18>
</a>
</div>
</div>
</div>
</footer>
<script type=text/javascript src=/js/jquery-3.4.1.min.js></script>
<script type=text/javascript src=/js/popper.min.js></script>
<script type=text/javascript src=/js/bootstrap.min.js></script>
<script type=text/javascript src=/js/navbar.js></script>
<script type=text/javascript src=/js/plyr.js></script>
<script type=text/javascript src=/js/main.js></script>
<script src=/js/list.js></script>
</body>
</html>