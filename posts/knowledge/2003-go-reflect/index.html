<!doctype html><html>
<head>
<title>Golang反射</title>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta http-equiv=x-ua-compatible content="ie=edge">
<link rel=stylesheet href=/css/bootstrap.min.css>
<link rel=stylesheet href=/css/layouts/main.css>
<link rel=stylesheet href=/css/navigators/navbar.css>
<link rel=stylesheet href=/css/plyr.css>
<link rel=stylesheet href=/css/flag-icon.min.css>
<link href="https://fonts.googleapis.com/css2?family=Muli:wght@300;400;500;600" rel=stylesheet>
<link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css>
<link rel=icon type=image/png href=/images/favicon_hu8376fd15465fef26ffe66b6bcf0ca686_13669_42x0_resize_box_3.png>
<meta property="og:title" content="Golang反射">
<meta property="og:description" content="反射简介  Golang提供了一种机制，在编译时不知道类型的情况下，可更新变量、运行时查看值、调用方法以及直接对他们的布局进行操作的机制，称为反射。
  reflect 包中的官方注释：Package reflect implements run-time reflection, allowing a program to manipulate objects with arbitrary types. 
 reflect 实现了运行时的反射能力，能够让程序操作不同类型的对象。反射包中有两对非常重要的函数和类型， 两个函数分别是：
 reflect.TypeOf 能获取类型信息 reflect.ValueOf 能获取数据的运行时表示  三大法则 运行时反射是程序在运行期间检查其自身结构的一种方式。反射带来的灵活性是一把双刃剑，反射作为一种元编程方式可以减少重复代码， 但是过量的使用反射会使我们的程序逻辑变得难以理解并且运行缓慢。我们在这一节中会介绍Go语言反射的三大法则，其中包括：
 从interface{}变量可以反射出反射对象； 从反射对象可以获取interface{}变量； 要修改反射对象，其值必须可设置；  第一法则 反射的第一法则是我们能将Go语言的interface{}变量转换成反射对象。很多读者可能会对这以法则产生困惑—为什么是从interface{}变量到反射对象？ 当我们执行reflect.ValueOf(1)时，虽然看起来是获取了基本类型int对应的反射类型，但是由于 reflect.TypeOf 、 reflect.ValueOf 两个方法的入参都是interface{}类型，所以在方法执行的过程中发生了类型转换。
因为Go语言的函数调用都是值传递的，所以变量会在函数调用时进行类型转换。基本类型int会转换成interface{}类型， 这也就是为什么第一条法则是从接口到反射对象。
上面提到的reflect.TypeOf 和reflect.ValueOf 函数就能完成这里的转换，如果我们认为Go语言的类型和反射类型处于两个不同的世界，那么这两个函数就是连接这两个世界的桥梁。
我们可以通过以下例子简单介绍它们的作用， reflect.TypeOf 获取了变量author的类型， reflect.ValueOf 获取了变量的值ormissia。如果我们知道了一个变量的类型和值，那么就意味着我们知道了这个变量的全部信息。
package main import ( &#34;fmt&#34; &#34;reflect&#34; ) func main() { author := &#34;ormissia&#34; fmt.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://ormissia.github.io/posts/knowledge/2003-go-reflect/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-08-03T17:17:01+08:00">
<meta property="article:modified_time" content="2021-08-03T17:17:01+08:00">
<meta name=description content="Golang反射">
<link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/atom-one-dark.min.css>
<link rel=stylesheet href=/css/layouts/single.css>
<link rel=stylesheet href=/css/navigators/sidebar.css>
<link rel=stylesheet href=/css/style.css>
</head>
<body data-spy=scroll data-target=#TableOfContents data-offset=80>
<div class="container-fluid bg-dimmed wrapper">
<nav class="navbar navbar-expand-xl top-navbar final-navbar shadow">
<div class=container>
<button class="navbar-toggler navbar-light" id=sidebar-toggler type=button onclick=toggleSidebar()>
<span class=navbar-toggler-icon></span>
</button>
<a class=navbar-brand href=/>
<img src=/images/ormissia_hu763a76473558eea2a316ef50b45aaecf_966068_42x0_resize_box_3.png alt=Logo>
Ormissia's Blog</a>
<button class="navbar-toggler navbar-light" id=toc-toggler type=button onclick=toggleTOC()>
<span class=navbar-toggler-icon></span>
</button>
<div class="collapse navbar-collapse lang-selector" id=top-nav-items>
<ul class="navbar-nav ml-auto">
</ul>
</div>
</div>
<img src=/images/ormissia_hu763a76473558eea2a316ef50b45aaecf_966068_42x0_resize_box_3.png class=d-none id=main-logo alt=Logo>
<img src=/images/ormissia_hu763a76473558eea2a316ef50b45aaecf_966068_42x0_resize_box_3.png class=d-none id=inverted-logo alt="Inverted Logo">
</nav>
<section class=sidebar-section id=sidebar-section>
<div class=sidebar-holder>
<div class=sidebar id=sidebar>
<form class=mx-auto method=get action=/search>
<input type=text name=keyword placeholder=Search data-search id=search-box>
</form>
<div class=sidebar-tree>
<ul class=tree id=tree>
<li id=list-heading><a href=/posts data-filter=all>博文</a></li>
<div class=subtree>
<li>
<i class="fas fa-minus-circle"></i><a class=active href=/posts/knowledge/>知识积累</a>
<ul class=active>
<li><a href=/posts/knowledge/2001-go-partten-1/ title=函数选项模式>函数选项模式</a></li>
<li><a href=/posts/knowledge/2002-go-param-verify/ title=实体参数校验>实体参数校验</a></li>
<li><a class=active href=/posts/knowledge/2003-go-reflect/ title=Golang反射>Golang反射</a></li>
<li><a href=/posts/knowledge/2004-go-pprof/ title=pprof>pprof</a></li>
<li><a href=/posts/knowledge/2005-go-tag/ title="Golang struct tag">Golang struct tag</a></li>
<li><a href=/posts/knowledge/2006-hadoop-env/ title=Hadoop生态组件>Hadoop生态组件</a></li>
<li><a href=/posts/knowledge/2007-hadoop-hdfs/ title=HDFS基础知识>HDFS基础知识</a></li>
<li><a href=/posts/knowledge/2008-elasticstack-es/ title=Elasticsearch>Elasticsearch</a></li>
<li><a href=/posts/knowledge/2009-kubernetes-handless-statefullset/ title=k8s中通过Headless连接StatefulSet>k8s中通过Headless连接StatefulSet</a></li>
<li><a href=/posts/knowledge/2010-kubernetes-index/ title=Kubernetes文档索引>Kubernetes文档索引</a></li>
</ul>
</li>
<li>
<i class="fas fa-plus-circle"></i><a href=/posts/deployment/>环境部署</a>
<ul>
<li><a href=/posts/deployment/3001-blog-cicd/ title=我的博客后端Docker镜像打包自动部署流程>我的博客后端Docker镜像打包自动部署流程</a></li>
<li><a href=/posts/deployment/3002-linux-nginx/ title=Linux部署Nginx流程>Linux部署Nginx流程</a></li>
<li><a href=/posts/deployment/3003-linux-traefik/ title=Traefik部署流程>Traefik部署流程</a></li>
<li><a href=/posts/deployment/3004-linux-grafana/ title=Grafana部署流程>Grafana部署流程</a></li>
<li><a href=/posts/deployment/3005-linux-prometheus/ title=Prometheus部署流程>Prometheus部署流程</a></li>
<li><a href=/posts/deployment/3006-linux-elk/ title=ELK部署流程>ELK部署流程</a></li>
<li><a href=/posts/deployment/3007-linux-kubernetes/ title=Linux部署Kubernetes流程>Linux部署Kubernetes流程</a></li>
</ul>
</li>
<li>
<i class="fas fa-plus-circle"></i><a href=/posts/algorithm/>算法</a>
<ul>
<li><a href=/posts/algorithm/4001-algorithm-sort/ title=排序算法>排序算法</a></li>
<li><a href=/posts/algorithm/4002-algorithm-trie/ title=前缀树>前缀树</a></li>
</ul>
</li>
<li>
<i class="fas fa-plus-circle"></i><a href=/posts/problems/>疑难杂症</a>
<ul>
<li><a href=/posts/problems/5001-go-online-service-oom/ title=记一次线上的内存持续增长问题>记一次线上的内存持续增长问题</a></li>
<li><a href=/posts/problems/5002-k8s-memory/ title=Grafana上监控不准问题排查>Grafana上监控不准问题排查</a></li>
<li><a href=/posts/problems/5003-elasticsearch-start-failed/ title=CentOS安装完ES无法启动>CentOS安装完ES无法启动</a></li>
<li><a href=/posts/problems/5004-kubernetes-dashboard-token/ title="k8s dashboard token过期时间太短">k8s dashboard token过期时间太短</a></li>
<li><a href=/posts/problems/5005-docker-image-source/ title=修改Docker镜像源>修改Docker镜像源</a></li>
<li><a href=/posts/problems/5006-mysql-brew-conf/ title=修改Mac上brew安装的MySQL配置>修改Mac上brew安装的MySQL配置</a></li>
</ul>
</li>
<li>
<i class="fas fa-plus-circle"></i><a href=/posts/unclassified/>未分类</a>
<ul>
<li><a href=/posts/unclassified/6001-markdown/ title="Markdown Sample">Markdown Sample</a></li>
</ul>
</li>
</div>
</ul>
</div>
</div>
</div>
</section>
<section class=content-section id=content-section>
<div class=content>
<div class="container p-0 read-area">
<div class="hero-area col-sm-12" id=hero-area style=background-image:url(https://ormissia.github.io/posts/knowledge/2003-go-reflect/head.svg)>
</div>
<div class=page-content>
<div class="author-profile ml-auto align-self-lg-center">
<img class=rounded-circle src=/images/avatar_hu6760e73bd186896e9f58f2b8b663dec5_93204_120x120_fit_box_3.png alt="Author Image">
<h5 class=author-name>Ormissia</h5>
<p>August 3, 2021</p>
</div>
<div class=title>
<h1>Golang反射</h1>
</div>
<div class=post-content id=post-content>
<hr>
<p><img src=https://img.shields.io/badge/-Golang-blue alt=Golang>
<img src=https://img.shields.io/badge/-%E5%8F%8D%E5%B0%84-orange alt=反射>
<img src=https://img.shields.io/badge/-reflect-red alt=reflect></p>
<hr>
<h2 id=反射简介>反射简介</h2>
<blockquote>
<p>Golang提供了一种机制，在编译时不知道类型的情况下，可更新变量、运行时查看值、调用方法以及直接对他们的布局进行操作的机制，称为反射。</p>
</blockquote>
<blockquote>
<p><a href=https://pkg.go.dev/reflect>reflect</a> 包中的官方注释：<code>Package reflect implements run-time reflection, allowing a program to manipulate objects with arbitrary types. </code></p>
</blockquote>
<p><a href=https://pkg.go.dev/reflect>reflect</a> 实现了运行时的反射能力，能够让程序操作不同类型的对象。反射包中有两对非常重要的函数和类型，
两个函数分别是：</p>
<ul>
<li><a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/type.go#L1393>reflect.TypeOf</a> 能获取类型信息</li>
<li><a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/value.go#L2351>reflect.ValueOf</a> 能获取数据的运行时表示</li>
</ul>
<h2 id=三大法则>三大法则</h2>
<p>运行时反射是程序在运行期间检查其自身结构的一种方式。反射带来的灵活性是一把双刃剑，反射作为一种元编程方式可以减少重复代码，
但是过量的使用反射会使我们的程序逻辑变得难以理解并且运行缓慢。我们在这一节中会介绍Go语言反射的三大法则，其中包括：</p>
<ol>
<li>从<code>interface{}</code>变量可以反射出反射对象；</li>
<li>从反射对象可以获取<code>interface{}</code>变量；</li>
<li>要修改反射对象，其值必须可设置；</li>
</ol>
<h3 id=第一法则>第一法则</h3>
<p>反射的第一法则是我们能将Go语言的<code>interface{}</code>变量转换成反射对象。很多读者可能会对这以法则产生困惑—为什么是从<code>interface{</code>}变量到反射对象？
当我们执行<code>reflect.ValueOf(1)</code>时，虽然看起来是获取了基本类型<code>int</code>对应的反射类型，但是由于
<a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/type.go#L1393>reflect.TypeOf</a> 、
<a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/value.go#L2351>reflect.ValueOf</a>
两个方法的入参都是<code>interface{}</code>类型，所以在方法执行的过程中发生了类型转换。</p>
<p>因为Go语言的函数调用都是值传递的，所以变量会在函数调用时进行类型转换。基本类型<code>int</code>会转换成<code>interface{}</code>类型，
这也就是为什么第一条法则是从接口到反射对象。</p>
<p>上面提到的<a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/type.go#L1393>reflect.TypeOf</a>
和<a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/value.go#L2351>reflect.ValueOf</a>
函数就能完成这里的转换，如果我们认为Go语言的类型和反射类型处于两个不同的世界，那么这两个函数就是连接这两个世界的桥梁。</p>
<p>我们可以通过以下例子简单介绍它们的作用，
<a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/type.go#L1393>reflect.TypeOf</a>
获取了变量<code>author</code>的类型，
<a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/value.go#L2351>reflect.ValueOf</a>
获取了变量的值<code>ormissia</code>。如果我们知道了一个变量的类型和值，那么就意味着我们知道了这个变量的全部信息。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> (
	<span style=color:#e6db74>&#34;fmt&#34;</span>
	<span style=color:#e6db74>&#34;reflect&#34;</span>
)

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>author</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;ormissia&#34;</span>
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;TypeOf author:&#34;</span>, <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>TypeOf</span>(<span style=color:#a6e22e>author</span>))
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;ValueOf author:&#34;</span>, <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>ValueOf</span>(<span style=color:#a6e22e>author</span>))
}

<span style=color:#960050;background-color:#1e0010>$</span> <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>run</span> <span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>
<span style=color:#a6e22e>TypeOf</span> <span style=color:#a6e22e>author</span>: <span style=color:#66d9ef>string</span>
<span style=color:#a6e22e>ValueOf</span> <span style=color:#a6e22e>author</span>: <span style=color:#a6e22e>ormissia</span>
</code></pre></div><p>有了变量的类型之后，我们可以通过<code>Method</code>方法获得类型实现的方法，通过Field获取类型包含的全部字段。对于不同的类型，
我们也可以调用不同的方法获取相关信息：</p>
<ul>
<li>结构体：获取字段的数量并通过下标和字段名获取字段StructField；</li>
<li>哈希表：获取哈希表的Key类型；</li>
<li>函数或方法：获取入参和返回值的类型；</li>
<li>…</li>
</ul>
<p>总而言之，使用<a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/type.go#L1393>reflect.TypeOf</a>
和<a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/value.go#L2351>reflect.ValueOf</a>
能够获取Go语言中的变量对应的反射对象。一旦获取了反射对象，我们就能得到跟当前类型相关数据和操作，并可以使用这些运行时获取的结构执行方法。</p>
<h3 id=第二法则>第二法则</h3>
<p>反射的第二法则是我们可以从反射对象可以获取<code>interface{}</code>变量。既然能够将接口类型的变量转换成反射对象，
那么一定需要其他方法将反射对象还原成接口类型的变量，<a href=https://golang.org/pkg/reflect/>reflect</a> 中的
<a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/value.go#L1015>reflect.Value.Interface</a>
就能完成这项工作</p>
<p>不过调用<a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/value.go#L1015>reflect.Value.Interface</a>
方法只能获得<code>interface{}</code>类型的变量，如果想要将其还原成最原始的状态还需要经过如下所示的显式类型转换：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>ValueOf</span>(<span style=color:#ae81ff>1</span>)
<span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>Interface</span>().(<span style=color:#66d9ef>int</span>)
</code></pre></div><p>从反射对象到接口值的过程是从接口值到反射对象的镜面过程，两个过程都需要经历两次转换：</p>
<ul>
<li>从接口值到反射对象：
<ul>
<li>从基本类型到接口类型的类型转换；</li>
<li>从接口类型到反射对象的转换；</li>
</ul>
</li>
<li>从反射对象到接口值：
<ul>
<li>反射对象转换成接口类型；</li>
<li>通过显式类型转换变成原始类型；</li>
</ul>
</li>
</ul>
<p>当然不是所有的变量都需要类型转换这一过程。如果变量本身就是<code>interface{}</code>类型的，那么它不需要类型转换，因为类型转换这一过程一般都是隐式的，
所以我不太需要关心它，只有在我们需要将反射对象转换回基本类型时才需要显式的转换操作。</p>
<h3 id=第三法则>第三法则</h3>
<p>Go语言反射的最后一条法则是与值是否可以被更改有关，如果我们想要更新一个
<a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/value.go#L37>reflect.Value</a> ，
那么它持有的值一定是可以被更新的，假设我们有以下代码：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>1</span>
	<span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>ValueOf</span>(<span style=color:#a6e22e>i</span>)
	<span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>SetInt</span>(<span style=color:#ae81ff>10</span>)
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>i</span>)
}

<span style=color:#960050;background-color:#1e0010>$</span> <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>run</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#66d9ef>go</span>
<span style=color:#a6e22e>panic</span>: <span style=color:#a6e22e>reflect</span>: <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Value</span>.<span style=color:#a6e22e>SetInt</span> <span style=color:#a6e22e>using</span> <span style=color:#a6e22e>unaddressable</span> <span style=color:#a6e22e>value</span>

<span style=color:#a6e22e>goroutine</span> <span style=color:#ae81ff>1</span> [<span style=color:#a6e22e>running</span>]:
<span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>flag</span>.<span style=color:#a6e22e>mustBeAssignableSlow</span>(<span style=color:#ae81ff>0x82</span>)
	<span style=color:#f92672>/</span><span style=color:#a6e22e>usr</span><span style=color:#f92672>/</span><span style=color:#a6e22e>local</span><span style=color:#f92672>/</span><span style=color:#66d9ef>go</span><span style=color:#f92672>/</span><span style=color:#a6e22e>src</span><span style=color:#f92672>/</span><span style=color:#a6e22e>reflect</span><span style=color:#f92672>/</span><span style=color:#a6e22e>value</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>260</span> <span style=color:#f92672>+</span><span style=color:#ae81ff>0x118</span>
<span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>flag</span>.<span style=color:#a6e22e>mustBeAssignable</span>(<span style=color:#f92672>...</span>)
	<span style=color:#f92672>/</span><span style=color:#a6e22e>usr</span><span style=color:#f92672>/</span><span style=color:#a6e22e>local</span><span style=color:#f92672>/</span><span style=color:#66d9ef>go</span><span style=color:#f92672>/</span><span style=color:#a6e22e>src</span><span style=color:#f92672>/</span><span style=color:#a6e22e>reflect</span><span style=color:#f92672>/</span><span style=color:#a6e22e>value</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>247</span>
<span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Value</span>.<span style=color:#a6e22e>SetInt</span>(<span style=color:#ae81ff>0x100196bc0</span>, <span style=color:#ae81ff>0x10021f8e8</span>, <span style=color:#ae81ff>0x82</span>, <span style=color:#ae81ff>0xa</span>)
	<span style=color:#f92672>/</span><span style=color:#a6e22e>usr</span><span style=color:#f92672>/</span><span style=color:#a6e22e>local</span><span style=color:#f92672>/</span><span style=color:#66d9ef>go</span><span style=color:#f92672>/</span><span style=color:#a6e22e>src</span><span style=color:#f92672>/</span><span style=color:#a6e22e>reflect</span><span style=color:#f92672>/</span><span style=color:#a6e22e>value</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>1637</span> <span style=color:#f92672>+</span><span style=color:#ae81ff>0x30</span>
<span style=color:#a6e22e>main</span>.<span style=color:#a6e22e>main</span>()
	<span style=color:#f92672>/</span><span style=color:#a6e22e>Users</span><span style=color:#f92672>/</span><span style=color:#a6e22e>orimissia</span><span style=color:#f92672>/</span><span style=color:#a6e22e>workspace</span><span style=color:#f92672>/</span><span style=color:#a6e22e>awesomeProject</span><span style=color:#f92672>/</span><span style=color:#a6e22e>goroutine</span><span style=color:#f92672>/</span><span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>13</span> <span style=color:#f92672>+</span><span style=color:#ae81ff>0xb8</span>
</code></pre></div><p>运行上述代码会导致程序崩溃并报出“reflect:reflect.flag.mustBeAssignableusingunaddressablevalue”错误，
仔细思考一下就能够发现出错的原因：由于Go语言的函数调用都是传值的，所以我们得到的反射对象跟最开始的变量没有任何关系，
那么直接修改反射对象无法改变原始变量，程序为了防止错误就会崩溃。</p>
<p>想要修改原变量只能使用如下的方法：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>1</span>
	<span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>ValueOf</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>i</span>)
	<span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>Elem</span>().<span style=color:#a6e22e>SetInt</span>(<span style=color:#ae81ff>10</span>)
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>i</span>)
}

<span style=color:#960050;background-color:#1e0010>$</span> <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>run</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#66d9ef>go</span>
<span style=color:#ae81ff>10</span>
</code></pre></div><ol>
<li>调用<a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/value.go#L2351>reflect.ValueOf</a>
获取变量指针；</li>
<li>调用<a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/value.go#L811>reflect.Value.Elem</a>
获取指针指向的变量；</li>
<li>调用<a href=https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/reflect/value.go#L1636>reflect.Value.SetInt</a>
更新变量的值：</li>
</ol>
<p>由于Go语言的函数调用都是值传递的，所以我们只能只能用迂回的方式改变原变量：先获取指针对应的
<a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/value.go#L37>reflect.Value</a> ，
再通过<a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/value.go#L811>reflect.Value.Elem</a>
方法得到可以被设置的变量，我们可以通过下面的代码理解这个过程：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>1</span>
	<span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>i</span>
	<span style=color:#f92672>*</span><span style=color:#a6e22e>v</span> = <span style=color:#ae81ff>10</span>
}
</code></pre></div><p>如果不能直接操作<code>i</code>变量修改其持有的值，我们就只能获取<code>i</code>变量所在地址并使用<code>*v</code>修改所在地址中存储的整数。</p>
<h2 id=类型和值>类型和值</h2>
<p>Go语言的<code>interface{}</code>类型在语言内部是通过<a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/value.go#L194>reflect.emptyInterface</a>
结体表示的，其中的<code>rtype</code>字段用于表示变量的类型，另一个<code>word</code>字段指向内部封装的数据：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>emptyInterface</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>typ</span>  <span style=color:#f92672>*</span><span style=color:#a6e22e>rtype</span>
	<span style=color:#a6e22e>word</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>
}
</code></pre></div><p>用于获取变量类型的<code>reflect.TypeOf</code>函数将传入的变量隐式转换成
<a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/value.go#L194>reflect.emptyInterface</a>
类型并获取其中存储的类型信息<code>reflect.rtype</code>：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>TypeOf</span>(<span style=color:#a6e22e>i</span> <span style=color:#66d9ef>interface</span>{}) <span style=color:#a6e22e>Type</span> {
	<span style=color:#a6e22e>eface</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>emptyInterface</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>i</span>))
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>toType</span>(<span style=color:#a6e22e>eface</span>.<span style=color:#a6e22e>typ</span>)
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>toType</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>rtype</span>) <span style=color:#a6e22e>Type</span> {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
	}
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>t</span>
}
</code></pre></div><p><code>reflect.rtype</code>是一个实现了<code>reflect.Type</code>接口的结构体，该结构体实现的
<a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/type.go#L755>reflect.rtype.String</a>
方法可以帮助我们获取当前类型的名称：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>rtype</span>) <span style=color:#a6e22e>String</span>() <span style=color:#66d9ef>string</span> {
	<span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>nameOff</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>str</span>).<span style=color:#a6e22e>name</span>()
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>tflag</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>tflagExtraStar</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>s</span>[<span style=color:#ae81ff>1</span>:]
	}
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>s</span>
}
</code></pre></div><p><a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/type.go#L1393>reflect.TypeOf</a>
的实现原理其实并不复杂，它只是将一个<code>interface{}</code>变量转换成了内部的
<a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/value.go#L194>reflect.emptyInterface</a>
表示，然后从中获取相应的类型信息。</p>
<p>用于获取接口值<a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/value.go#L37>reflect.Value</a>
的函数<a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/value.go#L2351>reflect.ValueOf</a>
实现也非常简单，在该函数中我们先调用了
<a href=https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/value.go#L2779>reflect.escapes</a>
保证当前值逃逸到堆上，然后通过
<a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/value.go#L142>reflect.unpackEface</a>
从接口中获取<a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/value.go#L37>reflect.Value</a>
结构体：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>ValueOf</span>(<span style=color:#a6e22e>i</span> <span style=color:#66d9ef>interface</span>{}) <span style=color:#a6e22e>Value</span> {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Value</span>{}
	}

	<span style=color:#a6e22e>escapes</span>(<span style=color:#a6e22e>i</span>)

	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>unpackEface</span>(<span style=color:#a6e22e>i</span>)
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>unpackEface</span>(<span style=color:#a6e22e>i</span> <span style=color:#66d9ef>interface</span>{}) <span style=color:#a6e22e>Value</span> {
	<span style=color:#a6e22e>e</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>emptyInterface</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>i</span>))
	<span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>typ</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Value</span>{}
	}
	<span style=color:#a6e22e>f</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>flag</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Kind</span>())
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ifaceIndir</span>(<span style=color:#a6e22e>t</span>) {
		<span style=color:#a6e22e>f</span> <span style=color:#f92672>|=</span> <span style=color:#a6e22e>flagIndir</span>
	}
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Value</span>{<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>word</span>, <span style=color:#a6e22e>f</span>}
}
</code></pre></div><p><a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/value.go#L142>reflect.unpackEface</a>
会将传入的接口转换成
<a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/value.go#L194>reflect.emptyInterface</a>，
然后将具体类型和指针包装成
<a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/value.go#L37>reflect.Value</a>
结构体后返回。</p>
<p><a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/type.go#L1393>reflect.TypeOf</a>
和<a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/value.go#L2351>reflect.ValueOf</a>
的实现都很简单。我们已经分析了这两个函数的实现，现在需要了解编译器在调用函数之前做了哪些工作：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> (
	<span style=color:#e6db74>&#34;reflect&#34;</span>
)

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>20</span>
	<span style=color:#a6e22e>_</span> = <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>TypeOf</span>(<span style=color:#a6e22e>i</span>)
}

<span style=color:#960050;background-color:#1e0010>$</span> <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>build</span> <span style=color:#f92672>-</span><span style=color:#a6e22e>gcflags</span>=<span style=color:#e6db74>&#34;-S -N&#34;</span> <span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>
<span style=color:#f92672>...</span>
<span style=color:#a6e22e>MOVQ</span>	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>20</span>, <span style=color:#e6db74>&#34;&#34;</span>..<span style=color:#a6e22e>autotmp_20</span><span style=color:#f92672>+</span><span style=color:#ae81ff>56</span>(<span style=color:#a6e22e>SP</span>) <span style=color:#75715e>// autotmp = 20
</span><span style=color:#75715e></span><span style=color:#a6e22e>LEAQ</span>	<span style=color:#66d9ef>type</span>.int(<span style=color:#a6e22e>SB</span>), <span style=color:#a6e22e>AX</span>           <span style=color:#75715e>// AX = type.int(SB)
</span><span style=color:#75715e></span><span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>AX</span>, <span style=color:#e6db74>&#34;&#34;</span>..<span style=color:#a6e22e>autotmp_19</span><span style=color:#f92672>+</span><span style=color:#ae81ff>280</span>(<span style=color:#a6e22e>SP</span>) <span style=color:#75715e>// autotmp_19+280(SP) = type.int(SB)
</span><span style=color:#75715e></span><span style=color:#a6e22e>LEAQ</span>	<span style=color:#e6db74>&#34;&#34;</span>..<span style=color:#a6e22e>autotmp_20</span><span style=color:#f92672>+</span><span style=color:#ae81ff>56</span>(<span style=color:#a6e22e>SP</span>), <span style=color:#a6e22e>CX</span>  <span style=color:#75715e>// CX = 20
</span><span style=color:#75715e></span><span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>CX</span>, <span style=color:#e6db74>&#34;&#34;</span>..<span style=color:#a6e22e>autotmp_19</span><span style=color:#f92672>+</span><span style=color:#ae81ff>288</span>(<span style=color:#a6e22e>SP</span>) <span style=color:#75715e>// autotmp_19+288(SP) = 20
</span><span style=color:#75715e></span><span style=color:#f92672>...</span>
</code></pre></div><p>从上面这段截取的汇编语言，我们可以发现在函数调用之前已经发生了类型转换，上述指令将<code>int</code>类型的变量转换成了占用16字节
<code>autotmp_19+280(SP) ~ autotmp_19+288(SP)</code>的接口，两个<code>LEAQ</code>指令分别获取了类型的指针<code>type.int(SB)</code>以及变量<code>i</code>所在的地址。</p>
<p>当我们想要将一个变量转换成反射对象时，Go语言会在编译期间完成类型转换，将变量的类型和值转换成了<code>interface{}</code>并等待运行期间使用
<a href=https://golang.org/pkg/reflect/>reflect</a> 包获取接口中存储的信息。</p>
<h2 id=更新变量>更新变量</h2>
<p>当我们想要更新<a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/value.go#L37>reflect.Value</a>
时，就需要调用
<a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/value.go#L1557>reflect.Value.Set</a>
更新反射对象，该方法会调用
<a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/value.go#L245>reflect.flag.mustBeAssignable</a>
和<a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/value.go#L227>reflect.flag.mustBeExported</a>
分别检查当前反射对象是否是可以被设置的以及字段是否是对外公开的：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>v</span> <span style=color:#a6e22e>Value</span>) <span style=color:#a6e22e>Set</span>(<span style=color:#a6e22e>x</span> <span style=color:#a6e22e>Value</span>) {
	<span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>mustBeAssignable</span>()
	<span style=color:#a6e22e>x</span>.<span style=color:#a6e22e>mustBeExported</span>()
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>target</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>kind</span>() <span style=color:#f92672>==</span> <span style=color:#a6e22e>Interface</span> {
		<span style=color:#a6e22e>target</span> = <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>ptr</span>
	}
	<span style=color:#a6e22e>x</span> = <span style=color:#a6e22e>x</span>.<span style=color:#a6e22e>assignTo</span>(<span style=color:#e6db74>&#34;reflect.Set&#34;</span>, <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>typ</span>, <span style=color:#a6e22e>target</span>)
	<span style=color:#a6e22e>typedmemmove</span>(<span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>typ</span>, <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>ptr</span>, <span style=color:#a6e22e>x</span>.<span style=color:#a6e22e>ptr</span>)
}
</code></pre></div><p><a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/value.go#L1557>reflect.Value.Set</a>
会调用<a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/value.go#L2418>reflect.Value.assignTo</a>
并返回一个新的反射对象，这个返回的反射对象指针会直接覆盖原反射变量。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>v</span> <span style=color:#a6e22e>Value</span>) <span style=color:#a6e22e>assignTo</span>(<span style=color:#a6e22e>context</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>dst</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>rtype</span>, <span style=color:#a6e22e>target</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>) <span style=color:#a6e22e>Value</span> {
	<span style=color:#f92672>...</span>
	<span style=color:#66d9ef>switch</span> {
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>directlyAssignable</span>(<span style=color:#a6e22e>dst</span>, <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>typ</span>):
		<span style=color:#f92672>...</span>
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Value</span>{<span style=color:#a6e22e>dst</span>, <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>ptr</span>, <span style=color:#a6e22e>fl</span>}
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>implements</span>(<span style=color:#a6e22e>dst</span>, <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>typ</span>):
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>Kind</span>() <span style=color:#f92672>==</span> <span style=color:#a6e22e>Interface</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>IsNil</span>() {
			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Value</span>{<span style=color:#a6e22e>dst</span>, <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>flag</span>(<span style=color:#a6e22e>Interface</span>)}
		}
		<span style=color:#a6e22e>x</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>valueInterface</span>(<span style=color:#a6e22e>v</span>, <span style=color:#66d9ef>false</span>)
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>dst</span>.<span style=color:#a6e22e>NumMethod</span>() <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
			<span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#66d9ef>interface</span>{})(<span style=color:#a6e22e>target</span>) = <span style=color:#a6e22e>x</span>
		} <span style=color:#66d9ef>else</span> {
			<span style=color:#a6e22e>ifaceE2I</span>(<span style=color:#a6e22e>dst</span>, <span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>target</span>)
		}
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Value</span>{<span style=color:#a6e22e>dst</span>, <span style=color:#a6e22e>target</span>, <span style=color:#a6e22e>flagIndir</span> | <span style=color:#a6e22e>flag</span>(<span style=color:#a6e22e>Interface</span>)}
	}
	panic(<span style=color:#a6e22e>context</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;: value of type &#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>typ</span>.<span style=color:#a6e22e>String</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; is not assignable to type &#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>dst</span>.<span style=color:#a6e22e>String</span>())
}
</code></pre></div><p><a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/value.go#L2418>reflect.Value.assignTo</a>
会根据当前和被设置的反射对象类型创建一个新的
<a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/value.go#L37>reflect.Value</a>
结构体：</p>
<ul>
<li>如果两个反射对象的类型是可以被直接替换，就会直接返回目标反射对象；</li>
<li>如果当前反射对象是接口并且目标对象实现了接口，就会把目标对象简单包装成接口值</li>
</ul>
<p>在变量更新的过程中，
<a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/value.go#L2418>reflect.Value.assignTo</a>
返回的<a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/value.go#L37>reflect.Value</a>
中的指针会覆盖当前反射对象中的指针实现变量的更新。</p>
<h2 id=实现协议>实现协议</h2>
<p><a href=https://pkg.go.dev/reflect>reflect</a> 包还为我们提供了
<a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/type.go#L1458>reflect.rtype.Implements</a>
方法可以用于判断某些类型是否遵循特定的接口。在Go语言中获取结构体的反射类型
<a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/type.go#L38>reflect.Type</a>
还是比较容易的，但是想要获得接口类型需要通过以下方式：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>TypeOf</span>((<span style=color:#f92672>*</span>&lt;<span style=color:#66d9ef>interface</span>&gt;)(<span style=color:#66d9ef>nil</span>)).<span style=color:#a6e22e>Elem</span>()
</code></pre></div><p>我们通过一个例子在介绍如何判断一个类型是否实现了某个接口。假设我们需要判断如下代码中的<code>CustomError</code>是否实现了Go语言标准库中的<code>error</code>接口：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>CustomError</span> <span style=color:#66d9ef>struct</span>{}

<span style=color:#66d9ef>func</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>CustomError</span>) <span style=color:#a6e22e>Error</span>() <span style=color:#66d9ef>string</span> {
	<span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;&#34;</span>
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>typeOfError</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>TypeOf</span>((<span style=color:#f92672>*</span><span style=color:#66d9ef>error</span>)(<span style=color:#66d9ef>nil</span>)).<span style=color:#a6e22e>Elem</span>()
	<span style=color:#a6e22e>customErrorPtr</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>TypeOf</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>CustomError</span>{})
	<span style=color:#a6e22e>customError</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>TypeOf</span>(<span style=color:#a6e22e>CustomError</span>{})

	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>customErrorPtr</span>.<span style=color:#a6e22e>Implements</span>(<span style=color:#a6e22e>typeOfError</span>)) <span style=color:#75715e>// #=&gt; true
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>customError</span>.<span style=color:#a6e22e>Implements</span>(<span style=color:#a6e22e>typeOfError</span>)) <span style=color:#75715e>// #=&gt; false
</span><span style=color:#75715e></span>}
</code></pre></div><p>上述代码的运行结果正如我们在接口一节中介绍的：</p>
<ul>
<li><code>CustomError</code>类型并没有实现<code>error</code>接口</li>
<li><code>*CustomError</code>指针类型实现了<code>error</code>接口</li>
</ul>
<p>抛开上述的执行结果不谈，我们来分析一下
<a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/type.go#L1458>reflect.rtype.Implements</a>
方法的工作原理：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>rtype</span>) <span style=color:#a6e22e>Implements</span>(<span style=color:#a6e22e>u</span> <span style=color:#a6e22e>Type</span>) <span style=color:#66d9ef>bool</span> {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>u</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
		panic(<span style=color:#e6db74>&#34;reflect: nil type passed to Type.Implements&#34;</span>)
	}
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>u</span>.<span style=color:#a6e22e>Kind</span>() <span style=color:#f92672>!=</span> <span style=color:#a6e22e>Interface</span> {
		panic(<span style=color:#e6db74>&#34;reflect: non-interface type passed to Type.Implements&#34;</span>)
	}
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>implements</span>(<span style=color:#a6e22e>u</span>.(<span style=color:#f92672>*</span><span style=color:#a6e22e>rtype</span>), <span style=color:#a6e22e>t</span>)
}
</code></pre></div><p><a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/type.go#L1458>reflect.rtype.Implements</a>
会检查传入的类型是不是接口，如果不是接口或者是空值就会直接崩溃并中止当前程序。在参数没有问题的情况下，上述方法会调用私有函数
<a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/type.go#L1458>reflect.implements</a>
判断类型之间是否有实现关系：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>implements</span>(<span style=color:#a6e22e>T</span>, <span style=color:#a6e22e>V</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>rtype</span>) <span style=color:#66d9ef>bool</span> {
	<span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>interfaceType</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>T</span>))
	<span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>methods</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
	}
	<span style=color:#f92672>...</span>
	<span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>V</span>.<span style=color:#a6e22e>uncommon</span>()
	<span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
	<span style=color:#a6e22e>vmethods</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>methods</span>()
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>j</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>j</span> &lt; int(<span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>mcount</span>); <span style=color:#a6e22e>j</span><span style=color:#f92672>++</span> {
		<span style=color:#a6e22e>tm</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>methods</span>[<span style=color:#a6e22e>i</span>]
		<span style=color:#a6e22e>tmName</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>nameOff</span>(<span style=color:#a6e22e>tm</span>.<span style=color:#a6e22e>name</span>)
		<span style=color:#a6e22e>vm</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>vmethods</span>[<span style=color:#a6e22e>j</span>]
		<span style=color:#a6e22e>vmName</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>V</span>.<span style=color:#a6e22e>nameOff</span>(<span style=color:#a6e22e>vm</span>.<span style=color:#a6e22e>name</span>)
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>vmName</span>.<span style=color:#a6e22e>name</span>() <span style=color:#f92672>==</span> <span style=color:#a6e22e>tmName</span>.<span style=color:#a6e22e>name</span>() <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>V</span>.<span style=color:#a6e22e>typeOff</span>(<span style=color:#a6e22e>vm</span>.<span style=color:#a6e22e>mtyp</span>) <span style=color:#f92672>==</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>typeOff</span>(<span style=color:#a6e22e>tm</span>.<span style=color:#a6e22e>typ</span>) {
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&gt;=</span> len(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>methods</span>) {
				<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
			}
		}
	}
	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
}
</code></pre></div><p>如果接口中不包含任何方法，就意味着这是一个空的接口，任意类型都自动实现该接口，这时会直接返回<code>true</code>。</p>
<p>在其他情况下，由于方法都是按照字母序存储的，
<a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/type.go#L1458>reflect.implements</a>
会维护两个用于遍历接口和类型方法的索引<code>i</code>和<code>j</code>判断类型是否实现了接口，因为最多只会进行<code>n</code>次比较（类型的方法数量），所以整个过程的时间复杂度是𝑂(𝑛)。</p>
<h2 id=方法调用>方法调用</h2>
<p>作为一门静态语言，如果我们想要通过<a href=https://golang.org/pkg/reflect/>reflect</a> 包利用反射在运行期间执行方法不是一件容易的事情，下面的十几行代码就使用反射来执行<code>Add(0,1)</code>函数：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Add</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> { <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>b</span> }

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>ValueOf</span>(<span style=color:#a6e22e>Add</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>Kind</span>() <span style=color:#f92672>!=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Func</span> {
		<span style=color:#66d9ef>return</span>
	}
	<span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>Type</span>()
	<span style=color:#a6e22e>argv</span> <span style=color:#f92672>:=</span> make([]<span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Value</span>, <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>NumIn</span>())
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>argv</span> {
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>In</span>(<span style=color:#a6e22e>i</span>).<span style=color:#a6e22e>Kind</span>() <span style=color:#f92672>!=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Int</span> {
			<span style=color:#66d9ef>return</span>
		}
		<span style=color:#a6e22e>argv</span>[<span style=color:#a6e22e>i</span>] = <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>ValueOf</span>(<span style=color:#a6e22e>i</span>)
	}
	<span style=color:#a6e22e>result</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>Call</span>(<span style=color:#a6e22e>argv</span>)
	<span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>result</span>) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>result</span>[<span style=color:#ae81ff>0</span>].<span style=color:#a6e22e>Kind</span>() <span style=color:#f92672>!=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Int</span> {
		<span style=color:#66d9ef>return</span>
	}
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>result</span>[<span style=color:#ae81ff>0</span>].<span style=color:#a6e22e>Int</span>()) <span style=color:#75715e>// #=&gt; 1
</span><span style=color:#75715e></span>}
</code></pre></div><ol>
<li>通过<a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/value.go#L2351>reflect.ValueOf</a>
获取函数<code>Add</code>对应的反射对象；</li>
<li>调用<a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/type.go#L982>reflect.rtype.NumIn</a>
获取函数的入参个数；</li>
<li>多次调用<a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/value.go#L2351>reflect.ValueOf</a>
函数逐一设置<code>argv</code>数组中的各个参数；</li>
<li>调用反射对象<code>Add</code>的<a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/value.go#L334>reflect.Value.Call</a>
方法并传入参数列表；</li>
<li>获取返回值数组、验证数组的长度以及类型并打印其中的数据；</li>
</ol>
<p>使用反射来调用方法非常复杂，原本只需要一行代码就能完成的工作，现在需要十几行代码才能完成，但这也是在静态语言中使用动态特性需要付出的成本。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>v</span> <span style=color:#a6e22e>Value</span>) <span style=color:#a6e22e>Call</span>(<span style=color:#a6e22e>in</span> []<span style=color:#a6e22e>Value</span>) []<span style=color:#a6e22e>Value</span> {
	<span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>mustBe</span>(<span style=color:#a6e22e>Func</span>)
	<span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>mustBeExported</span>()
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>call</span>(<span style=color:#e6db74>&#34;Call&#34;</span>, <span style=color:#a6e22e>in</span>)
}
</code></pre></div><p><a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/value.go#L334>reflect.Value.Call</a>
是运行时调用方法的入口，它通过两个<code>MustBe</code>开头的方法确定了当前反射对象的类型是函数以及可见性，随后调用
<a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/value.go#L334>reflect.Value.call</a>
完成方法调用，这个私有方法的执行过程会分成以下的几个部分：</p>
<ol>
<li>检查输入参数以及类型的合法性；</li>
<li>将传入的<a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/value.go#L37>reflect.Value</a>
参数数组设置到栈上；</li>
<li>通过函数指针和输入参数调用函数；</li>
<li>从栈上获取函数的返回值；</li>
</ol>
<p>我们将按照上面的顺序分析使用<a href=https://golang.org/pkg/reflect/>reflect</a> 进行函数调用的几个过程。</p>
<h3 id=参数检查>参数检查</h3>
<p>参数检查是通过反射调用方法的第一步，在参数检查期间我们会从反射对象中取出当前的函数指针<code>unsafe.Pointer</code>，如果该函数指针是方法，
那么我们会通过<a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/value.go#L635>reflect.methodReceiver</a>
获取方法的接收者和函数指针。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>v</span> <span style=color:#a6e22e>Value</span>) <span style=color:#a6e22e>call</span>(<span style=color:#a6e22e>op</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>in</span> []<span style=color:#a6e22e>Value</span>) []<span style=color:#a6e22e>Value</span> {
	<span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>funcType</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>typ</span>))
	<span style=color:#f92672>...</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>flag</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>flagMethod</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
		<span style=color:#a6e22e>rcvr</span> = <span style=color:#a6e22e>v</span>
		<span style=color:#a6e22e>rcvrtype</span>, <span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>fn</span> = <span style=color:#a6e22e>methodReceiver</span>(<span style=color:#a6e22e>op</span>, <span style=color:#a6e22e>v</span>, int(<span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>flag</span>)<span style=color:#f92672>&gt;&gt;</span><span style=color:#a6e22e>flagMethodShift</span>)
	} <span style=color:#66d9ef>else</span> {
		<span style=color:#f92672>...</span>
	}
	<span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>NumIn</span>()
	<span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>in</span>) &lt; <span style=color:#a6e22e>n</span> {
		panic(<span style=color:#e6db74>&#34;reflect: Call with too few input arguments&#34;</span>)
	}
	<span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>in</span>) &gt; <span style=color:#a6e22e>n</span> {
		panic(<span style=color:#e6db74>&#34;reflect: Call with too many input arguments&#34;</span>)
	}
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>n</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>xt</span>, <span style=color:#a6e22e>targ</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>in</span>[<span style=color:#a6e22e>i</span>].<span style=color:#a6e22e>Type</span>(), <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>In</span>(<span style=color:#a6e22e>i</span>); !<span style=color:#a6e22e>xt</span>.<span style=color:#a6e22e>AssignableTo</span>(<span style=color:#a6e22e>targ</span>) {
			panic(<span style=color:#e6db74>&#34;reflect: &#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>op</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; using &#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>xt</span>.<span style=color:#a6e22e>String</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; as type &#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>targ</span>.<span style=color:#a6e22e>String</span>())
		}
	}
</code></pre></div><p>上述方法还会检查传入参数的个数以及参数的类型与函数签名中的类型是否可以匹配，任何参数的不匹配都会导致整个程序的崩溃中止。</p>
<h3 id=准备参数>准备参数</h3>
<p>当我们已经对当前方法的参数完成验证后，就会进入函数调用的下一个阶段，为函数调用准备参数，在前面函数调用一节中，我们已经介绍过Go语言的函数调用惯例，
函数或者方法在调用时，所有的参数都会被依次放到栈上。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>	<span style=color:#a6e22e>nout</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>NumOut</span>()
	<span style=color:#a6e22e>frametype</span>, <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>retOffset</span>, <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>framePool</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>funcLayout</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>rcvrtype</span>)

	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>args</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>nout</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
		<span style=color:#a6e22e>args</span> = <span style=color:#a6e22e>framePool</span>.<span style=color:#a6e22e>Get</span>().(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>)
	} <span style=color:#66d9ef>else</span> {
		<span style=color:#a6e22e>args</span> = <span style=color:#a6e22e>unsafe_New</span>(<span style=color:#a6e22e>frametype</span>)
	}
	<span style=color:#a6e22e>off</span> <span style=color:#f92672>:=</span> uintptr(<span style=color:#ae81ff>0</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>rcvrtype</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>storeRcvr</span>(<span style=color:#a6e22e>rcvr</span>, <span style=color:#a6e22e>args</span>)
		<span style=color:#a6e22e>off</span> = <span style=color:#a6e22e>ptrSize</span>
	}
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>in</span> {
		<span style=color:#a6e22e>targ</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>In</span>(<span style=color:#a6e22e>i</span>).(<span style=color:#f92672>*</span><span style=color:#a6e22e>rtype</span>)
		<span style=color:#a6e22e>a</span> <span style=color:#f92672>:=</span> uintptr(<span style=color:#a6e22e>targ</span>.<span style=color:#a6e22e>align</span>)
		<span style=color:#a6e22e>off</span> = (<span style=color:#a6e22e>off</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>&amp;^</span> (<span style=color:#a6e22e>a</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
		<span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>targ</span>.<span style=color:#a6e22e>size</span>
		<span style=color:#f92672>...</span>
		<span style=color:#a6e22e>addr</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>args</span>, <span style=color:#a6e22e>off</span>, <span style=color:#e6db74>&#34;n &gt; 0&#34;</span>)
		<span style=color:#a6e22e>v</span> = <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>assignTo</span>(<span style=color:#e6db74>&#34;reflect.Value.Call&#34;</span>, <span style=color:#a6e22e>targ</span>, <span style=color:#a6e22e>addr</span>)
		<span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>)(<span style=color:#a6e22e>addr</span>) = <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>ptr</span>
		<span style=color:#a6e22e>off</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>n</span>
	}
</code></pre></div><ol>
<li>通过<a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/type.go#L3026>reflect.funcLayout</a>
计算当前函数需要的参数和返回值的栈布局，也就是每一个参数和返回值所占的空间大小；</li>
<li>如果当前函数有返回值，需要为当前函数的参数和返回值分配一片内存空间<code>args</code>；</li>
<li>如果当前函数是方法，需要向将方法的接收接收者者拷贝到<code>args</code>内存中；</li>
<li>将所有函数的参数按照顺序依次拷贝到对应<code>args</code>内存中
<ol>
<li>使用<a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/type.go#L3026>reflect.funcLayout</a>
返回的参数计算参数在内存中的位置；</li>
<li>将参数拷贝到内存空间中；</li>
</ol>
</li>
</ol>
<p>准备参数是计算各个参数和返回值占用的内存空间并将所有的参数都拷贝内存空间对应位置的过程，该过程会考虑函数和方法、返回值数量以及参数类型带来的差异。</p>
<h3 id=调用函数>调用函数</h3>
<p>准备好调用函数需要的全部参数后，就会通过下面的代码执行函数指针了。我们会向该函数传入栈类型、函数指针、参数和返回值的内存空间、
栈的大小以及返回值的偏移量：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>	<span style=color:#a6e22e>call</span>(<span style=color:#a6e22e>frametype</span>, <span style=color:#a6e22e>fn</span>, <span style=color:#a6e22e>args</span>, uint32(<span style=color:#a6e22e>frametype</span>.<span style=color:#a6e22e>size</span>), uint32(<span style=color:#a6e22e>retOffset</span>))
</code></pre></div><p>上述函数实际上并不存在，它会在编译期间链接到
<a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/runtime/asm_386.s#L492>reflect.reflectcall</a>
这个用汇编实现的函数上，我们在这里不会分析该函数的具体实现，感兴趣的读者可以自行了解其实现原理。</p>
<h3 id=处理返回值>处理返回值</h3>
<p>当函数调用结束之后，就会开始处理函数的返回值：</p>
<ul>
<li>如果函数没有任何返回值，会直接清空<code>args</code>中的全部内容来释放内存空间；</li>
<li>如果当前函数有返回值；
<ol>
<li>将<code>args</code>中与输入参数有关的内存空间清空；</li>
<li>创建一个nout长度的切片用于保存由反射对象构成的返回值数组；</li>
<li>从函数对象中获取返回值的类型和内存大小，将<code>args</code>内存中的数据转换成
<a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/value.go#L37>reflect.Value</a>
类型并存储到切片中；</li>
</ol>
</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ret</span> []<span style=color:#a6e22e>Value</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>nout</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
		<span style=color:#a6e22e>typedmemclr</span>(<span style=color:#a6e22e>frametype</span>, <span style=color:#a6e22e>args</span>)
		<span style=color:#a6e22e>framePool</span>.<span style=color:#a6e22e>Put</span>(<span style=color:#a6e22e>args</span>)
	} <span style=color:#66d9ef>else</span> {
		<span style=color:#a6e22e>typedmemclrpartial</span>(<span style=color:#a6e22e>frametype</span>, <span style=color:#a6e22e>args</span>, <span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>retOffset</span>)
		<span style=color:#a6e22e>ret</span> = make([]<span style=color:#a6e22e>Value</span>, <span style=color:#a6e22e>nout</span>)
		<span style=color:#a6e22e>off</span> = <span style=color:#a6e22e>retOffset</span>
		<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>nout</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
			<span style=color:#a6e22e>tv</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Out</span>(<span style=color:#a6e22e>i</span>)
			<span style=color:#a6e22e>a</span> <span style=color:#f92672>:=</span> uintptr(<span style=color:#a6e22e>tv</span>.<span style=color:#a6e22e>Align</span>())
			<span style=color:#a6e22e>off</span> = (<span style=color:#a6e22e>off</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>&amp;^</span> (<span style=color:#a6e22e>a</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>tv</span>.<span style=color:#a6e22e>Size</span>() <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
				<span style=color:#a6e22e>fl</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>flagIndir</span> | <span style=color:#a6e22e>flag</span>(<span style=color:#a6e22e>tv</span>.<span style=color:#a6e22e>Kind</span>())
				<span style=color:#a6e22e>ret</span>[<span style=color:#a6e22e>i</span>] = <span style=color:#a6e22e>Value</span>{<span style=color:#a6e22e>tv</span>.<span style=color:#a6e22e>common</span>(), <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>args</span>, <span style=color:#a6e22e>off</span>, <span style=color:#e6db74>&#34;tv.Size() != 0&#34;</span>), <span style=color:#a6e22e>fl</span>}
			} <span style=color:#66d9ef>else</span> {
				<span style=color:#a6e22e>ret</span>[<span style=color:#a6e22e>i</span>] = <span style=color:#a6e22e>Zero</span>(<span style=color:#a6e22e>tv</span>)
			}
			<span style=color:#a6e22e>off</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>tv</span>.<span style=color:#a6e22e>Size</span>()
		}
	}

	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>ret</span>
}
</code></pre></div><p>由<a href=https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/value.go#L37>reflect.Value</a>
构成的<code>ret</code>数组会被返回到调用方，到这里为止使用反射实现函数调用的过程就结束了。</p>
<h2 id=小结>小结</h2>
<p>Go语言的<a href=https://golang.org/pkg/reflect/>reflect</a> 包为我们提供了多种能力，包括如何使用反射来动态修改变量、
判断类型是否实现了某些接口以及动态调用方法等功能，通过分析反射包中方法的原理能帮助我们理解之前看起来比较怪异、令人困惑的现象。</p>
<h2 id=参考>参考</h2>
<ul>
<li>转载自<a href=https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-reflect/>Draveness Go语言设计与实现 4.3反射</a></li>
</ul>
</div>
<div class="row pl-3 pr-3">
<div class="col-md-6 share-buttons">
<strong>分享:</strong>
<a class="btn btn-sm reddit-btn" href="https://reddit.com/submit?url=https%3a%2f%2formissia.github.io%2fposts%2fknowledge%2f2003-go-reflect%2f&title=Golang%e5%8f%8d%e5%b0%84" target=_blank>
<i class="fab fa-reddit"></i>
</a>
<a class="btn btn-sm linkedin-btn" href="https://www.linkedin.com/shareArticle?url=https%3a%2f%2formissia.github.io%2fposts%2fknowledge%2f2003-go-reflect%2f&title=Golang%e5%8f%8d%e5%b0%84" target=_blank>
<i class="fab fa-linkedin"></i>
</a>
<a class="btn btn-sm email-btn" href="mailto:?subject=Golang%e5%8f%8d%e5%b0%84&body=https%3a%2f%2formissia.github.io%2fposts%2fknowledge%2f2003-go-reflect%2f" target=_blank>
<i class="fas fa-envelope-open-text"></i>
</a>
</div>
<div class="col-md-6 btn-improve-page">
<a href=https://github.com/ormissia/ormissia.github.io/edit/master/content/posts/knowledge/2003-go-reflect/index.md title=改善此页面 target=_blank rel=noopener>
<i class="fas fa-code-branch"></i>
改善此页面
</a>
</div>
</div>
<hr>
<div class="row next-prev-navigator">
<div class="col-md-6 previous-article">
<a href=/posts/knowledge/2002-go-param-verify/ title="Golang 实体参数校验" class="btn btn-outline-info">
<div><i class="fas fa-chevron-circle-left"></i> 上一篇</div>
<div class=next-prev-text>Golang 实体参数校验</div>
</a>
</div>
<div class="col-md-6 next-article">
<a href=/posts/knowledge/2004-go-pprof/ title=Golang性能分析工具-pprof class="btn btn-outline-info">
<div>下一篇 <i class="fas fa-chevron-circle-right"></i></div>
<div class=next-prev-text>Golang性能分析工具-pprof</div>
</a>
</div>
</div>
<hr>
<div id=utteranc_thread></div>
<div id=comments class=comments>
<div id=comments-container></div>
</div>
<script type=text/javascript>(function(){var a=document.createElement('script');a.type='text/javascript',a.async=!0,a.setAttribute('repo','ormissia/ormissia.github.io'),a.setAttribute('issue-term','title'),a.setAttribute('theme','github-light'),a.crossorigin='anonymous',a.src='https://utteranc.es/client.js',document.getElementById('comments-container').appendChild(a)})()</script>
</div>
</div>
</div>
<a id=scroll-to-top class=btn><i class="fas fa-chevron-circle-up"></i></a>
</section>
<section class=toc-section id=toc-section>
<div class=toc-holder>
<h5 class="text-center pl-3">目录</h5>
<hr>
<div class=toc>
<nav id=TableOfContents>
<ul>
<li><a href=#反射简介>反射简介</a></li>
<li><a href=#三大法则>三大法则</a>
<ul>
<li><a href=#第一法则>第一法则</a></li>
<li><a href=#第二法则>第二法则</a></li>
<li><a href=#第三法则>第三法则</a></li>
</ul>
</li>
<li><a href=#类型和值>类型和值</a></li>
<li><a href=#更新变量>更新变量</a></li>
<li><a href=#实现协议>实现协议</a></li>
<li><a href=#方法调用>方法调用</a>
<ul>
<li><a href=#参数检查>参数检查</a></li>
<li><a href=#准备参数>准备参数</a></li>
<li><a href=#调用函数>调用函数</a></li>
<li><a href=#处理返回值>处理返回值</a></li>
</ul>
</li>
<li><a href=#小结>小结</a></li>
<li><a href=#参考>参考</a></li>
</ul>
</nav>
</div>
</div>
</section>
</div>
<footer class="container-fluid text-center align-content-center footer pb-2">
<div class="container pt-5">
<div class="row text-left">
<div class="col-md-4 col-sm-12">
<h5>联系方式:</h5>
<ul>
<li><span>QQ: </span> <span>1432050813</span></li>
<li><a href=mailto:ormissia@outlook.com target=_blank rel=noopener>
<span><i class="fas fa-envelope"></i></span> <span>ormissia@outlook.com</span>
</a></li>
</ul>
</div>
</div>
</div>
<hr>
<div class=container>
<p id=disclaimer><strong>免责声明:</strong> 老铁看到底了，要负责的哦</p>
</div>
<hr>
<div class=container>
<div class="row text-left">
<div class=col-md-4>
<a id=theme href=https://github.com/hossainemruz/toha target=_blank rel=noopener>
<img src=/images/theme-logo_hu8376fd15465fef26ffe66b6bcf0ca686_13669_32x0_resize_box_3.png alt="Toha Theme Logo">
Toha
</a>
</div>
<div class="col-md-4 text-center">© 2021 Copyright.</div>
<div class="col-md-4 text-right">
<a id=hugo href=https://gohugo.io/ target=_blank rel=noopener>Powered by
<img src=/images/hugo-logo.svg alt="Hugo Logo" height=18>
</a>
</div>
</div>
</div>
</footer>
<script type=text/javascript src=/js/jquery-3.4.1.min.js></script>
<script type=text/javascript src=/js/popper.min.js></script>
<script type=text/javascript src=/js/bootstrap.min.js></script>
<script type=text/javascript src=/js/navbar.js></script>
<script type=text/javascript src=/js/plyr.js></script>
<script type=text/javascript src=/js/main.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js></script>
<script src=/js/single.js></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>