<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>环境部署 on Ormissia's Blog</title><link>https://ormissia.github.io/posts/deployment/</link><description>Recent content in 环境部署 on Ormissia's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 03 Mar 2021 18:00:20 +0600</lastBuildDate><atom:link href="https://ormissia.github.io/posts/deployment/index.xml" rel="self" type="application/rss+xml"/><item><title>我的博客后端Docker镜像打包自动部署流程</title><link>https://ormissia.github.io/posts/deployment/2021-03-03t180020+0600/</link><pubDate>Wed, 03 Mar 2021 18:00:20 +0600</pubDate><guid>https://ormissia.github.io/posts/deployment/2021-03-03t180020+0600/</guid><description>博客后端使用Golang重构之后使用GitHub-DockerHub-Jenkins自动打包部署流程
虽然说Golang打包生成的是二进制可执行文件，不需要像JAVA一样部署环境变量，但依然也是需要打包的流程。由于考虑到在不(hen)久(yuan)的将来可能做成简单的微服务程序，又要使用Docker部署，所以在这就直接使用Docker镜像的方式来部署运行。
本地代码→GitHub 这一步是通过git commit-git push或是直接使用IDE将代码托管到GitHub上。 在这一步的同时需要编写Dockerfile文件，用来指定Docker镜像打包时的各种参数
# Go程序编译之后会得到一个可执行的二进制文件，其实在最终的镜像中是不需要go编译器的，也就是说我们只需要一个运行最终二进制文件的容器即可。# 作为别名为&amp;#34;builder&amp;#34;的编译镜像，下面会用到FROMgolang AS builder# 为镜像设置必要的环境变量ENV GO111MODULE=on \ CGO_ENABLED=0 \ GOOS=linux \ GOARCH=amd64 \ GOPROXY=https://goproxy.cn# 设置工作目录：/buildWORKDIR/build# 复制项目中的 go.mod 和 go.sum文件并下载依赖信息COPY go.mod .COPY go.sum .RUN go mod download# 将代码复制到容器中COPY 2021-03-04T18:02:29 .# 将代码编译成二进制可执行文件appRUN go build -o go-blog-app .#################### 接下来创建一个小镜像###################FROMscratch# 设置程序运行时必要的环境变量，包括监听端口、数据库配置等等ENV SERVER_PORT=8085 \ DATASOURCE_DRIVERNAME=mysql \ DATASOURCE_HOST=192.168.13.110 \ DATASOURCE_PORT=3306 \ DATASOURCE_DATABASE=blog \ DATASOURCE_USERNAME=root \ DATASOURCE_PASSWORD=5KvA82*Ziq \ DATASOURCE_CHARSET=utf8mb4# 从builder镜像中把/dist/app 拷贝到当前目录COPY --from=builder /build/go-blog-app /# 声明服务端口EXPOSE8085# 启动容器时运行的命令ENTRYPOINT [&amp;#34;/go-blog-app&amp;#34;]GitHub→Docker Hub 这一步是将GitHub上的代码打包成Docker镜像并将镜像托管到Docker Hub上，我在这里使用的是使用Docker Hub来自动打包Docker镜像。也有另一种方式是GitHub通过设置好的Webhooks来通知Jenkins等CI/CD工具来拉取代码在自己的服务器上打包Docker镜像再上传到Docker Hub或是其他Docker镜像管理工具上，由于自己的这个项目代码更新比较慢，可以容忍提交代码之后有较长的时间来更新到线上环境中，所以就采用了Docker官方的打包功能。</description></item></channel></rss>