<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>算法 on Ormissia's Blog</title><link>https://ormissia.github.io/posts/algorithm/</link><description>Recent content in 算法 on Ormissia's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 07 Aug 2021 12:52:56 +0800</lastBuildDate><atom:link href="https://ormissia.github.io/posts/algorithm/index.xml" rel="self" type="application/rss+xml"/><item><title>排序算法</title><link>https://ormissia.github.io/posts/algorithm/4001-algorithm-sort/</link><pubDate>Sat, 07 Aug 2021 12:52:56 +0800</pubDate><guid>https://ormissia.github.io/posts/algorithm/4001-algorithm-sort/</guid><description>归并排序 思想：整体是递归（当然可以用非递归实现），使左边有序，使右边有序，合并左边右边使整体有序
核心代码：
func merge(arr []interface{}, l, mid, r int, compare Compare) { help := make([]interface{}, r-l+1) i := 0 p1 := l p2 := mid + 1 for p1 &amp;lt;= mid &amp;amp;&amp;amp; p2 &amp;lt;= r { if compare(arr[p1], arr[p2]) { help[i] = arr[p1] p1++ } else { help[i] = arr[p2] p2++ } i++ } //要么p1越界了，要么p2越界了 for p1 &amp;lt;= mid { help[i] = arr[p1] i++ p1++ } for p2 &amp;lt;= r { help[i] = arr[p2] i++ p2++ } for j, _ := range help { arr[l+j] = help[j] } } 递归 核心代码</description></item></channel></rss>